diff --git a/bin/omarchy-windows-vm b/bin/omarchy-windows-vm
index f9034d48..1deb971d 100755
--- a/bin/omarchy-windows-vm
+++ b/bin/omarchy-windows-vm
@@ -1,390 +1,3820 @@
 #!/bin/bash
+
+# Get script directory for accessing resources (icons, etc.)
+SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
+
 COMPOSE_FILE="$HOME/.config/windows/docker-compose.yml"
+DOCKER_IMAGE="dockurr/windows:latest"
+SPICE_DIR="/var/run/omarchy-windows"      # SPICE socket directory (tmpfs, auto-cleaned on reboot)
+SPICE_SOCKET_PATH="$SPICE_DIR/spice.sock" # SPICE Unix socket from dockurr/windows container
+
+msg_error() {
+  echo "❌  Error: $*" >&2
+}
+
+msg_warning() {
+  echo "⚠️  Warning: $*" >&2
+}
+
+msg_success() {
+  echo "✓  $*"
+}
+
+msg_info() {
+  echo "ℹ️  $*"
+}
+
+notify_silent() {
+  local title="$1"
+  local message="$2"
+  local urgency="${3:-normal}"
+
+  if command -v notify-send &>/dev/null; then
+    notify-send -u "$urgency" -- "$title" "$message" 2>/dev/null || true
+  fi
+}
+
+run_with_spinner() {
+  local message="$1"
+  shift
+  local spinner=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
+  local spin_idx=0
+
+  "$@" &
+  local pid=$!
+
+  while kill -0 $pid 2>/dev/null; do
+    printf "\r%s %s " "$message" "${spinner[$spin_idx]}"
+    spin_idx=$(( (spin_idx + 1) % ${#spinner[@]} ))
+    sleep 0.1
+  done
+
+  wait $pid
+  local exit_code=$?
+  printf "\r%s   \r" "$message"
+  return $exit_code
+}
+
+# Returns: 0=already in group, 1=added (relogin needed), 2=failed
+ensure_user_in_kvm_group() {
+  if groups "$USER" | grep -q kvm; then
+    return 0
+  fi
+
+  # Use -n to avoid blocking in background processes
+  if sudo -n usermod -aG kvm "$USER" 2>/dev/null; then
+    return 1
+  else
+    return 2
+  fi
+}
+
+is_looking_glass_ready() {
+  command -v looking-glass-client &>/dev/null &&
+    lsmod | grep -q kvmfr &&
+    [[ -e /dev/kvmfr0 ]]
+}
+
+get_escape_key_display() {
+  local lg_config="$HOME/.config/looking-glass/client.ini"
+  local escape_key="Scroll Lock"
+
+  if [[ -f "$lg_config" ]]; then
+    local raw_key=$(grep -E '^\s*escapeKey\s*=' "$lg_config" 2>/dev/null | sed 's/^.*=\s*//' | tr -d ' "')
+    case "$raw_key" in
+      KEY_SCROLLLOCK) escape_key="Scroll Lock" ;;
+      KEY_RIGHTCTRL)  escape_key="Right Ctrl" ;;
+      KEY_LEFTCTRL)   escape_key="Left Ctrl" ;;
+      KEY_RIGHTALT)   escape_key="Right Alt" ;;
+      KEY_PAUSE)      escape_key="Pause" ;;
+      KEY_INSERT)     escape_key="Insert" ;;
+      "") ;;  # No key set, use default
+      *) escape_key="${raw_key#KEY_}" ;;  # Strip KEY_ prefix for unknown keys
+    esac
+  fi
+
+  echo "$escape_key"
+}
+
+check_docker_running() {
+  if docker ps &>/dev/null; then
+    return 0
+  fi
+
+  msg_error "Docker is not running"
+  echo "   Start: sudo systemctl start docker"
+  exit 1
+}
+
+# Get container status by name
+get_container_status() {
+  local container_name="${1:-omarchy-windows}"
+  docker inspect --format='{{.State.Status}}' "$container_name" 2>/dev/null
+}
+
+get_rdp_scale() {
+  command -v jq &>/dev/null || return
+  local hypr_scale=$(hyprctl monitors -j 2>/dev/null | jq -r '.[] | select (.focused == true) | .scale' 2>/dev/null)
+  [[ -z "$hypr_scale" ]] && return
+
+  local scale_percent=$(echo "$hypr_scale" | awk '{print int($1 * 100)}')
+  [[ "$scale_percent" =~ ^[0-9]+$ ]] || return
+
+  [[ "$scale_percent" -ge 170 ]] && echo "/scale:180" && return
+  [[ "$scale_percent" -ge 130 ]] && echo "/scale:140"
+}
+
+test_rdp_ready() {
+  local -r X224_CR="\x03\x00\x00\x13\x0e\xe0\x00\x00\x00\x00\x00\x01\x00\x08\x00\x03\x00\x00\x00"
+
+  printf '%b' "$X224_CR" | timeout 2 nc -w2 127.0.0.1 3389 2>/dev/null |
+    head -c2 | od -An -tx1 | tr -d ' \n' | grep -q "^0300$"
+}
+
+# Check and warn about GPU IOTLB errors (AMD reset bug)
+warn_if_gpu_iotlb_error() {
+  if command -v omarchy-gpu-passthrough-info &>/dev/null; then
+    if omarchy-gpu-passthrough-info gpu-health &>/dev/null; then
+      msg_warning "GPU Health: IOTLB_INV_TIMEOUT detected"
+      echo "   The GPU may need a cold boot (poweroff + unplug power 30s)"
+      echo "   Details: omarchy-gpu-passthrough-info health"
+    fi
+  fi
+}
+
+convert_to_crlf() {
+  local file="$1"
+  [[ ! -f "$file" ]] && {
+    msg_error "File not found: $file"
+    return 1
+  }
+
+  sed -i -e 's/\r$//' -e 's/$/\r/' "$file" || return 1
+}
+
+# Connect to Windows VM via RDP
+# Parameters:
+#   $1 - USERNAME
+#   $2 - PASSWORD
+#   $3 - BACKGROUND: true (detached) or false (foreground) - default: false
+connect_rdp() {
+  local USERNAME="$1"
+  local PASSWORD="$2"
+  local BACKGROUND="${3:-false}"
+
+  local RDP_SCALE=$(get_rdp_scale)
+
+  if ! command -v xfreerdp3 &>/dev/null; then
+    echo ""
+    msg_warning "xfreerdp3 not found - cannot launch RDP"
+    echo "   Install freerdp: omarchy-pkg-add freerdp"
+    echo "   Or manually connect via VNC: http://127.0.0.1:8006"
+    echo ""
+    if [[ "$BACKGROUND" == true ]]; then
+      echo "Windows VM is running in background."
+      echo "After installing freerdp, connect with: omarchy-windows-vm launch"
+    fi
+    return 1
+  fi
+
+  local RDP_ARGS=(
+    /u:"$USERNAME"
+    /p:"$PASSWORD"
+    /v:127.0.0.1:3389
+    -grab-keyboard
+    /sound
+    /microphone
+    /cert:ignore
+    /title:"Windows VM - Omarchy"
+    /dynamic-resolution
+    /gfx:AVC444
+    /floatbar:sticky:off,default:visible,show:fullscreen
+  )
+  [[ -n "$RDP_SCALE" ]] && RDP_ARGS+=("$RDP_SCALE")
+
+  if [[ "$BACKGROUND" == true ]]; then
+    # Background mode: User can close terminal and keep using Windows
+    setsid uwsm-app -- xfreerdp3 "${RDP_ARGS[@]}" >/dev/null 2>&1 &
+
+    echo ""
+    msg_success "RDP window opened in background"
+    echo "   You can close this terminal/browser and keep using Windows"
+    echo ""
+  else
+    # Foreground mode: Wait for RDP to close (for --keep-alive logic)
+    # Note: Keyboard shortcuts are printed by launch_windows() before calling connect_rdp()
+    local MAX_RETRIES=3
+    local ATTEMPT=1
+
+    while [[ $ATTEMPT -le $MAX_RETRIES ]]; do
+      setsid xfreerdp3 "${RDP_ARGS[@]}" >/dev/null 2>&1 &
+      local RDP_PID=$!
+      local START_TIME=$(date +%s)
+
+      wait $RDP_PID
+      local RDP_EXIT=$?
+      local END_TIME=$(date +%s)
+      local ELAPSED=$((END_TIME - START_TIME))
+
+      # If RDP session lasted more than 3 seconds, consider it a real session (user closed it)
+      # If it failed quickly (<3s) with error, it was likely a connection failure - retry
+      if [[ $ELAPSED -gt 3 ]] || [[ $RDP_EXIT -eq 0 ]]; then
+        return $RDP_EXIT
+      fi
+
+      ATTEMPT=$((ATTEMPT + 1))
+      if [[ $ATTEMPT -le $MAX_RETRIES ]]; then
+        echo "RDP connection failed, waiting for Windows to be ready... (attempt $ATTEMPT/$MAX_RETRIES)"
+
+        # Wait for RDP service to be ready (up to 30s per retry)
+        local WAIT_ELAPSED=0
+        local WAIT_MAX=30
+        while [[ $WAIT_ELAPSED -lt $WAIT_MAX ]]; do
+          if test_rdp_ready; then
+            echo "  RDP ready, connecting..."
+            break
+          fi
+          sleep 3
+          WAIT_ELAPSED=$((WAIT_ELAPSED + 3))
+          echo "  Waiting for RDP service... (${WAIT_ELAPSED}s)"
+        done
+      fi
+    done
+
+    echo "RDP connection failed after $MAX_RETRIES attempts"
+    return 1
+  fi
+}
+
+# Check KVM virtualization support
+check_kvm_available() {
+  if [[ ! -e /dev/kvm ]]; then
+    msg_error "KVM virtualization not available!"
+    echo ""
+    echo "   Please enable virtualization in BIOS or run:"
+    echo "     sudo modprobe kvm-intel  # for Intel CPUs"
+    echo "     sudo modprobe kvm-amd    # for AMD CPUs"
+    return 1
+  fi
+  return 0
+}
+
+check_prerequisites() {
+  local DISK_SIZE_GB=${1:-64}
+  local REQUIRED_SPACE=$((DISK_SIZE_GB + 10)) # Add 10GB for Windows ISO and overhead
+
+  if ! check_kvm_available; then
+    exit 1
+  fi
+
+  AVAILABLE_SPACE=$(df "$HOME" | awk 'NR==2 {print int($4/1024/1024)}')
+
+  if ! [[ "$AVAILABLE_SPACE" =~ ^[0-9]+$ ]] || [[ "$AVAILABLE_SPACE" -eq 0 ]]; then
+    msg_error "Failed to calculate available disk space!"
+    echo "   Could not determine space on $HOME"
+    exit 1
+  fi
+
+  if [[ "$AVAILABLE_SPACE" -lt "$REQUIRED_SPACE" ]]; then
+    msg_error "Insufficient disk space!"
+    echo "   Available: ${AVAILABLE_SPACE}GB"
+    echo "   Required: ${REQUIRED_SPACE}GB (${DISK_SIZE_GB}GB disk + 10GB for Windows image)"
+    exit 1
+  fi
+}
+
+check_vm_configured() {
+  if [[ ! -f "$COMPOSE_FILE" ]]; then
+    msg_error "Windows VM not configured"
+    echo "   Run: omarchy-windows-vm install"
+    exit 1
+  fi
+}
+
+configure_sudoers_windows_vm() {
+  local sudoers_file="/etc/sudoers.d/omarchy-windows-vm"
+
+  if sudo test -f "$sudoers_file"; then
+    return 0
+  fi
+
+  local sudoers_content="# Omarchy Windows VM - Passwordless Operations
+# Generated by omarchy-windows-vm install
+
+# System information (SMBIOS spoofing for anti-cheat)
+$USER ALL=(ALL) NOPASSWD: /usr/bin/dmidecode -s *
+$USER ALL=(ALL) NOPASSWD: /usr/bin/dmidecode -t processor
+"
+
+  local temp_file
+  temp_file=$(mktemp)
+  echo "$sudoers_content" > "$temp_file"
+
+  if ! sudo visudo -c -f "$temp_file" 2>&1 | grep -q "parsed OK"; then
+    msg_warning "Sudoers syntax validation failed - skipping"
+    rm -f "$temp_file"
+    return 1
+  fi
+
+  if sudo install -m 440 -o root -g root "$temp_file" "$sudoers_file"; then
+    rm -f "$temp_file"
+    if ! sudo visudo -c 2>&1 | grep -q "parsed OK"; then
+      msg_warning "Sudoers file issue - removing"
+      sudo rm -f "$sudoers_file"
+      return 1
+    fi
+  else
+    msg_warning "Failed to install sudoers file"
+    rm -f "$temp_file"
+    return 1
+  fi
+
+  return 0
+}
+
+install_looking_glass_client() {
+  # Returns: 0=success, 1=reboot needed, 2=failed
+  # This is a wrapper that calls the dedicated installation script
+
+  if is_looking_glass_ready; then
+    msg_success "Looking Glass already installed"
+    if [[ -f /etc/modprobe.d/kvmfr.conf ]]; then
+      IVSHMEM_SIZE=$(grep -oP 'static_size_mb=\K\d+' /etc/modprobe.d/kvmfr.conf 2>/dev/null || echo "64")
+    else
+      IVSHMEM_SIZE=64
+    fi
+    export IVSHMEM_SIZE
+    return 0
+  fi
+
+  if ! command -v omarchy-looking-glass-install &>/dev/null; then
+    msg_error "omarchy-looking-glass-install not found"
+    echo "   Make sure Omarchy scripts are in PATH"
+    return 2
+  fi
+
+  echo "Running Looking Glass installation..."
+
+  # Note: Script handles all installation steps interactively
+  # It will ask user for resolution choice (1080p/1440p/4K)
+  # FORCE_RECONFIGURE=1 allows user to change resolution on each install
+  if FORCE_RECONFIGURE=1 omarchy-looking-glass-install; then
+    if [[ -f /etc/modprobe.d/kvmfr.conf ]]; then
+      IVSHMEM_SIZE=$(grep -oP 'static_size_mb=\K\d+' /etc/modprobe.d/kvmfr.conf 2>/dev/null || echo "64")
+    else
+      IVSHMEM_SIZE=64
+    fi
+    export IVSHMEM_SIZE
+
+    if ! is_looking_glass_ready; then
+      return 1
+    fi
+    return 0
+  else
+    echo ""
+    msg_error "Looking Glass installation failed"
+    return 2
+  fi
+}
+
+create_oem_powershell_script() {
+  local OEM_DIR="$1"
+  local SCRIPT_VERSION="$2"
+
+  printf '\xEF\xBB\xBF' >"$OEM_DIR/install.ps1"
+  cat >>"$OEM_DIR/install.ps1" <<'EOFPS1'
+# Omarchy Windows VM Setup Script
+# This script runs automatically after Windows installation completes
+# Logs are saved to C:\OEM\install-log.txt for debugging
+
+$LogFile = "C:\OEM\install-log.txt"
+
+# Initialize log file (create if doesn't exist)
+try {
+    if (-not (Test-Path $LogFile)) {
+        New-Item -ItemType File -Path $LogFile -Force | Out-Null
+    }
+}
+catch {
+    # If we can't create log file, continue anyway (logs will only go to console)
+    Write-Host "WARNING: Could not create log file at $LogFile" -ForegroundColor Yellow
+}
+
+function Write-Log {
+    param([string]$Message, [string]$Color = "White")
+    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
+    $logEntry = "[$timestamp] $Message"
+    Write-Host $Message -ForegroundColor $Color
+
+    try {
+        Add-Content -Path $LogFile -Value $logEntry -Encoding UTF8 -ErrorAction Stop
+    }
+    catch {
+        # Silently continue if log write fails
+    }
+}
+
+Write-Log "=== Omarchy Windows VM Setup Script ===" "Cyan"
+Write-Log "Version: SCRIPT_VERSION_PLACEHOLDER" "Gray"
+Write-Log "Windows installation complete - running Omarchy setup..." "Green"
+Write-Log ""
+
+function Set-InstallationMarker {
+    Write-Log "Creating installation completion marker..."
+
+    try {
+        Write-Log "Mounting shared folder \\host.lan\Data as Z:..."
+        $null = net use Z: \\host.lan\Data /persistent:yes 2>&1
+
+        $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
+        $markerContent = "Installation completed at $timestamp"
+
+        if (Test-Path "Z:\") {
+            $markerContent | Out-File -FilePath "Z:\installation-complete.txt" -Encoding UTF8
+            Write-Log "✓ Marker file created: Z:\installation-complete.txt" "Green"
+        }
+        else {
+            Write-Log "WARNING: Z: drive not available, trying UNC path..." "Yellow"
+            $markerContent | Out-File -FilePath "\\host.lan\Data\installation-complete.txt" -Encoding UTF8
+
+            if (Test-Path "\\host.lan\Data\installation-complete.txt") {
+                Write-Log "✓ Marker file created via UNC path" "Green"
+            }
+            else {
+                Write-Log "ERROR: Failed to create marker file!" "Red"
+            }
+        }
+    }
+    catch {
+        Write-Log "ERROR creating marker: $($_.Exception.Message)" "Red"
+    }
+}
+
+function Install-LookingGlass {
+    $installer = "C:\OEM\looking-glass-host-setup.exe"
+
+    if (Test-Path $installer) {
+        Write-Log "Installing Looking Glass host..." "Cyan"
+        Write-Log "  Installer: $installer" "Gray"
+        Write-Log "  Installer size: $((Get-Item $installer).Length) bytes" "Gray"
+
+        try {
+            # Log execution context for debugging
+            Write-Log "  Current user: $env:USERNAME" "Gray"
+            Write-Log "  User domain: $env:USERDOMAIN" "Gray"
+            Write-Log "  Running as admin: $(([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator))" "Gray"
+
+            # Start installer with timeout to prevent hanging
+            # Using only /S for NSIS silent install (not Inno Setup params)
+            # IMPORTANT: Do NOT use -NoNewWindow or redirect stdout/stderr during OEM setup
+            # as it can cause the installer to hang waiting for console
+            Write-Log "  Starting installer (NSIS silent mode with 120s timeout)..." "Gray"
+            Write-Log "  Command: $installer /S" "Gray"
+
+            $process = Start-Process -FilePath $installer -ArgumentList "/S" -PassThru -WindowStyle Hidden -ErrorAction Stop
+
+            # Wait max 120 seconds (2 minutes) for installation
+            # NSIS installers are typically fast, longer timeout suggests hang
+            $timeout = 120
+            $waitResult = $process.WaitForExit($timeout * 1000)
+
+            if ($waitResult) {
+                $exitCode = $process.ExitCode
+                Write-Log "  Installer finished with exit code: $exitCode" "Gray"
+
+                # Check if installation actually succeeded by looking for files
+                $lgPaths = @(
+                    "C:\Program Files\Looking Glass (host)",
+                    "C:\Program Files (x86)\Looking Glass (host)"
+                )
+
+                $installed = $false
+                foreach ($path in $lgPaths) {
+                    if (Test-Path $path) {
+                        Write-Log "  Found installation at: $path" "Gray"
+                        $installed = $true
+                        break
+                    }
+                }
+
+                if ($installed) {
+                    Write-Log "✓ Looking Glass host installation complete!" "Green"
+
+                    # Verify Looking Glass service
+                    Start-Sleep -Seconds 1
+                    $lgService = Get-Service -Name "looking-glass-host" -ErrorAction SilentlyContinue
+                    if ($lgService) {
+                        Write-Log "  Service detected: $($lgService.Status)" "Gray"
+                        Write-Log "  The service will start after reboot." "Gray"
+                    } else {
+                        Write-Log "  Service not yet registered (will be available after reboot)" "Gray"
+                    }
+                }
+                elseif ($exitCode -eq 0) {
+                    Write-Log "✓ Installer completed (exit code 0)" "Green"
+                    Write-Log "  Installation directory not verified (may be custom location)" "Gray"
+                }
+                else {
+                    Write-Log "WARNING: Installation may have failed (exit code: $exitCode)" "Yellow"
+                    Write-Log "  Continuing with setup anyway..." "Gray"
+                }
+            }
+            else {
+                Write-Log "WARNING: Looking Glass installer did not complete within $timeout seconds" "Yellow"
+                Write-Log "  This likely means the installer hung or requires user interaction" "Yellow"
+                Write-Log "  Attempting to terminate installer process..." "Gray"
+
+                try {
+                    if (-not $process.HasExited) {
+                        $process.Kill()
+                        $process.WaitForExit(5000)  # Wait 5s for graceful termination
+                        Write-Log "  Process terminated" "Gray"
+                    }
+                }
+                catch {
+                    Write-Log "  Could not terminate process: $_" "Gray"
+                }
+
+                Write-Log "  Continuing with remaining setup tasks..." "Yellow"
+            }
+        }
+        catch {
+            Write-Log "ERROR starting Looking Glass installer: $($_.Exception.Message)" "Red"
+            Write-Log "  Continuing with remaining setup tasks..." "Yellow"
+        }
+    }
+    else {
+        Write-Log "Looking Glass installer not found at: $installer" "Yellow"
+        Write-Log "  Expected during installation with GPU passthrough" "Gray"
+    }
+}
+
+function Install-SpiceGuestTools {
+    $installer = "C:\OEM\spice-guest-tools-setup.exe"
+
+    if (Test-Path $installer) {
+        Write-Log "Installing SPICE Guest Tools..." "Cyan"
+        Write-Log "  Installer: $installer" "Gray"
+        Write-Log "  Installer size: $((Get-Item $installer).Length) bytes" "Gray"
+
+        try {
+            # Log execution context for debugging
+            Write-Log "  Current user: $env:USERNAME" "Gray"
+            Write-Log "  User domain: $env:USERDOMAIN" "Gray"
+            Write-Log "  Running as admin: $(([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator))" "Gray"
+
+            # Use schtasks to run installer as SYSTEM (prevents driver approval prompts)
+            # Windows OEM setup may run as user context, but SPICE drivers require SYSTEM
+            $taskName = "OmarchyInstallSPICE"
+            Write-Log "  Creating scheduled task to run as SYSTEM (bypass driver prompts)..." "Gray"
+
+            # Create task (force overwrite if exists)
+            $taskCmd = "`"$installer`" /S"
+            schtasks /Create /TN $taskName /TR $taskCmd /SC ONCE /ST 00:00 /RU SYSTEM /RL HIGHEST /F | Out-Null
+
+            if ($LASTEXITCODE -ne 0) {
+                Write-Log "WARNING: Could not create scheduled task (code: $LASTEXITCODE)" "Yellow"
+                Write-Log "  Falling back to direct execution..." "Gray"
+
+                # Fallback: run directly
+                $process = Start-Process -FilePath $installer -ArgumentList "/S" -PassThru -WindowStyle Hidden -ErrorAction Stop
+                $timeout = 120
+                $waitResult = $process.WaitForExit($timeout * 1000)
+
+                if (-not $waitResult) {
+                    Write-Log "WARNING: Installer timeout, may require user interaction" "Yellow"
+                    if (-not $process.HasExited) {
+                        $process.Kill()
+                        $process.WaitForExit(5000)
+                    }
+                }
+
+                if ($process.HasExited) {
+                    $exitCode = $process.ExitCode
+                } else {
+                    $exitCode = -1  # Timeout
+                }
+            }
+            else {
+                # Run task immediately
+                Write-Log "  Executing installer as SYSTEM..." "Gray"
+                schtasks /Run /TN $taskName | Out-Null
+
+                # Wait for task to complete (max 120 seconds)
+                $timeout = 120
+                $elapsed = 0
+                $exitCode = 0
+
+                while ($elapsed -lt $timeout) {
+                    Start-Sleep -Seconds 2
+                    $elapsed += 2
+
+                    # Query task status
+                    $taskInfo = schtasks /Query /TN $taskName /FO LIST 2>&1 | Out-String
+                    if ($taskInfo -match "Status:\s+(.+)") {
+                        $status = $matches[1].Trim()
+                        if ($status -ne "Running") {
+                            Write-Log "  Task completed (status: $status)" "Gray"
+                            break
+                        }
+                    }
+                }
+
+                if ($elapsed -ge $timeout) {
+                    Write-Log "WARNING: SPICE installer did not complete within $timeout seconds" "Yellow"
+                }
+
+                # Delete task
+                schtasks /Delete /TN $taskName /F 2>&1 | Out-Null
+            }
+
+            # Check if installation actually succeeded by looking for SPICE agent
+            Start-Sleep -Seconds 2  # Give filesystem time to update
+
+            $spicePaths = @(
+                "C:\Program Files\SPICE Guest Tools",
+                "C:\Program Files (x86)\SPICE Guest Tools",
+                "C:\Windows\System32\drivers\vioser.sys"
+            )
+
+            $installed = $false
+            foreach ($path in $spicePaths) {
+                if (Test-Path $path) {
+                    Write-Log "  Found SPICE installation at: $path" "Gray"
+                    $installed = $true
+                    break
+                }
+            }
+
+            if ($installed) {
+                Write-Log "✓ SPICE Guest Tools installation complete!" "Green"
+                Write-Log "  Auto-resolution, clipboard, and copy-paste will be available after reboot." "Gray"
+            }
+            elseif ($exitCode -eq 0) {
+                Write-Log "✓ Installer completed (exit code 0)" "Green"
+                Write-Log "  Installation directory not verified (may be custom location)" "Gray"
+            }
+            else {
+                Write-Log "WARNING: Installation may have failed (exit code: $exitCode)" "Yellow"
+                Write-Log "  Continuing with setup anyway..." "Gray"
+            }
+        }
+        catch {
+            Write-Log "ERROR starting SPICE Guest Tools installer: $($_.Exception.Message)" "Red"
+            Write-Log "  Continuing with remaining setup tasks..." "Yellow"
+        }
+    }
+    else {
+        Write-Log "SPICE Guest Tools installer not found at: $installer" "Yellow"
+        Write-Log "  Expected during installation with Looking Glass and GPU passthrough" "Gray"
+    }
+}
+
+function Set-OmarchyWallpaper {
+    $wallpaperSrc = "C:\OEM\wallpaper\omarchy.png"
+    $wallpaperDst = "C:\Windows\Web\Wallpaper\Omarchy\omarchy.png"
+
+    if (Test-Path $wallpaperSrc) {
+        Write-Log "Setting up Omarchy wallpaper..."
+
+        try {
+            $wallpaperDir = Split-Path -Parent $wallpaperDst
+            if (-not (Test-Path $wallpaperDir)) {
+                New-Item -ItemType Directory -Path $wallpaperDir -Force | Out-Null
+            }
+            Copy-Item -Path $wallpaperSrc -Destination $wallpaperDst -Force
+            Write-Log "  Wallpaper copied to: $wallpaperDst" "Gray"
+
+            Set-ItemProperty -Path 'HKCU:\Control Panel\Desktop' -Name Wallpaper -Value $wallpaperDst -ErrorAction SilentlyContinue
+
+            Add-Type -TypeDefinition @"
+using System;
+using System.Runtime.InteropServices;
+public class Wallpaper {
+    [DllImport("user32.dll", CharSet = CharSet.Auto)]
+    public static extern int SystemParametersInfo(int uAction, int uParam, string lpvParam, int fuWinIni);
+}
+"@ -ErrorAction SilentlyContinue
+
+            $SPI_SETDESKWALLPAPER = 0x0014
+            $SPIF_UPDATEINIFILE = 0x0001
+            $SPIF_SENDCHANGE = 0x0002
+
+            [Wallpaper]::SystemParametersInfo($SPI_SETDESKWALLPAPER, 0, $wallpaperDst, $SPIF_UPDATEINIFILE -bor $SPIF_SENDCHANGE) | Out-Null
+
+            Write-Log "✓ Omarchy wallpaper set successfully" "Green"
+            Write-Log "  Note: Wallpaper applies immediately (no login required)" "Gray"
+        }
+        catch {
+            Write-Log "ERROR setting wallpaper: $($_.Exception.Message)" "Red"
+        }
+    }
+    else {
+        Write-Log "Wallpaper file not found at: $wallpaperSrc" "Yellow"
+    }
+}
+
+Write-Log ""
+Write-Log "Starting OEM setup tasks..."
+Write-Log ""
+
+Set-OmarchyWallpaper
+Install-LookingGlass
+Install-SpiceGuestTools
+Set-InstallationMarker
+
+Write-Log ""
+Write-Log "=== OEM setup complete! ===" "Green"
+Write-Log "Log file saved to: C:\OEM\install-log.txt"
+
+Write-Log ""
+Write-Log "Copying log to shared folder..."
+try {
+    $sharedPath = if (Test-Path "Z:\") { "Z:\" } elseif (Test-Path "\\host.lan\Data") { "\\host.lan\Data\" } else { $null }
+
+    if ($sharedPath) {
+        Copy-Item -Path $LogFile -Destination "$sharedPath\install-log.txt" -Force -ErrorAction Stop
+        Write-Log "✓ Log copied to: $sharedPath\install-log.txt" "Green"
+        Write-Log "  (Available on host: ~/Windows/install-log.txt)" "Gray"
+    }
+    else {
+        Write-Log "WARNING: Shared folder not accessible, log not copied" "Yellow"
+    }
+}
+catch {
+    Write-Log "WARNING: Could not copy log to shared folder: $_" "Yellow"
+}
+EOFPS1
+
+  SCRIPT_VERSION_ESCAPED=$(printf '%s\n' "$SCRIPT_VERSION" | sed 's/[&/\]/\\&/g')
+  sed -i "s/SCRIPT_VERSION_PLACEHOLDER/$SCRIPT_VERSION_ESCAPED/" "$OEM_DIR/install.ps1"
+
+  convert_to_crlf "$OEM_DIR/install.ps1"
+}
+
+create_oem_batch_script() {
+  local OEM_DIR="$1"
+
+  cat >"$OEM_DIR/install.bat" <<'EOFBAT'
+@echo off
+setlocal EnableDelayedExpansion
+
+REM Create marker file to indicate script started
+echo OEM setup started at %DATE% %TIME% > C:\OEM\oem-started.txt
+
+REM ======================================
+REM Omarchy Windows VM OEM Setup
+REM Post-installation customization script
+REM ======================================
+
+REM Check for admin privileges
+net session >nul 2>&1
+if %errorLevel% neq 0 (
+    echo ERROR: This script requires administrator privileges!
+    echo Please run as administrator.
+    pause
+    exit /b 1
+)
+
+echo ======================================
+echo Omarchy Windows VM OEM Setup
+echo ======================================
+echo.
+echo Starting PowerShell setup script...
+echo Logs will be saved to C:\OEM\install-log.txt
+echo.
+
+REM Log basic information
+echo [BATCH] OEM setup started > C:\OEM\batch-log.txt
+echo [BATCH] Current directory: %CD% >> C:\OEM\batch-log.txt
+echo [BATCH] Script location: %~dp0 >> C:\OEM\batch-log.txt
+echo [BATCH] About to execute: powershell.exe -ExecutionPolicy Bypass -NoProfile -File "%~dp0install.ps1" >> C:\OEM\batch-log.txt
+echo.
+
+REM Execute PowerShell script and capture exit code
+powershell.exe -ExecutionPolicy Bypass -NoProfile -File "%~dp0install.ps1"
+set PS_EXIT_CODE=%errorLevel%
+
+echo.
+echo ======================================
+if %PS_EXIT_CODE% equ 0 (
+    echo Setup completed successfully!
+    echo Check C:\OEM\install-log.txt for details
+) else (
+    echo WARNING: Setup finished with errors ^(exit code: %PS_EXIT_CODE%^)
+    echo Check C:\OEM\install-log.txt for error details
+    echo.
+    echo Troubleshooting:
+    echo   - Check network connectivity for shared folder
+    echo   - Verify file permissions in C:\OEM\
+    echo   - Review install-log.txt for specific errors
+)
+echo ======================================
+
+REM Wait 5 seconds before closing (gives time to read output)
+timeout /t 5 /nobreak >nul
+
+exit /b %PS_EXIT_CODE%
+EOFBAT
+
+  convert_to_crlf "$OEM_DIR/install.bat"
+}
+
+detect_smbios_and_disk_info() {
+  # Detect SMBIOS info from host for VM anti-cheat spoofing
+  # Sets global variables: SMBIOS_FLAGS, DISK_FLAGS
+
+  SMBIOS_FLAGS=""
+  DISK_FLAGS=""
+
+  if ! command -v dmidecode &>/dev/null; then
+    msg_warning "dmidecode not found - SMBIOS spoofing disabled" >&2
+    echo "   Install dmidecode for better anti-cheat compatibility" >&2
+    return 0
+  fi
+
+  escape_for_qemu() {
+    local value="$1"
+    value="${value// /_}"  # QEMU -smbios doesn't support spaces
+    value="${value//,/,,}" # Escape commas (QEMU convention: double comma)
+    echo "$value"
+  }
+
+  # Helper to check for placeholder values (case-insensitive)
+  is_valid_smbios_value() {
+    local val="${1,,}"  # lowercase
+    [[ -n "$1" ]] && [[ "$val" != "unknown" ]] && [[ "$val" != "not specified" ]] && [[ "$val" != *"to be filled"* ]] && [[ "$val" != "default string" ]] && [[ "$val" != "default" ]] && [[ "$val" != "n/a" ]]
+  }
+
+  # SMBIOS Type 0: BIOS Information
+  local BIOS_VENDOR="$(sudo -n /usr/bin/dmidecode -s bios-vendor 2>/dev/null | head -1)"
+  local BIOS_VERSION="$(sudo -n /usr/bin/dmidecode -s bios-version 2>/dev/null | head -1)"
+  local BIOS_DATE="$(sudo -n /usr/bin/dmidecode -s bios-release-date 2>/dev/null | head -1)"
+
+  if is_valid_smbios_value "$BIOS_VENDOR" && is_valid_smbios_value "$BIOS_VERSION"; then
+    SMBIOS_FLAGS="${SMBIOS_FLAGS} -smbios type=0,vendor=$(escape_for_qemu "$BIOS_VENDOR"),version=$(escape_for_qemu "$BIOS_VERSION")"
+    [[ -n "$BIOS_DATE" ]] && SMBIOS_FLAGS="${SMBIOS_FLAGS},date=$(escape_for_qemu "$BIOS_DATE")"
+    SMBIOS_FLAGS="${SMBIOS_FLAGS},uefi=on"
+  fi
+
+  # SMBIOS Type 1: System Information
+  local SYS_MANUFACTURER="$(sudo -n /usr/bin/dmidecode -s system-manufacturer 2>/dev/null | head -1)"
+  local SYS_PRODUCT="$(sudo -n /usr/bin/dmidecode -s system-product-name 2>/dev/null | head -1)"
+  local SYS_VERSION="$(sudo -n /usr/bin/dmidecode -s system-version 2>/dev/null | head -1)"
+  local SYS_SERIAL="$(sudo -n /usr/bin/dmidecode -s system-serial-number 2>/dev/null | head -1)"
+  local SYS_UUID="$(sudo -n /usr/bin/dmidecode -s system-uuid 2>/dev/null | head -1)"
+
+  if is_valid_smbios_value "$SYS_MANUFACTURER" && is_valid_smbios_value "$SYS_PRODUCT"; then
+    SMBIOS_FLAGS="${SMBIOS_FLAGS} -smbios type=1,manufacturer=$(escape_for_qemu "$SYS_MANUFACTURER"),product=$(escape_for_qemu "$SYS_PRODUCT")"
+    is_valid_smbios_value "$SYS_VERSION" && SMBIOS_FLAGS="${SMBIOS_FLAGS},version=$(escape_for_qemu "$SYS_VERSION")"
+    is_valid_smbios_value "$SYS_SERIAL" && SMBIOS_FLAGS="${SMBIOS_FLAGS},serial=$(escape_for_qemu "$SYS_SERIAL")"
+    # UUID must be in format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (only add if valid)
+    if [[ "$SYS_UUID" =~ ^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$ ]]; then
+      SMBIOS_FLAGS="${SMBIOS_FLAGS},uuid=$SYS_UUID"
+    fi
+  fi
+
+  # SMBIOS Type 4: Processor Information (required by BenchMate for Max Core Frequency)
+  local CPU_MANUFACTURER="$(sudo -n /usr/bin/dmidecode -t processor 2>/dev/null | grep -m1 'Manufacturer:' | sed 's/.*Manufacturer: //')"
+  local CPU_VERSION="$(sudo -n /usr/bin/dmidecode -t processor 2>/dev/null | grep -m1 'Version:' | sed 's/.*Version: //')"
+  local CPU_CURRENT_SPEED="$(sudo -n /usr/bin/dmidecode -t processor 2>/dev/null | grep -m1 'Current Speed:' | grep -oP '\d+' | head -1)"
+  local CPU_MAX_SPEED="$(sudo -n /usr/bin/dmidecode -t processor 2>/dev/null | grep -m1 'Max Speed:' | grep -oP '\d+' | head -1)"
+
+  if [[ -n "$CPU_MANUFACTURER" ]] && [[ -n "$CPU_VERSION" ]]; then
+    SMBIOS_FLAGS="${SMBIOS_FLAGS} -smbios type=4,manufacturer=$(escape_for_qemu "$CPU_MANUFACTURER"),version=$(escape_for_qemu "$CPU_VERSION")"
+    [[ -n "$CPU_CURRENT_SPEED" ]] && SMBIOS_FLAGS="${SMBIOS_FLAGS},current-speed=${CPU_CURRENT_SPEED}"
+    [[ -n "$CPU_MAX_SPEED" ]] && SMBIOS_FLAGS="${SMBIOS_FLAGS},max-speed=${CPU_MAX_SPEED}"
+  fi
+
+  # SMBIOS Type 2: Baseboard Information
+  local BOARD_MANUFACTURER="$(sudo -n /usr/bin/dmidecode -s baseboard-manufacturer 2>/dev/null | head -1)"
+  local BOARD_PRODUCT="$(sudo -n /usr/bin/dmidecode -s baseboard-product-name 2>/dev/null | head -1)"
+  local BOARD_VERSION="$(sudo -n /usr/bin/dmidecode -s baseboard-version 2>/dev/null | head -1)"
+  local BOARD_SERIAL="$(sudo -n /usr/bin/dmidecode -s baseboard-serial-number 2>/dev/null | head -1)"
+
+  if is_valid_smbios_value "$BOARD_MANUFACTURER" && is_valid_smbios_value "$BOARD_PRODUCT"; then
+    SMBIOS_FLAGS="${SMBIOS_FLAGS} -smbios type=2,manufacturer=$(escape_for_qemu "$BOARD_MANUFACTURER"),product=$(escape_for_qemu "$BOARD_PRODUCT")"
+    is_valid_smbios_value "$BOARD_VERSION" && SMBIOS_FLAGS="${SMBIOS_FLAGS},version=$(escape_for_qemu "$BOARD_VERSION")"
+    is_valid_smbios_value "$BOARD_SERIAL" && SMBIOS_FLAGS="${SMBIOS_FLAGS},serial=$(escape_for_qemu "$BOARD_SERIAL")"
+  fi
+
+  # SMBIOS Type 3: Chassis Information
+  local CHASSIS_MANUFACTURER="$(sudo -n /usr/bin/dmidecode -s chassis-manufacturer 2>/dev/null | head -1)"
+  local CHASSIS_SERIAL="$(sudo -n /usr/bin/dmidecode -s chassis-serial-number 2>/dev/null | head -1)"
+
+  if is_valid_smbios_value "$CHASSIS_MANUFACTURER"; then
+    SMBIOS_FLAGS="${SMBIOS_FLAGS} -smbios type=3,manufacturer=$(escape_for_qemu "$CHASSIS_MANUFACTURER")"
+    is_valid_smbios_value "$CHASSIS_SERIAL" && SMBIOS_FLAGS="${SMBIOS_FLAGS},serial=$(escape_for_qemu "$CHASSIS_SERIAL")"
+  fi
+
+  # SMBIOS Type 17: Memory Device (find first populated DIMM)
+  local MEM_MANUFACTURER="$(sudo -n /usr/bin/dmidecode -t memory 2>/dev/null | grep 'Manufacturer:' | grep -v 'Not Specified' | head -1 | sed 's/.*Manufacturer: //' | xargs)"
+  local MEM_PART="$(sudo -n /usr/bin/dmidecode -t memory 2>/dev/null | grep 'Part Number:' | grep -v 'Not Specified' | head -1 | sed 's/.*Part Number: //' | xargs)"
+  local MEM_SPEED="$(sudo -n /usr/bin/dmidecode -t memory 2>/dev/null | grep 'Speed:' | grep -v 'Unknown' | head -1 | grep -oP '\d+' | head -1)"
+  local MEM_SERIAL="$(sudo -n /usr/bin/dmidecode -t memory 2>/dev/null | grep 'Serial Number:' | grep -v 'Not Specified' | head -1 | sed 's/.*Serial Number: //' | xargs)"
+
+  if is_valid_smbios_value "$MEM_MANUFACTURER"; then
+    SMBIOS_FLAGS="${SMBIOS_FLAGS} -smbios type=17,manufacturer=$(escape_for_qemu "$MEM_MANUFACTURER"),loc_pfx=DIMM_A1,bank=Bank_0"
+    is_valid_smbios_value "$MEM_SERIAL" && SMBIOS_FLAGS="${SMBIOS_FLAGS},serial=$(escape_for_qemu "$MEM_SERIAL")"
+    is_valid_smbios_value "$MEM_PART" && SMBIOS_FLAGS="${SMBIOS_FLAGS},part=$(escape_for_qemu "$MEM_PART")"
+    [[ -n "$MEM_SPEED" ]] && SMBIOS_FLAGS="${SMBIOS_FLAGS},speed=${MEM_SPEED}"
+  fi
+
+  # Disk spoofing - detect disk containing $HOME (where VM data lives)
+  local HOME_PARTITION DISK_DEVICE=""
+  HOME_PARTITION=$(df -P "$HOME" 2>/dev/null | tail -1 | awk '{print $1}')
+  if [[ -n "$HOME_PARTITION" ]] && [[ -b "$HOME_PARTITION" ]]; then
+    # Get parent device (strip partition): /dev/nvme1n1p2 → nvme1n1, /dev/sda2 → sda
+    DISK_DEVICE="/dev/$(lsblk -no PKNAME "$HOME_PARTITION" 2>/dev/null | head -1)"
+  fi
+
+  # Fallback chain: detected disk → nvme0n1 → sda
+  [[ ! -b "$DISK_DEVICE" ]] && DISK_DEVICE="/dev/nvme0n1"
+  [[ ! -b "$DISK_DEVICE" ]] && DISK_DEVICE="/dev/sda"
+
+  local DISK_VENDOR="$(lsblk -ndo VENDOR "$DISK_DEVICE" 2>/dev/null | xargs)"
+  local DISK_MODEL="$(lsblk -ndo MODEL "$DISK_DEVICE" 2>/dev/null | xargs)"
+  local DISK_SERIAL="$(lsblk -ndo SERIAL "$DISK_DEVICE" 2>/dev/null | xargs)"
+
+  if [[ -n "$DISK_MODEL" ]]; then
+    [[ -n "$DISK_VENDOR" ]] && DISK_FLAGS="${DISK_FLAGS} -global scsi-hd.vendor=$(escape_for_qemu "$DISK_VENDOR")"
+    DISK_FLAGS="${DISK_FLAGS} -global scsi-hd.product=$(escape_for_qemu "$DISK_MODEL")"
+    [[ -n "$DISK_SERIAL" ]] && DISK_FLAGS="${DISK_FLAGS} -global scsi-hd.serial=$(escape_for_qemu "$DISK_SERIAL")"
+    # Performance optimization: removed rotation_rate=1 (metadata only, no anti-cheat value)
+  fi
+}
+
+# Format CPU range: "X" for single, "X-Y" for range
+format_cpu_range() {
+  local start=$1 end=$2
+  if ((end == start)); then
+    echo "$start"
+  else
+    echo "${start}-${end}"
+  fi
+}
+
+# Detect SMP topology for proper hyperthreading/SMT support in guest
+detect_smp_topology() {
+  local selected_vcpus="${1:-}"
+  SMP_FLAGS=""
+  SMT_ENABLED=false
+  THREADS_PER_CORE=1
+  VM_PHYSICAL_CORES=0
+
+  [[ -z "$selected_vcpus" ]] || ! [[ "$selected_vcpus" =~ ^[0-9]+$ ]] && return 1
+
+  # Detect host threads per core
+  local host_threads_per_core
+  host_threads_per_core=$(lscpu 2>/dev/null | grep -E "^Thread\(s\) per core:" | awk '{print $NF}')
+  [[ -z "$host_threads_per_core" ]] && host_threads_per_core=1
+
+  if ((host_threads_per_core >= 2)); then
+    SMT_ENABLED=true
+    THREADS_PER_CORE=2
+  fi
+
+  # Calculate physical cores and threads for VM
+  # selected_vcpus = number of physical cores user wants
+  # With SMT: each core has 2 threads, so total vCPUs = cores × 2
+  if [[ "$SMT_ENABLED" == true ]]; then
+    VM_PHYSICAL_CORES=$selected_vcpus
+    local vm_threads=$((VM_PHYSICAL_CORES * 2))
+
+    # -smp total,sockets=1,cores=X,threads=2
+    # Example: 8 cores with SMT → -smp 16,sockets=1,cores=8,threads=2
+    SMP_FLAGS="-smp ${vm_threads},sockets=1,cores=${VM_PHYSICAL_CORES},threads=2"
+  else
+    # Without SMT: each vCPU is a physical core
+    VM_PHYSICAL_CORES=$selected_vcpus
+    SMP_FLAGS="-smp ${selected_vcpus},sockets=1,cores=${selected_vcpus},threads=1"
+  fi
+
+  return 0
+}
+
+# Detect CPU pinning for Intel Hybrid CPUs (P-core + E-core)
+# Limits VM to P-cores for better gaming performance (E-cores are slower)
+# Note: Host can still use all cores - cpuset only limits the container
+detect_cpu_pinning_set() {
+  local selected_cores="${1:-}"
+  CPU_PINNING_SET=""
+
+  local total_threads
+  total_threads=$(nproc --all 2>/dev/null) || return 1
+  ((total_threads < 6)) && return 1
+
+  local -a cpu_freqs=()
+  local -A freq_seen=()
+  local -a unique_freqs=()
+  local cpu freq
+
+  for ((cpu = 0; cpu < total_threads; cpu++)); do
+    local freq_file="/sys/devices/system/cpu/cpu${cpu}/cpufreq/cpuinfo_max_freq"
+    [[ -r "$freq_file" ]] || continue
+    freq=$(<"$freq_file") || continue
+    [[ "$freq" =~ ^[0-9]+$ ]] || continue
+    cpu_freqs[$cpu]=$freq
+    if [[ -z "${freq_seen[$freq]:-}" ]]; then
+      freq_seen[$freq]=1
+      unique_freqs+=("$freq")
+    fi
+  done
+
+  if [[ ${#cpu_freqs[@]} -eq 0 ]]; then
+    detect_cpu_pinning_set_simple "$selected_cores"
+    return $?
+  fi
+
+  # Hybrid CPU: multiple max frequencies - use P-cores (faster) for VM
+  if [[ ${#unique_freqs[@]} -gt 1 ]]; then
+    local lowest_freq
+    lowest_freq=$(printf '%s\n' "${unique_freqs[@]}" | sort -n | head -1)
+
+    local -a vm_cpus=()
+    for ((cpu = 0; cpu < total_threads; cpu++)); do
+      [[ -z "${cpu_freqs[$cpu]:-}" ]] && continue
+      [[ "${cpu_freqs[$cpu]}" != "$lowest_freq" ]] && vm_cpus+=("$cpu")
+    done
+
+    if [[ ${#vm_cpus[@]} -lt 4 ]]; then
+      detect_cpu_pinning_set_simple "$selected_cores"
+      return $?
+    fi
+
+    # selected_cores = number of physical cores user wants
+    # With SMT, need selected_cores * threads_per_core host threads
+    # Use global THREADS_PER_CORE set by detect_smp_topology()
+    if [[ -n "$selected_cores" ]] && [[ "$selected_cores" =~ ^[0-9]+$ ]]; then
+      local needed_threads=$((selected_cores * THREADS_PER_CORE))
+      if ((needed_threads < ${#vm_cpus[@]})); then
+        vm_cpus=("${vm_cpus[@]:0:$needed_threads}")
+      fi
+    fi
+
+    CPU_PINNING_SET=$(compact_cpu_list "${vm_cpus[@]}")
+  else
+    detect_cpu_pinning_set_simple "$selected_cores"
+    return $?
+  fi
+
+  return 0
+}
+
+# CPU pinning: reserves core 0 (IRQs) or core 0,1 for host to reduce micro-stutters
+# Dynamic: max vCPU=no reserve, max-2=1 core, ≤max-4=2 cores, fallback if can't fit
+detect_cpu_pinning_set_simple() {
+  local selected_cores="${1:-}"
+  local total_threads physical_cores
+
+  total_threads=$(nproc --all 2>/dev/null) || return 1
+  ((total_threads < 4)) && return 1
+
+  if [[ -z "$selected_cores" ]] || ! [[ "$selected_cores" =~ ^[0-9]+$ ]] || ((selected_cores >= total_threads)); then
+    CPU_PINNING_SET="0-$((total_threads - 1))"
+    return 0
+  fi
+
+  physical_cores=$((total_threads / THREADS_PER_CORE))
+
+  local vm_start phys_cores_needed
+  phys_cores_needed=$selected_cores
+
+  # Dynamic reservation: prefer 2 cores, fallback to 1, then 0
+  if ((selected_cores >= total_threads - 2)); then
+    vm_start=1
+  else
+    vm_start=2
+  fi
+
+  # Reduce if can't fit requested cores
+  while ((vm_start > 0)) && ((phys_cores_needed > physical_cores - vm_start)); do
+    ((vm_start--))
+  done
+
+  if ((vm_start == 0)); then
+    CPU_PINNING_SET="0-$((total_threads - 1))"
+    return 0
+  fi
+
+  if ((THREADS_PER_CORE == 1)); then
+    local vm_end=$((vm_start + selected_cores - 1))
+    ((vm_end >= physical_cores)) && vm_end=$((physical_cores - 1))
+    CPU_PINNING_SET=$(format_cpu_range "$vm_start" "$vm_end")
+  else
+    # SMT: use full physical cores for cache locality
+    local available_cores=$((physical_cores - vm_start))
+    local primary_end sibling_start sibling_end
+
+    if ((phys_cores_needed >= available_cores)); then
+      primary_end=$((physical_cores - 1))
+      sibling_start=$((physical_cores + vm_start))
+      sibling_end=$((total_threads - 1))
+    else
+      primary_end=$((vm_start + phys_cores_needed - 1))
+      sibling_start=$((physical_cores + vm_start))
+      sibling_end=$((sibling_start + phys_cores_needed - 1))
+    fi
+
+    CPU_PINNING_SET="$(format_cpu_range "$vm_start" "$primary_end"),$(format_cpu_range "$sibling_start" "$sibling_end")"
+  fi
+
+  return 0
+}
+
+# Convert "0 1 2 5 6 7" → "0-2,5-7"
+compact_cpu_list() {
+  local -a cpus=("$@")
+  [[ ${#cpus[@]} -eq 0 ]] && return
+
+  local -a sorted_cpus
+  mapfile -t sorted_cpus < <(printf '%s\n' "${cpus[@]}" | sort -n)
+
+  local result="" start="" prev=""
+  for current in "${sorted_cpus[@]}"; do
+    if [[ -z "$start" ]]; then
+      start=$current
+      prev=$current
+    elif ((current == prev + 1)); then
+      prev=$current
+    else
+      if [[ "$start" == "$prev" ]]; then
+        result+="${result:+,}$start"
+      else
+        result+="${result:+,}${start}-${prev}"
+      fi
+      start=$current
+      prev=$current
+    fi
+  done
+
+  # Close final range
+  if [[ -n "$start" ]]; then
+    if [[ "$start" == "$prev" ]]; then
+      result+="${result:+,}$start"
+    else
+      result+="${result:+,}${start}-${prev}"
+    fi
+  fi
+
+  echo "$result"
+}
+
+create_docker_compose_config() {
+  local COMPOSE_FILE="$1"
+  local SELECTED_RAM="$2"
+  local SELECTED_CORES="$3"
+  local SELECTED_DISK="$4"
+  local USERNAME="$5"
+  local PASSWORD="$6"
+  local LG_ENABLED="$7"
+  local IVSHMEM_SIZE="${8:-64}"
+  local GPU_PASSTHROUGH_ENABLED="${9:-false}"
+  local GPU_PCI_ADDR="${10:-}"
+  local GPU_IOMMU_GROUP="${11:-}"
+  local GPU_IOMMU_DEVICES="${12:-}"
+  local TPM_ENABLED="${13:-true}"
+
+  # Detect SMBIOS and disk info for anti-cheat spoofing
+  detect_smbios_and_disk_info
+
+  # Detect SMP topology
+  detect_smp_topology "$SELECTED_CORES"
+
+  # Detect CPU pinning based on selected cores
+  detect_cpu_pinning_set "$SELECTED_CORES"
+
+  local MACHINE_FLAGS="-machine kernel-irqchip=on"
+  local HV_VENDOR_ID="AuthenticAMD"
+  local CPU_EXTRA=""
+
+  if grep -qi 'GenuineIntel' /proc/cpuinfo 2>/dev/null; then
+    HV_VENDOR_ID="GenuineIntel"
+    CPU_EXTRA=",+hv-evmcs"
+    [[ "$LG_ENABLED" == true ]] && CPU_EXTRA="${CPU_EXTRA},host-phys-bits-limit=39"
+  else
+    if [[ "$SMT_ENABLED" == true ]]; then
+      CPU_EXTRA=",+topoext"
+    fi
+  fi
+
+  local CPU_FLAGS="-cpu host,-hypervisor,hv_vendor_id=${HV_VENDOR_ID},+pdpe1gb,+tsc-deadline${CPU_EXTRA}"
+
+  # Auto-detect host timezone
+  local HOST_TZ=""
+  if [[ -r /etc/timezone ]]; then
+    HOST_TZ=$(<"/etc/timezone")
+    HOST_TZ="${HOST_TZ//[[:space:]]/}"
+  elif command -v timedatectl &>/dev/null; then
+    HOST_TZ=$(timedatectl show -p Timezone --value 2>/dev/null)
+    HOST_TZ="${HOST_TZ//[[:space:]]/}"
+  fi
+  [[ -z "$HOST_TZ" ]] && HOST_TZ="UTC"
+
+  # Build ARGUMENTS section based on configuration
+  local ARGUMENTS_SECTION=""
+  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]] && [[ "$LG_ENABLED" == true ]]; then
+    # GPU Passthrough + Looking Glass + SPICE
+    # vfio-pci passthrough GPU is primary display (console 0)
+    # No QXL needed - Looking Glass uses passthrough GPU for display
+    ARGUMENTS_SECTION="
+      ARGUMENTS: >-"
+    [[ -n "$MACHINE_FLAGS" ]] && ARGUMENTS_SECTION+="
+        $MACHINE_FLAGS"
+    ARGUMENTS_SECTION+="
+        $CPU_FLAGS"
+    [[ -n "$SMP_FLAGS" ]] && ARGUMENTS_SECTION+="
+        $SMP_FLAGS"
+    [[ -n "$SMBIOS_FLAGS" ]] && ARGUMENTS_SECTION+="
+        ${SMBIOS_FLAGS# }"
+    [[ -n "$DISK_FLAGS" ]] && ARGUMENTS_SECTION+="
+        ${DISK_FLAGS# }"
+    ARGUMENTS_SECTION+="
+        -device ivshmem-plain,id=shmem0,memdev=looking-glass
+        -object memory-backend-file,id=looking-glass,mem-path=/dev/kvmfr0,size=${IVSHMEM_SIZE}M,share=yes"
+
+    # AMD GPU requires dedicated PCIe root-port for Windows drivers
+    # Check if GPU is multifunction device (has multiple functions like .0, .1)
+    local gpu_base_addr="${GPU_PCI_ADDR%.*}"  # e.g., 03:00.0 -> 03:00
+    local gpu_function_count=0
+    local gpu_devices_filtered=()
+
+    for dev_pci in $GPU_IOMMU_DEVICES; do
+      # Skip PCI bridges (class 0604) - they're host infrastructure
+      local dev_class=$(lspci -Dn -s "$dev_pci" 2>/dev/null | awk '{print $2}' | cut -d: -f1)
+      if [[ "$dev_class" == "0604" ]]; then
+        continue
+      fi
+      gpu_devices_filtered+=("$dev_pci")
+      # Count functions on same base address (multifunction detection)
+      if [[ "${dev_pci%.*}" == "$gpu_base_addr" ]]; then
+        ((gpu_function_count++))
+      fi
+    done
+
+    # Multifunction if more than one function on same base address
+    local is_multifunction=false
+    [[ "$gpu_function_count" -gt 1 ]] && is_multifunction=true
+
+    ARGUMENTS_SECTION+="
+        -device pcie-root-port,id=pcie_gpu,bus=pcie.0,addr=1c.0,slot=1,chassis=1,multifunction=on"
+
+    local gpu_device_idx=0
+
+    for dev_pci in "${gpu_devices_filtered[@]}"; do
+      # Get function number from PCI address (e.g., 03:00.0 -> 0, 03:00.1 -> 1)
+      local func_num="${dev_pci##*.}"
+
+      if [[ "$gpu_device_idx" -eq 0 ]]; then
+        # First device (GPU video)
+        if [[ "$is_multifunction" == true ]]; then
+          ARGUMENTS_SECTION+="
+        -device vfio-pci,host=0000:${dev_pci},bus=pcie_gpu,addr=00.${func_num},multifunction=on"
+        else
+          ARGUMENTS_SECTION+="
+        -device vfio-pci,host=0000:${dev_pci},bus=pcie_gpu,addr=00.${func_num}"
+        fi
+      else
+        # Subsequent devices (audio etc.) - same bus, addr=00.X
+        ARGUMENTS_SECTION+="
+        -device vfio-pci,host=0000:${dev_pci},bus=pcie_gpu,addr=00.${func_num}"
+      fi
+      ((gpu_device_idx++))
+    done
+    ARGUMENTS_SECTION+="
+        -audiodev spice,id=spice
+        -device intel-hda
+        -device hda-duplex,audiodev=spice
+        -spice unix=on,addr=/tmp/spice/spice.sock,disable-ticketing=on,agent-mouse=off
+        -device virtio-serial-pci
+        -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0
+        -chardev spicevmc,id=spicechannel0,name=vdagent
+        -device virtio-mouse-pci
+        -device virtio-keyboard-pci
+        -global ICH9-LPC.disable_s3=1
+        -global ICH9-LPC.disable_s4=1
+
+      USB: \"no\""
+  elif [[ "$LG_ENABLED" == true ]]; then
+    # Looking Glass only (no GPU passthrough)
+    local LG_ARGS="$MACHINE_FLAGS $CPU_FLAGS $SMP_FLAGS $SMBIOS_FLAGS $DISK_FLAGS -device ivshmem-plain,id=shmem0,memdev=looking-glass -object memory-backend-file,id=looking-glass,mem-path=/dev/kvmfr0,size=${IVSHMEM_SIZE}M,share=yes"
+    LG_ARGS="${LG_ARGS# }" # Trim leading space
+    ARGUMENTS_SECTION="
+      ARGUMENTS: \"$LG_ARGS\""
+  else
+    # No GPU passthrough, no Looking Glass - CPU-only VM with anti-cheat flags
+    if [[ -n "$MACHINE_FLAGS" ]] || [[ "$CPU_FLAGS" != "-cpu host" ]] || [[ -n "$SMBIOS_FLAGS" ]] || [[ -n "$DISK_FLAGS" ]] || [[ -n "$SMP_FLAGS" ]]; then
+      local CPU_ARGS="$MACHINE_FLAGS $CPU_FLAGS $SMP_FLAGS $SMBIOS_FLAGS $DISK_FLAGS"
+      CPU_ARGS="${CPU_ARGS# }" # Trim leading space
+      ARGUMENTS_SECTION="
+      ARGUMENTS: \"$CPU_ARGS\""
+    fi
+  fi
+
+  # Build devices section
+  local DEVICES_KVMFR=""
+  if [[ "$LG_ENABLED" == true ]]; then
+    DEVICES_KVMFR="
+      - /dev/kvmfr0:/dev/kvmfr0"
+  fi
+
+  local DEVICES_VFIO=""
+  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]]; then
+    DEVICES_VFIO=""
+    for group in $(echo "$GPU_IOMMU_GROUP" | tr ',' ' '); do
+      DEVICES_VFIO+="
+      - /dev/vfio/${group}:/dev/vfio/${group}"
+    done
+    DEVICES_VFIO+="
+      - /dev/vfio/vfio:/dev/vfio/vfio"
+  fi
+
+  # Build ulimits section (needed for VFIO memory locking)
+  local ULIMITS_SECTION=""
+  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]]; then
+    ULIMITS_SECTION="
+
+    ulimits:
+      memlock:
+        soft: -1
+        hard: -1"
+  fi
+
+  # Build volumes section
+  local VOLUMES_SPICE=""
+  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]] && [[ "$LG_ENABLED" == true ]]; then
+    VOLUMES_SPICE="
+      - $SPICE_DIR:/tmp/spice"
+  fi
+
+  # Build TPM/Secure Boot section
+  local TPM_SECTION=""
+  if [[ "$TPM_ENABLED" == true ]]; then
+    TPM_SECTION="
+      TPM: \"Y\"
+      BOOT_MODE: \"windows_secure\""
+  fi
+
+  local CPUSET_SECTION=""
+  if [[ -n "$CPU_PINNING_SET" ]]; then
+    CPUSET_SECTION="
+    cpuset: \"$CPU_PINNING_SET\""
+  fi
+
+  # Create docker-compose.yml with clean variable substitution
+  # If COMPOSE_FILE is "-" or "/dev/stdout", print to stdout instead of file
+  if [[ "$COMPOSE_FILE" == "-" ]] || [[ "$COMPOSE_FILE" == "/dev/stdout" ]]; then
+    cat <<EOF
+services:
+  windows:
+    image: $DOCKER_IMAGE
+    pull_policy: if_not_present
+    container_name: omarchy-windows
+    environment:
+      VERSION: "11"
+      RAM_SIZE: "$SELECTED_RAM"
+      CPU_CORES: "$SELECTED_CORES"
+      DISK_SIZE: "$SELECTED_DISK"
+      USERNAME: "$USERNAME"
+      PASSWORD: "$PASSWORD"
+      TZ: "$HOST_TZ"$TPM_SECTION$ARGUMENTS_SECTION
+    devices:
+      - /dev/kvm
+      - /dev/net/tun$DEVICES_KVMFR$DEVICES_VFIO
+    cap_add:
+      - NET_ADMIN$ULIMITS_SECTION$CPUSET_SECTION
+    ports:
+      - 8006:8006
+      - 3389:3389/tcp
+      - 3389:3389/udp
+    volumes:
+      - \${HOME}/.windows:/storage
+      - \${HOME}/Windows:/shared
+      - \${HOME}/.config/windows/oem:/oem$VOLUMES_SPICE
+    restart: "no"
+    stop_grace_period: 2m
+EOF
+  else
+    cat >"$COMPOSE_FILE" <<EOF
+services:
+  windows:
+    image: $DOCKER_IMAGE
+    pull_policy: if_not_present
+    container_name: omarchy-windows
+    environment:
+      VERSION: "11"
+      RAM_SIZE: "$SELECTED_RAM"
+      CPU_CORES: "$SELECTED_CORES"
+      DISK_SIZE: "$SELECTED_DISK"
+      USERNAME: "$USERNAME"
+      PASSWORD: "$PASSWORD"
+      TZ: "$HOST_TZ"$TPM_SECTION$ARGUMENTS_SECTION
+    devices:
+      - /dev/kvm
+      - /dev/net/tun$DEVICES_KVMFR$DEVICES_VFIO
+    cap_add:
+      - NET_ADMIN$ULIMITS_SECTION$CPUSET_SECTION
+    ports:
+      - 8006:8006
+      - 3389:3389/tcp
+      - 3389:3389/udp
+    volumes:
+      - \${HOME}/.windows:/storage
+      - \${HOME}/Windows:/shared
+      - \${HOME}/.config/windows/oem:/oem$VOLUMES_SPICE
+    restart: "no"
+    stop_grace_period: 2m
+EOF
+    chmod 600 "$COMPOSE_FILE"
+  fi
+}
+
+show_installation_header() {
+  local IS_FRESH_INSTALL="$1"
+
+  if [[ "$IS_FRESH_INSTALL" == "true" ]]; then
+    echo "Waiting for Windows installation to complete..."
+  else
+    echo "Waiting for Windows boot..."
+  fi
+  echo ""
+}
+
+draw_progress_bar() {
+  local PERCENT="$1"
+  local BAR_WIDTH=20
+
+  # Validate and clamp PERCENT to 0-100 range
+  [[ ! "$PERCENT" =~ ^[0-9]+$ ]] && PERCENT=0
+  [[ "$PERCENT" -gt 100 ]] && PERCENT=100
+
+  # Calculate filled and empty parts
+  local FILLED=$((PERCENT * BAR_WIDTH / 100))
+  local EMPTY=$((BAR_WIDTH - FILLED))
+
+  # Build progress bar
+  local BAR="["
+  for ((i = 0; i < FILLED; i++)); do
+    BAR+="█"
+  done
+  for ((i = 0; i < EMPTY; i++)); do
+    BAR+="░"
+  done
+  BAR+="]"
+
+  echo "$BAR"
+}
+
+show_disk_usage() {
+  local VM_DISK="$1"
+  local TIME_PREFIX="$2"
+
+  local DISK_SIZE_MB=0
+  if [[ -f "$VM_DISK" ]]; then
+    DISK_SIZE_MB=$(du -m "$VM_DISK" | cut -f1 2>/dev/null || echo "0")
+    [[ "$DISK_SIZE_MB" =~ ^[0-9]+$ ]] || DISK_SIZE_MB=0
+  fi
+
+  # Get max disk size from docker-compose config
+  local MAX_DISK_GB=256
+  if [[ -f "$COMPOSE_FILE" ]]; then
+    MAX_DISK_GB=$(grep -E '^\s*DISK_SIZE:' "$COMPOSE_FILE" | grep -oP '\d+' | head -1)
+    [[ "$MAX_DISK_GB" =~ ^[0-9]+$ ]] || MAX_DISK_GB=256
+  fi
+
+  # Calculate percentage used
+  local MAX_DISK_MB=$((MAX_DISK_GB * 1024))
+  local PERCENT_USED=0
+  if [[ "$MAX_DISK_MB" -gt 0 ]] && [[ "$DISK_SIZE_MB" -gt 0 ]]; then
+    PERCENT_USED=$((DISK_SIZE_MB * 100 / MAX_DISK_MB))
+  fi
+
+  # Format with comma separator for MB (using sed, works everywhere)
+  local FORMATTED_MB=$(echo "$DISK_SIZE_MB" | sed ':a;s/\B[0-9]\{3\}\>/,&/;ta')
+
+  printf "%s Storage: %s MB / %d GB (%d%% used)\n" "$TIME_PREFIX" "$FORMATTED_MB" "$MAX_DISK_GB" "$PERCENT_USED"
+}
+
+handle_installation_marker() {
+  local COMPLETION_MARKER="$1"
+  local TIME_PREFIX="$2"
+
+  # Remove UTF-8 BOM if present
+  local MARKER_CONTENT=$(cat "$COMPLETION_MARKER" 2>/dev/null | LC_ALL=C sed 's/^\xEF\xBB\xBF//' || echo "marker detected")
+
+  printf "%s Installation complete! Windows reports: %s\n" "$TIME_PREFIX" "$MARKER_CONTENT"
+  printf "%s Waiting for RDP service...\n" "$TIME_PREFIX"
+  sleep 10
+
+  if command -v nc &>/dev/null && nc -z 127.0.0.1 3389 2>/dev/null; then
+    printf "%s RDP port accessible\n" "$TIME_PREFIX"
+  fi
+}
+
+show_installation_summary() {
+  local ELAPSED="$1"
+  local USERNAME="$2"
+  local PASSWORD="$3"
+  local LG_ENABLED="${4:-false}"
+  local DOWNLOAD_START="$5"
+  local EXTRACT_START="$6"
+  local OEM_START="$7"
+  local BUILD_START="$8"
+  local DISK_START="$9"
+  local BOOT_START="${10}"
+  local WINDOWS_START="${11}"
+  local CURRENT="${12}"
+  local IS_FRESH_INSTALL="${13:-false}"
+
+  local MINUTES=$((ELAPSED / 60))
+  local SECONDS=$((ELAPSED % 60))
+
+  echo ""
+  echo "Installation Complete!"
+  printf "  Total time: %dm %ds\n" "$MINUTES" "$SECONDS"
+  echo ""
+
+  # Calculate individual stage durations (show only non-zero)
+  echo "  Stage Timing:"
+  if [[ "$DOWNLOAD_START" -gt 0 ]] && [[ "$EXTRACT_START" -gt 0 ]]; then
+    local DUR=$((EXTRACT_START - DOWNLOAD_START))
+    if [[ "$DUR" -gt 0 ]]; then
+      printf "    Download:        %dm %ds\n" "$((DUR / 60))" "$((DUR % 60))"
+    fi
+  fi
+  if [[ "$EXTRACT_START" -gt 0 ]] && [[ "$OEM_START" -gt 0 ]]; then
+    local DUR=$((OEM_START - EXTRACT_START))
+    if [[ "$DUR" -gt 0 ]]; then
+      printf "    Extract:         %dm %ds\n" "$((DUR / 60))" "$((DUR % 60))"
+    fi
+  fi
+  if [[ "$BUILD_START" -gt 0 ]] && [[ "$DISK_START" -gt 0 ]]; then
+    local DUR=$((DISK_START - BUILD_START))
+    if [[ "$DUR" -gt 0 ]]; then
+      printf "    Build:           %dm %ds\n" "$((DUR / 60))" "$((DUR % 60))"
+    fi
+  fi
+  if [[ "$BOOT_START" -gt 0 ]] && [[ "$WINDOWS_START" -gt 0 ]]; then
+    local DUR=$((WINDOWS_START - BOOT_START))
+    if [[ "$DUR" -gt 0 ]]; then
+      printf "    First boot:      %dm %ds\n" "$((DUR / 60))" "$((DUR % 60))"
+    fi
+  fi
+  if [[ "$WINDOWS_START" -gt 0 ]] && [[ "$CURRENT" -gt 0 ]]; then
+    local DUR=$((CURRENT - WINDOWS_START))
+    printf "    Windows setup:   %dm %ds\n" "$((DUR / 60))" "$((DUR % 60))"
+  fi
+  echo ""
+
+  # Show installed components
+  echo "  Installed Components:"
+  echo "    [OK] Windows 11 Pro"
+  if [[ "$LG_ENABLED" == true ]]; then
+    echo "    [OK] Looking Glass host service"
+  fi
+  echo "    [OK] SPICE Guest Tools"
+  echo ""
+
+  # Desktop notification
+  notify_silent "Windows VM" "Installation complete! (${MINUTES}m ${SECONDS}s)" "normal"
+
+  if [[ "$LG_ENABLED" == true ]]; then
+    echo ""
+    echo "Looking Glass Setup"
+    echo "  1. Ensure display is connected to GPU (monitor, 2nd cable, or dummy plug)"
+    echo "     Note: dummy plugs limit Windows refresh rate"
+    echo ""
+    echo "  2. Wait for Windows to install GPU drivers (few minutes)"
+    echo "     → Close noVNC browser tab (no longer needed)"
+    echo ""
+    echo "  3. Device Manager → Disable 'Red Hat VirtIO GPU DOD controller'"
+    echo "     WARNING: Screen will FREEZE after this - this is normal!"
+    echo ""
+    echo "  4. Immediately restart the VM:"
+    echo "     → omarchy-windows-vm stop"
+    echo "     → omarchy-windows-vm launch --lg --keep-alive --windowed"
+    echo ""
+    echo "  5. After restart, wait for Windows to configure the GPU display"
+    echo "     → Looking Glass will show native GPU output"
+    echo ""
+    echo "  6. Optional: Set resolution and refresh rate in Windows Display Settings"
+    echo ""
+    echo "  7. Install GPU drivers (NVIDIA/AMD) for best performance"
+    echo "     Screen may FREEZE during install - restart VM as in step 4"
+    echo "     Tip: RDP works even when LG freezes (omarchy-windows-vm launch)"
+    echo ""
+    echo "Done! You now have full GPU performance in Looking Glass."
+    echo "     Now you can update Windows, install games and apps."
+    echo ""
+    echo "If Looking Glass doesn't start automatically:"
+    echo "  → omarchy-windows-vm launch --lg --keep-alive"
+    echo "  → or use app menu: 'Windows [Looking Glass]'"
+    echo ""
+  fi
+}
+
+connect_looking_glass() {
+  local KEEP_ALIVE="${1:-true}"
+  local WINDOWED="${2:-false}"
+
+  # Note: sudo -v removed - no longer needed with sudoers rules configured
+  # Socket permissions are fixed automatically via passwordless sudo rules
+
+  # Auto-fix Looking Glass config if using old SPICE socket path
+  LG_CONFIG="$HOME/.config/looking-glass/client.ini"
+  if [[ -f "$LG_CONFIG" ]]; then
+    if grep -q "host=/tmp/spice/spice.sock" "$LG_CONFIG" 2>/dev/null; then
+      echo "  Updating Looking Glass config to new SPICE socket path..."
+      sed -i 's|host=/tmp/spice/spice.sock|host=/var/run/omarchy-windows/spice.sock|g' "$LG_CONFIG"
+      msg_success "Config updated"
+    fi
+  fi
+
+  # Validate Looking Glass requirements: client, module, device, permissions
+  if ! command -v looking-glass-client &>/dev/null; then
+    msg_error "Looking Glass is not installed!"
+    echo ""
+    echo "Install it with: omarchy-looking-glass-install"
+    echo "Or search for 'Install Looking Glass' in the application menu"
+    exit 1
+  fi
+
+  if ! lsmod | grep -q kvmfr; then
+    msg_warning "kvmfr module not loaded, attempting to load..."
+    if sudo -n /usr/bin/modprobe kvmfr 2>/dev/null; then
+      msg_success "Module loaded successfully"
+      sleep 1 # Give udev time to create device
+    else
+      msg_error "Failed to load kvmfr module"
+      echo "   Install: omarchy-looking-glass-install"
+      echo "   Then reboot"
+      exit 1
+    fi
+  fi
+
+  if [[ ! -e /dev/kvmfr0 ]]; then
+    msg_error "/dev/kvmfr0 not found (module loaded but device missing)"
+    echo "   Reinstall: omarchy-looking-glass-install"
+    echo "   Then reboot"
+    exit 1
+  fi
+
+  # Check /dev/kvmfr0 permissions and auto-fix if needed
+  USE_SG_KVM=false
+  if [[ ! -r /dev/kvmfr0 ]]; then
+    # Try to fix permissions silently
+    ensure_user_in_kvm_group
+    local kvm_status=$?
+    case "$kvm_status" in
+    1)
+      # User was just added to kvm group - use temporary access (silent)
+      USE_SG_KVM=true
+      ;;
+    0)
+      # User already in kvm group but session not refreshed - use temporary access (silent)
+      USE_SG_KVM=true
+      ;;
+    2)
+      echo ""
+      msg_error "Cannot access /dev/kvmfr0"
+      echo "   Failed to add user to kvm group."
+      echo ""
+      echo "   Manual fix:"
+      echo "   1. sudo usermod -aG kvm \"$USER\""
+      echo "   2. Logout and login again (or reboot)"
+      echo "   3. Verify: ls -la /dev/kvmfr0"
+      echo ""
+      exit 1
+      ;;
+    *)
+      msg_error "Cannot access /dev/kvmfr0 (code: $kvm_status)"
+      echo "  Fix: sudo usermod -aG kvm \"$USER\" && reboot"
+      echo "  Help: https://github.com/basecamp/omarchy/discussions/3455"
+      exit 1
+      ;;
+    esac
+  fi
+
+  local escape_key=$(get_escape_key_display)
+
+  # Wait for QEMU SPICE listener to be ready
+  MAX_WAIT=30
+  ELAPSED=0
+  SPICE_READY=false
+
+  while [[ "$ELAPSED" -lt "$MAX_WAIT" ]]; do
+    # Check socket and fix permissions if needed
+    if sudo -n test -S "$SPICE_SOCKET_PATH" 2>/dev/null; then
+      sudo -n chmod 660 "$SPICE_SOCKET_PATH" 2>/dev/null || true
+      sudo -n chgrp kvm "$SPICE_SOCKET_PATH" 2>/dev/null || true
+    fi
+
+    if timeout 1 env SOCKET_PATH="$SPICE_SOCKET_PATH" python3 -c "import socket, os; s=socket.socket(socket.AF_UNIX); s.connect(os.environ['SOCKET_PATH'])" 2>/dev/null; then
+      SPICE_READY=true
+      break
+    fi
+    sleep 2
+    ELAPSED=$((ELAPSED + 2))
+  done
+
+  if [[ "$SPICE_READY" != true ]]; then
+    msg_error "SPICE listener not ready after ${MAX_WAIT}s"
+    echo "   Try RDP instead: omarchy-windows-vm launch"
+    exit 1
+  fi
+
+  echo ""
+  echo "Connecting to Windows VM via Looking Glass..."
+  echo ""
+  echo "  $escape_key         - Release mouse/keyboard (hold for info menu)"
+  echo "  $escape_key + F     - Toggle fullscreen (or SUPER + F)"
+  echo "  $escape_key + Q     - Quit Looking Glass"
+  echo ""
+  echo "Press Ctrl+C to return to shell (Looking Glass will keep running)"
+  echo ""
+  sleep 3
+
+  # Launch Looking Glass client in background (hide logs, immune to Ctrl+C)
+  local lg_args=""
+
+  if [[ "$USE_SG_KVM" == true ]]; then
+    # User needs temporary kvm group access - run through sg kvm
+    sg kvm -c "setsid uwsm-app -- looking-glass-client $lg_args >/dev/null 2>&1" &
+    LG_PID=$!
+  else
+    # Normal launch (user has direct access to /dev/kvmfr0)
+    setsid uwsm-app -- looking-glass-client $lg_args >/dev/null 2>&1 &
+    LG_PID=$!
+  fi
+
+  # Wait for Looking Glass to close (blocks here)
+  wait $LG_PID
+  LG_EXIT=$?
+
+  # After Looking Glass closes
+  if [[ "$LG_EXIT" -eq 0 ]] || [[ "$LG_EXIT" -eq 255 ]] || [[ "$LG_EXIT" -eq 130 ]]; then
+    if [[ "$KEEP_ALIVE" == false ]]; then
+      echo ""
+      echo "Looking Glass session closed. Stopping Windows VM..."
+      docker-compose -f "$COMPOSE_FILE" stop
+      echo "VM stopped. Restart: omarchy-windows-vm launch --lg"
+    else
+      echo ""
+      echo "Looking Glass session closed. VM still running."
+      echo "To stop: omarchy-windows-vm stop"
+    fi
+  else
+    echo ""
+    msg_error "Looking Glass error (code: $LG_EXIT)"
+    echo "   Try RDP instead: omarchy-windows-vm launch"
+    exit 1
+  fi
+}
+
+launch_after_install() {
+  local USERNAME="$1"
+  local PASSWORD="$2"
+  local USE_LG="${3:-false}"
+
+  if [[ "$USE_LG" == true ]]; then
+    if ! command -v looking-glass-client &>/dev/null; then
+      msg_warning "Looking Glass not installed - run: omarchy-looking-glass-install"
+      return
+    fi
+    if [[ ! -e /dev/kvmfr0 ]]; then
+      msg_warning "KVMFR not ready - reboot required after Looking Glass installation"
+      return
+    fi
+
+    # Wait 30s for Windows post-install configuration, then launch Looking Glass
+    echo ""
+    printf "Waiting for Windows to finish configuration"
+    local spice_wait=0
+    local spice_ready=false
+    while [[ "$spice_wait" -lt 10 ]]; do
+      sleep 3
+      spice_wait=$((spice_wait + 1))
+      printf "."
+
+      # Fix permissions if socket exists
+      if sudo -n test -S "$SPICE_SOCKET_PATH" 2>/dev/null; then
+        sudo -n chmod 660 "$SPICE_SOCKET_PATH" 2>/dev/null || true
+        sudo -n chgrp kvm "$SPICE_SOCKET_PATH" 2>/dev/null || true
+      fi
+    done
+    echo ""
+
+    # Verify socket accepts connections
+    if timeout 1 env SOCKET_PATH="$SPICE_SOCKET_PATH" python3 -c "import socket, os; s=socket.socket(socket.AF_UNIX); s.connect(os.environ['SOCKET_PATH'])" 2>/dev/null; then
+      spice_ready=true
+    fi
+
+    if [[ "$spice_ready" != true ]]; then
+      msg_warning "SPICE not ready - try later: omarchy-windows-vm launch --lg"
+      return
+    fi
+
+    local escape_key=$(get_escape_key_display)
+    echo ""
+    echo "Connecting to Windows VM via Looking Glass..."
+    echo ""
+    echo "  $escape_key         - Release mouse/keyboard (hold for info menu)"
+    echo "  $escape_key + F     - Toggle fullscreen (or SUPER + F)"
+    echo "  $escape_key + Q     - Quit Looking Glass"
+    echo ""
+
+    # Launch Looking Glass in background (windowed mode)
+    local use_sg_kvm=false
+    if [[ ! -r /dev/kvmfr0 ]]; then
+      ensure_user_in_kvm_group
+      local kvm_status=$?
+      [[ "$kvm_status" -le 1 ]] && use_sg_kvm=true
+    fi
+
+    local lg_args="-F win:fullScreen=no"
+    if [[ "$use_sg_kvm" == true ]]; then
+      sg kvm -c "setsid uwsm-app -- looking-glass-client $lg_args >/dev/null 2>&1" &
+    else
+      setsid uwsm-app -- looking-glass-client $lg_args >/dev/null 2>&1 &
+    fi
+
+    sleep 3
+    if pgrep -x looking-glass-c >/dev/null 2>&1; then
+      msg_success "Looking Glass started (windowed mode)"
+    else
+      msg_warning "Looking Glass may not have started - try: omarchy-windows-vm launch --lg"
+    fi
+  else
+    # RDP: wait briefly then connect
+    echo ""
+    printf "Connecting via RDP"
+    for _ in {1..3}; do sleep 1; printf "."; done
+    echo ""
+    connect_rdp "$USERNAME" "$PASSWORD" true
+  fi
+}
+
+monitor_installation_progress() {
+  local USERNAME="$1"
+  local PASSWORD="$2"
+  local IS_FRESH_INSTALL="${3:-true}"
+  local LG_ENABLED="${4:-false}"
+  local VM_DISK="$HOME/.windows/data.img"
+  local COMPLETION_MARKER="$HOME/Windows/installation-complete.txt"
+  local INSTALL_LOG="$HOME/Windows/install-log.txt"
+  local START_TIME=$(date +%s)
+  local LAST_DISPLAY_TIME=0
+  local LAST_LOG_CHECK=0
+  local DISPLAY_INTERVAL=60
+  local LOG_CHECK_INTERVAL=5
+  local MARKER_CHECK_INTERVAL=5
+  local TIMEOUT=3600
+  local MARKER_DETECTED=false
+  local BOOT_COUNT=0
+  local SEEN_STAGES=""
+  local LAST_PROGRESS=-1
+  local DOWNLOADING=false
+
+  # Stage timing tracking
+  local DOWNLOAD_START_TIME=0
+  local EXTRACT_START_TIME=0
+  local OEM_START_TIME=0
+  local BUILD_START_TIME=0
+  local DISK_START_TIME=0
+  local BOOT_START_TIME=0
+  local WINDOWS_START_TIME=0
+
+  rm -f "$COMPLETION_MARKER" "$INSTALL_LOG" 2>/dev/null
+
+  show_installation_header "$IS_FRESH_INSTALL"
+
+  while true; do
+    # Calculate elapsed time and format timestamp
+    local CURRENT_TIME=$(date +%s)
+    local ELAPSED=$((CURRENT_TIME - START_TIME))
+    local ELAPSED_MIN=$((ELAPSED / 60))
+    local ELAPSED_SEC=$((ELAPSED % 60))
+    local TIME_PREFIX=$(printf "[%s | +%dm %02ds]" "$(date +%H:%M:%S)" "$ELAPSED_MIN" "$ELAPSED_SEC")
+
+    # Parse Docker logs for installation stages (only during fresh install)
+    if [[ "$IS_FRESH_INSTALL" == "true" ]] && [[ "$((CURRENT_TIME - LAST_LOG_CHECK))" -ge "$LOG_CHECK_INTERVAL" ]]; then
+      LAST_LOG_CHECK=$CURRENT_TIME
+
+      # Check if container exists and is running
+      if ! docker inspect omarchy-windows &>/dev/null; then
+        # Container doesn't exist yet, skip log parsing this iteration
+        sleep "$MARKER_CHECK_INTERVAL"
+        continue
+      fi
+
+      # Check if container crashed during installation
+      local CONTAINER_STATUS=$(docker ps -a --filter "name=omarchy-windows" --format "{{.Status}}" 2>/dev/null)
+      if [[ "$CONTAINER_STATUS" =~ ^Exited ]]; then
+        msg_error "VM crashed during installation"
+        echo "  Check logs: docker logs omarchy-windows"
+        return 1
+      fi
+
+      # Get last 500 lines from Docker logs (covers full download cycle + previous stages)
+      local DOCKER_LOGS=$(docker logs --tail 500 omarchy-windows 2>&1)
+
+      # Check for key stages (only show each once)
+      if [[ ! "$SEEN_STAGES" =~ "downloading" ]] && echo "$DOCKER_LOGS" | grep -q "Downloading Windows 11"; then
+        printf "%s Downloading Windows 11 image...\n" "$TIME_PREFIX"
+        SEEN_STAGES="${SEEN_STAGES}downloading "
+        DOWNLOADING=true
+        DOWNLOAD_START_TIME=$CURRENT_TIME
+      fi
+
+      # Show download progress while downloading
+      if [[ "$DOWNLOADING" == true ]] && [[ ! "$SEEN_STAGES" =~ "download_complete" ]]; then
+        # Extract latest progress % from download lines (format: "65536K .... 1% 97.5M 1m43s")
+        local PROGRESS=$(echo "$DOCKER_LOGS" | grep -oP '\s+\K\d+(?=%)' | tail -1)
+        if [[ -n "$PROGRESS" ]] && [[ "$PROGRESS" != "$LAST_PROGRESS" ]]; then
+          # Extract download speed (e.g., "97.5M" from "1% 97.5M 1m43s")
+          local SPEED=$(echo "$DOCKER_LOGS" | grep -oP '\d+%\s+\K[\d.]+[KMG](?=\s)' | tail -1)
+          [[ -z "$SPEED" ]] && SPEED="--"
+
+          # Extract ETA (e.g., "1m43s", "43s", "2m", "1h20m")
+          local ETA=$(echo "$DOCKER_LOGS" | grep -oP '\d+%\s+[\d.]+[KMG]\s+\K[\dhms]+' | tail -1)
+          local ETA_DISPLAY=""
+          if [[ -n "$ETA" ]]; then
+            ETA_DISPLAY=" ~$ETA remaining"
+          fi
+
+          # Draw progress bar
+          local PROGRESS_BAR=$(draw_progress_bar "$PROGRESS")
+
+          # Use \r to update same line (carriage return without newline)
+          # Clear line with spaces to prevent artifacts from previous longer output
+          printf "\r%-100s\r" ""
+          printf "%s Downloading: %s %d%% (%s/s)%s" "$TIME_PREFIX" "$PROGRESS_BAR" "$PROGRESS" "$SPEED" "$ETA_DISPLAY"
+          LAST_PROGRESS=$PROGRESS
+        fi
+      fi
+
+      if [[ ! "$SEEN_STAGES" =~ "download_complete" ]] && echo "$DOCKER_LOGS" | grep -q "100%.*=.*s$"; then
+        # Print newline to finish progress line, then completion message
+        [[ "$DOWNLOADING" == true ]] && echo ""
+        printf "%s Download complete [OK]\n" "$TIME_PREFIX"
+        SEEN_STAGES="${SEEN_STAGES}download_complete "
+        DOWNLOADING=false
+      fi
+
+      if [[ ! "$SEEN_STAGES" =~ "extracting" ]] && echo "$DOCKER_LOGS" | grep -q "Extracting Windows"; then
+        printf "%s Extracting Windows image...\n" "$TIME_PREFIX"
+        SEEN_STAGES="${SEEN_STAGES}extracting "
+        EXTRACT_START_TIME=$CURRENT_TIME
+      fi
+
+      if [[ ! "$SEEN_STAGES" =~ "oem" ]] && echo "$DOCKER_LOGS" | grep -q "Adding OEM folder"; then
+        if [[ "$EXTRACT_START_TIME" -gt 0 ]]; then
+          printf "%s Extracting complete [OK]\n" "$TIME_PREFIX"
+        fi
+        printf "%s Adding OEM setup (Looking Glass + SPICE Guest Tools)...\n" "$TIME_PREFIX"
+        SEEN_STAGES="${SEEN_STAGES}oem "
+        OEM_START_TIME=$CURRENT_TIME
+      fi
+
+      if [[ ! "$SEEN_STAGES" =~ "building" ]] && echo "$DOCKER_LOGS" | grep -q "Building Windows.*image"; then
+        if [[ "$OEM_START_TIME" -gt 0 ]]; then
+          printf "%s OEM setup complete [OK]\n" "$TIME_PREFIX"
+        fi
+        printf "%s Building Windows image...\n" "$TIME_PREFIX"
+        SEEN_STAGES="${SEEN_STAGES}building "
+        BUILD_START_TIME=$CURRENT_TIME
+      fi
+
+      if [[ ! "$SEEN_STAGES" =~ "disk_created" ]] && echo "$DOCKER_LOGS" | grep -q "Creating a.*growable disk image"; then
+        if [[ "$BUILD_START_TIME" -gt 0 ]]; then
+          printf "%s Building complete [OK]\n" "$TIME_PREFIX"
+        fi
+        printf "%s Creating virtual disk...\n" "$TIME_PREFIX"
+        SEEN_STAGES="${SEEN_STAGES}disk_created "
+        DISK_START_TIME=$CURRENT_TIME
+      fi
+
+      if [[ ! "$SEEN_STAGES" =~ "booting" ]] && echo "$DOCKER_LOGS" | grep -q "Booting Windows using QEMU"; then
+        if [[ "$DISK_START_TIME" -gt 0 ]]; then
+          printf "%s Disk creation complete [OK]\n" "$TIME_PREFIX"
+        fi
+        printf "%s Booting Windows...\n" "$TIME_PREFIX"
+        SEEN_STAGES="${SEEN_STAGES}booting "
+        BOOT_START_TIME=$CURRENT_TIME
+      fi
+
+      if [[ ! "$SEEN_STAGES" =~ "started" ]] && echo "$DOCKER_LOGS" | grep -q "Windows started successfully"; then
+        if [[ "$BOOT_START_TIME" -gt 0 ]]; then
+          printf "%s Boot complete [OK]\n" "$TIME_PREFIX"
+        fi
+        printf "%s Windows installation started\n" "$TIME_PREFIX"
+        SEEN_STAGES="${SEEN_STAGES}started "
+        WINDOWS_START_TIME=$CURRENT_TIME
+      fi
+
+      # Count Windows Boot Manager occurrences (reboots during setup)
+      # Note: Each reboot shows "loading" AND "starting" - count only "loading" to avoid duplicates
+      local NEW_BOOT_COUNT
+      NEW_BOOT_COUNT=$(echo "$DOCKER_LOGS" | grep -c "BdsDxe: loading Boot.*Windows Boot Manager" 2>/dev/null) || NEW_BOOT_COUNT=0
+      # Ensure clean number (remove any whitespace/newlines)
+      NEW_BOOT_COUNT=$(echo "$NEW_BOOT_COUNT" | tr -d '[:space:]')
+      NEW_BOOT_COUNT=${NEW_BOOT_COUNT:-0}
+      if [[ "$NEW_BOOT_COUNT" -gt "$BOOT_COUNT" ]] && [[ "$NEW_BOOT_COUNT" -gt 1 ]]; then
+        # Show each reboot increment (in case we missed a check cycle)
+        for ((i = $((BOOT_COUNT + 1)); i <= NEW_BOOT_COUNT; i++)); do
+          if [[ "$i" -gt 1 ]]; then
+            printf "%s Windows setup reboot #%d\n" "$TIME_PREFIX" "$((i - 1))"
+          fi
+        done
+        BOOT_COUNT=$NEW_BOOT_COUNT
+      fi
+    fi
+
+    # Display storage size every minute (only after disk is created)
+    if [[ "$SEEN_STAGES" =~ "disk_created" ]]; then
+      if [[ "$((CURRENT_TIME - LAST_DISPLAY_TIME))" -ge "$DISPLAY_INTERVAL" ]] || [[ "$LAST_DISPLAY_TIME" -eq 0 ]]; then
+        LAST_DISPLAY_TIME=$CURRENT_TIME
+        show_disk_usage "$VM_DISK" "$TIME_PREFIX"
+      fi
+    fi
+
+    # Check for OEM completion marker (created by Windows after installation)
+    if [[ "$MARKER_DETECTED" == false ]]; then
+      if [[ -f "$COMPLETION_MARKER" ]]; then
+        MARKER_DETECTED=true
+        handle_installation_marker "$COMPLETION_MARKER" "$TIME_PREFIX"
+      else
+        # Check if container crashed while waiting for marker
+        local CONTAINER_STATUS=$(docker ps -a --filter "name=omarchy-windows" --format "{{.Status}}" 2>/dev/null)
+        if [[ "$CONTAINER_STATUS" =~ ^Exited ]]; then
+          msg_error "VM crashed during installation"
+          echo "  Check logs: docker logs omarchy-windows"
+          return 1
+        fi
+        sleep $MARKER_CHECK_INTERVAL
+        continue
+      fi
+    fi
+
+    if [[ "$MARKER_DETECTED" == true ]]; then
+      show_installation_summary "$ELAPSED" "$USERNAME" "$PASSWORD" "$LG_ENABLED" \
+        "$DOWNLOAD_START_TIME" "$EXTRACT_START_TIME" "$OEM_START_TIME" \
+        "$BUILD_START_TIME" "$DISK_START_TIME" "$BOOT_START_TIME" \
+        "$WINDOWS_START_TIME" "$CURRENT_TIME" "$IS_FRESH_INSTALL"
+      launch_after_install "$USERNAME" "$PASSWORD" "$LG_ENABLED" "$IS_FRESH_INSTALL"
+      break
+    fi
+
+    if [[ "$ELAPSED" -ge "$TIMEOUT" ]]; then
+      msg_warning "Monitoring timeout - VM still running"
+      echo "   Check: http://127.0.0.1:8006 or omarchy-windows-vm launch"
+      break
+    fi
+  done
+}
+
+# Build dockurr/windows:latest with SPICE support
+# SPICE module (qemu-system-modules-spice) was rejected from upstream
+# See: https://github.com/dockur/windows/pull/1567
+build_dockurr_windows_with_spice() {
+  local build_dir="/tmp/dockurr-windows-spice-$$"
+
+  # Cleanup on exit (success, failure, or Ctrl+C)
+  trap "rm -rf '$build_dir' 2>/dev/null || true" EXIT INT TERM
+
+  msg_info "Building Docker image with SPICE support..."
+
+  # Clone dockur/windows repository
+  if ! git clone --quiet --depth 1 https://github.com/dockur/windows.git "$build_dir" 2>/dev/null; then
+    msg_error "Failed to clone repository (check internet)"
+    return 1
+  fi
+
+  cd "$build_dir" || return 1
+
+  # Modify Dockerfile to add SPICE support (if not already present)
+  if ! grep -q 'qemu-system-modules-spice' Dockerfile; then
+    if ! sed -i 's/libarchive-tools && \\/libarchive-tools \\\n        qemu-system-modules-spice \&\& \\/' Dockerfile; then
+      msg_error "Failed to patch Dockerfile"
+      return 1
+    fi
+  fi
+
+  local DOCKER_BUILD_LOG="/tmp/docker-build-$(date +%Y%m%d-%H%M%S).log"
+  if ! run_with_spinner "   Building Docker image..." bash -c 'docker build -t dockurr/windows:latest . >"$1" 2>&1' _ "$DOCKER_BUILD_LOG"; then
+    msg_error "Docker build failed (log: $DOCKER_BUILD_LOG)"
+    return 1
+  fi
+
+  msg_success "Docker image built with SPICE support"
+  return 0
+}
+
+# Ensure dockurr/windows:latest has SPICE support
+# Checks if image exists and has qemu-system-modules-spice
+# Rebuilds if missing or lacks SPICE
+ensure_dockurr_windows_with_spice() {
+  # Check Docker daemon is running
+  if ! docker info &>/dev/null; then
+    msg_error "Docker daemon is not running"
+    echo "   Start: sudo systemctl start docker"
+    return 1
+  fi
+
+  # Check if image exists locally with SPICE
+  if docker image inspect dockurr/windows:latest &>/dev/null; then
+    if docker history --no-trunc dockurr/windows:latest 2>/dev/null | grep -q 'qemu-system-modules-spice'; then
+      msg_success "Docker image ready (SPICE support detected)"
+      return 0
+    fi
+    # Image exists but lacks SPICE - remove it
+    docker rmi dockurr/windows:latest 2>/dev/null || true
+  fi
+
+  # Build image with SPICE
+  if ! build_dockurr_windows_with_spice; then
+    msg_error "Failed to build Docker image with SPICE support"
+    return 1
+  fi
+
+  return 0
+}
+
+install_windows() {
+  # Set up trap to handle Ctrl+C
+  trap "echo ''; echo 'Installation cancelled by user'; exit 1" INT
+
+  # Request sudo access upfront (avoids password prompt during installation)
+  if ! sudo -v 2>/dev/null; then
+    msg_error "sudo access required for installation"
+    exit 1
+  fi
+
+  # Initialize previous config variables
+  PREVIOUS_TPM_ENABLED=""
+
+  # Handle existing installation - fresh or quick reinstall
+  if [[ -f "$COMPOSE_FILE" ]] || [[ -d "$HOME/.windows" ]]; then
+    # Read previous configuration before showing reinstall choice
+    PREVIOUS_RAM=""
+    PREVIOUS_CPU=""
+    PREVIOUS_DISK=""
+    PREVIOUS_USERNAME=""
+    PREVIOUS_PASSWORD=""
+    PREVIOUS_LG_ENABLED=false
+    PREVIOUS_GPU_ENABLED=false
+    PREVIOUS_TPM_ENABLED=false
+    PREVIOUS_IVSHMEM_SIZE=""
+
+    if [[ -f "$COMPOSE_FILE" ]]; then
+      # Extract values from docker-compose.yml
+      PREVIOUS_RAM=$(grep '^\s*RAM_SIZE:' "$COMPOSE_FILE" | sed 's/.*RAM_SIZE: "\(.*\)".*/\1/' | tr -d '"')
+      PREVIOUS_CPU=$(grep '^\s*CPU_CORES:' "$COMPOSE_FILE" | sed 's/.*CPU_CORES: "\(.*\)".*/\1/' | tr -d '"')
+      PREVIOUS_DISK=$(grep '^\s*DISK_SIZE:' "$COMPOSE_FILE" | sed 's/.*DISK_SIZE: "\(.*\)".*/\1/' | tr -d '"')
+      PREVIOUS_USERNAME=$(grep '^\s*USERNAME:' "$COMPOSE_FILE" | sed 's/.*USERNAME: "\(.*\)".*/\1/' | tr -d '"')
+      PREVIOUS_PASSWORD=$(grep '^\s*PASSWORD:' "$COMPOSE_FILE" | sed 's/.*PASSWORD: "\(.*\)".*/\1/' | tr -d '"')
+
+      # Check Looking Glass (ivshmem-plain in ARGUMENTS) and extract IVSHMEM size
+      if grep -q 'ivshmem-plain' "$COMPOSE_FILE"; then
+        PREVIOUS_LG_ENABLED=true
+        PREVIOUS_IVSHMEM_SIZE=$(grep -oP 'size=\K[0-9]+' "$COMPOSE_FILE" | head -1)
+        [[ -z "$PREVIOUS_IVSHMEM_SIZE" ]] && PREVIOUS_IVSHMEM_SIZE=64
+      fi
+
+      # Check GPU passthrough (vfio-pci in ARGUMENTS)
+      if grep -q 'vfio-pci' "$COMPOSE_FILE"; then
+        PREVIOUS_GPU_ENABLED=true
+      fi
+
+      # Check TPM (TPM: "Y" in environment)
+      if grep -q 'TPM:.*Y' "$COMPOSE_FILE"; then
+        PREVIOUS_TPM_ENABLED=true
+      fi
+    fi
+
+    msg_warning "Previous Windows VM installation detected"
+    echo ""
+    echo "Found:"
+    [[ -f "$COMPOSE_FILE" ]] && echo "  • Configuration: $COMPOSE_FILE"
+    [[ -d "$HOME/.windows" ]] && echo "  • VM disk: $HOME/.windows/"
+
+    # Show previous configuration if available
+    if [[ -n "$PREVIOUS_RAM" ]]; then
+      echo ""
+      echo "Previous configuration:"
+      echo "  RAM:              $PREVIOUS_RAM"
+      echo "  CPU:              $PREVIOUS_CPU cores"
+      echo "  Disk:             $PREVIOUS_DISK"
+      echo "  Username:         $PREVIOUS_USERNAME"
+      echo "  GPU Passthrough:  $([[ "$PREVIOUS_GPU_ENABLED" == true ]] && echo "Enabled" || echo "Disabled")"
+      echo "  Looking Glass:    $([[ "$PREVIOUS_LG_ENABLED" == true ]] && echo "Enabled" || echo "Disabled")"
+      echo "  TPM/Secure Boot:  $([[ "$PREVIOUS_TPM_ENABLED" == true ]] && echo "Enabled" || echo "Disabled")"
+    fi
+
+    echo ""
+    echo "What would you like to do?"
+
+    REINSTALL_CHOICE=$(gum choose --selected="Quick reinstall (keep VM data, update config)" \
+      "Quick reinstall (keep VM data, update config)" \
+      "Fresh install (delete all data and reinstall)")
+
+    # Check if user cancelled (Ctrl+C returns empty string)
+    if [[ -z "$REINSTALL_CHOICE" ]]; then
+      echo ""
+      echo "Installation cancelled by user"
+      exit 1
+    fi
+
+    if [[ "$REINSTALL_CHOICE" == "Fresh install"* ]]; then
+      echo ""
+      echo "Fresh installation: Removing all previous data..."
+      echo ""
+      echo "This will DELETE:"
+      echo "  ⚠️  VM disk and Windows OS ($HOME/.windows/)"
+      echo "  ⚠️  Configuration files"
+      echo ""
+      echo "This will KEEP:"
+      echo "  ✓  Shared files ($HOME/Windows/) - your data"
+      echo ""
+
+      docker-compose -f "$COMPOSE_FILE" down 2>/dev/null || true
+      rm -f "$COMPOSE_FILE"
+      rm -rf "$HOME/.config/windows"
+
+      if [[ -d "$HOME/.windows" ]]; then
+        echo "  • Removing VM disk..."
+        sudo rm -rf "$HOME/.windows"
+      fi
+
+      [[ -d "$HOME/.config/windows/oem" ]] && rm -rf "$HOME/.config/windows/oem" 2>/dev/null
+      rm -f "$HOME/Windows/installation-complete.txt" 2>/dev/null
+      rm -f "$HOME/.local/share/applications/windows-vm.desktop" "$HOME/.local/share/applications/windows-looking-glass.desktop"
+
+      # Update desktop database after removing old icons
+      if command -v update-desktop-database &>/dev/null; then
+        update-desktop-database "$HOME/.local/share/applications" 2>/dev/null || true
+      fi
+
+      echo ""
+      msg_success "Previous installation completely removed"
+      echo ""
+
+      # Clear previous values to use intelligent defaults for fresh install
+      PREVIOUS_RAM=""
+      PREVIOUS_CPU=""
+      PREVIOUS_DISK=""
+      PREVIOUS_USERNAME=""
+      PREVIOUS_PASSWORD=""
+      PREVIOUS_LG_ENABLED=false
+      PREVIOUS_GPU_ENABLED=false
+      PREVIOUS_TPM_ENABLED=false
+      PREVIOUS_IVSHMEM_SIZE=""
+    else
+      echo ""
+      echo "Quick reinstall: Keeping VM disk, updating configuration..."
+      echo ""
+
+      # Stop VM but keep configuration until user confirms new settings
+      docker-compose -f "$COMPOSE_FILE" down 2>/dev/null || true
+
+      msg_success "VM stopped, configuration preserved (will update after confirmation)"
+      echo ""
+      msg_info "Quick reinstall only updates docker-compose configuration"
+      echo "   Windows installation and all your files remain unchanged"
+      echo "   VM will boot to existing Windows system with new config"
+      echo ""
+
+      # Skip OEM auto-run since Windows is already installed
+      # Mark for later cleanup (after user confirms configuration)
+      SKIP_OEM_AUTORUN=true
+      QUICK_REINSTALL_CLEANUP=true
+    fi
+  fi
+
+  check_prerequisites
+
+  # Install dependencies quietly
+  msg_info "Installing dependencies..."
+  DEPS_LOG="/tmp/omarchy-windows-deps-$$.log"
+
+  # Build dependency list (skip netcat if nc already available - avoids gnu-netcat conflict)
+  local deps="freerdp dmidecode"
+  if ! command -v nc &>/dev/null; then
+    deps="$deps openbsd-netcat"
+  fi
+
+  if ! omarchy-pkg-add $deps > "$DEPS_LOG" 2>&1; then
+    msg_error "Failed to install dependencies"
+    echo ""
+    tail -15 "$DEPS_LOG"
+    rm -f "$DEPS_LOG"
+    exit 1
+  fi
+  rm -f "$DEPS_LOG"
+  msg_success "Dependencies installed"
+
+  configure_sudoers_windows_vm
+
+  mkdir -p "$HOME/.windows"
+  mkdir -p "$HOME/.config/windows"
+
+  # Get system resources
+  TOTAL_RAM=$(free -h | awk 'NR==2 {print $2}')
+  TOTAL_RAM_GB=$(awk 'NR==1 {printf "%d", $2/1024/1024}' /proc/meminfo)
+  TOTAL_CORES=$(nproc)
+
+  # Validate RAM detection (must be positive number)
+  if ! [[ "$TOTAL_RAM_GB" =~ ^[0-9]+$ ]] || [[ "$TOTAL_RAM_GB" -eq 0 ]]; then
+    msg_warning "Could not detect total RAM, using safe default (8GB)"
+    TOTAL_RAM_GB=8
+    TOTAL_RAM="8G"
+  fi
+
+  # Validate TOTAL_RAM display value (Bug #30 fix)
+  if [[ -z "$TOTAL_RAM" ]]; then
+    TOTAL_RAM="${TOTAL_RAM_GB}G"
+  fi
+
+  echo "System resources: $TOTAL_RAM RAM, $TOTAL_CORES CPU cores"
+  echo ""
+
+  RAM_OPTIONS=""
+  for size in 2 4 8 16 32 64; do
+    if [[ "$size" -le "$TOTAL_RAM_GB" ]]; then
+      RAM_OPTIONS="$RAM_OPTIONS ${size}G"
+    fi
+  done
+  RAM_OPTIONS="$RAM_OPTIONS Custom"
+
+  # Use previous RAM if available AND in options list, otherwise calculate intelligent default
+  if [[ -n "$PREVIOUS_RAM" ]] && echo "$RAM_OPTIONS" | grep -q "$PREVIOUS_RAM"; then
+    DEFAULT_RAM="$PREVIOUS_RAM"
+  else
+    # Calculate half of total RAM, find largest value from options that is smaller than half
+    HALF_RAM=$((TOTAL_RAM_GB / 2))
+    DEFAULT_RAM="4G"            # fallback
+    for size in 32 16 8 4 2; do # reversed order (largest to smallest)
+      if [[ "$size" -lt "$HALF_RAM" ]] && [[ "$size" -le "$TOTAL_RAM_GB" ]]; then
+        DEFAULT_RAM="${size}G"
+        break
+      fi
+    done
+  fi
+  SELECTED_RAM=$(echo "$RAM_OPTIONS" | tr ' ' '\n' | gum choose --selected="$DEFAULT_RAM" --header="How much RAM would you like to allocate to Windows VM?")
+
+  # Check if user cancelled
+  if [[ -z "$SELECTED_RAM" ]]; then
+    echo "Installation cancelled by user"
+    exit 1
+  fi
+
+  # Handle Custom RAM option
+  if [[ "$SELECTED_RAM" == "Custom" ]]; then
+    local MAX_RAM_GB=$((TOTAL_RAM_GB - 4))
+    [[ "$MAX_RAM_GB" -lt 2 ]] && MAX_RAM_GB=2
+    while true; do
+      CUSTOM_RAM=$(gum input --placeholder "Enter RAM in GB (2-${MAX_RAM_GB})" --header="Custom RAM size")
+      if [[ -z "$CUSTOM_RAM" ]]; then
+        echo "Installation cancelled by user"
+        exit 1
+      fi
+      if [[ "$CUSTOM_RAM" =~ ^[0-9]+$ ]] && [[ "$CUSTOM_RAM" -ge 2 ]] && [[ "$CUSTOM_RAM" -le "$MAX_RAM_GB" ]]; then
+        SELECTED_RAM="${CUSTOM_RAM}G"
+        break
+      else
+        msg_warning "RAM must be between 2 and ${MAX_RAM_GB} GB"
+      fi
+    done
+  fi
+
+  msg_success "RAM: $SELECTED_RAM"
+
+  # Use previous CPU cores if available, otherwise calculate intelligent default (quarter of total)
+  if [[ -n "$PREVIOUS_CPU" ]]; then
+    DEFAULT_CORES="$PREVIOUS_CPU"
+  else
+    # Calculate quarter of total cores (conservative: leave more for host)
+    DEFAULT_CORES=$((TOTAL_CORES / 4))
+    [[ "$DEFAULT_CORES" -lt 1 ]] && DEFAULT_CORES=1
+  fi
+  SELECTED_CORES=$(gum input --placeholder="Number of CPU cores (1-$TOTAL_CORES)" --value="$DEFAULT_CORES" --header="How many CPU cores would you like to allocate to Windows VM?" --char-limit=2)
+
+  # Check if user cancelled (Ctrl+C in gum input returns empty string)
+  if [[ -z "$SELECTED_CORES" ]]; then
+    echo "Installation cancelled by user"
+    exit 1
+  fi
+
+  if ! [[ "$SELECTED_CORES" =~ ^[0-9]+$ ]] || [[ "$SELECTED_CORES" -lt 1 ]] || [[ "$SELECTED_CORES" -gt "$TOTAL_CORES" ]]; then
+    echo "Invalid input. Using default: 2 cores"
+    SELECTED_CORES=2
+  fi
+
+  msg_success "CPU: $SELECTED_CORES cores"
+
+  AVAILABLE_SPACE=$(df "$HOME" | awk 'NR==2 {print int($4/1024/1024)}')
+  MAX_DISK_GB=$((AVAILABLE_SPACE - 10)) # Leave 10GB for Windows image
+
+  # Check if we have enough space for minimum
+  if [[ "$MAX_DISK_GB" -lt 32 ]]; then
+    msg_error "Insufficient disk space for Windows VM!"
+    echo "   Available: ${AVAILABLE_SPACE}GB"
+    echo "   Minimum required: 42GB (32GB disk + 10GB for Windows image)"
+    exit 1
+  fi
+
+  DISK_OPTIONS=""
+  for size in 32 64 128 256 512 1024 2048 4096 8192; do
+    if [[ "$size" -le "$MAX_DISK_GB" ]]; then
+      DISK_OPTIONS="$DISK_OPTIONS ${size}G"
+    fi
+  done
+  DISK_OPTIONS="$DISK_OPTIONS Custom"
+
+  # Use previous disk if available, otherwise calculate intelligent default (half of max, choose smaller, cap at 256GB)
+  if [[ -n "$PREVIOUS_DISK" ]] && echo "$DISK_OPTIONS" | grep -q "$PREVIOUS_DISK"; then
+    DEFAULT_DISK="$PREVIOUS_DISK"
+  else
+    # Calculate half of max disk space, find largest value smaller than half (max suggestion: 256GB)
+    HALF_DISK=$((MAX_DISK_GB / 2))
+    DEFAULT_DISK="32G"            # fallback
+    for size in 256 128 64 32; do # removed 512, max suggestion is 256GB
+      if [[ "$size" -lt "$HALF_DISK" ]] && [[ "$size" -le "$MAX_DISK_GB" ]]; then
+        DEFAULT_DISK="${size}G"
+        break
+      fi
+    done
+  fi
+
+  SELECTED_DISK=$(echo "$DISK_OPTIONS" | tr ' ' '\n' | gum choose --selected="$DEFAULT_DISK" --header="How much disk space would you like to give Windows VM? (64GB+ recommended)")
+
+  # Check if user cancelled
+  if [[ -z "$SELECTED_DISK" ]]; then
+    echo "Installation cancelled by user"
+    exit 1
+  fi
+
+  # Handle Custom disk option
+  if [[ "$SELECTED_DISK" == "Custom" ]]; then
+    while true; do
+      CUSTOM_DISK=$(gum input --placeholder "Enter size in GB (32-${MAX_DISK_GB})" --header="Custom disk size")
+      if [[ -z "$CUSTOM_DISK" ]]; then
+        echo "Installation cancelled by user"
+        exit 1
+      fi
+      if [[ "$CUSTOM_DISK" =~ ^[0-9]+$ ]] && [[ "$CUSTOM_DISK" -ge 32 ]] && [[ "$CUSTOM_DISK" -le "$MAX_DISK_GB" ]]; then
+        SELECTED_DISK="${CUSTOM_DISK}G"
+        break
+      else
+        msg_warning "Disk size must be between 32 and ${MAX_DISK_GB} GB"
+      fi
+    done
+  fi
+
+  msg_success "Disk: $SELECTED_DISK"
+
+  # Extract just the number for prerequisite check
+  DISK_SIZE_NUM=$(echo "$SELECTED_DISK" | sed 's/G//')
+
+  # Re-check prerequisites with selected disk size
+  check_prerequisites "$DISK_SIZE_NUM"
+
+  # Prompt for username and password
+  # Use previous username if available, otherwise show default
+  if [[ -n "$PREVIOUS_USERNAME" ]]; then
+    USERNAME=$(gum input --placeholder="Username (Press enter to use previous: $PREVIOUS_USERNAME)" --value="$PREVIOUS_USERNAME" --header="Enter Windows username:")
+    if [[ -z "$USERNAME" ]]; then
+      USERNAME="$PREVIOUS_USERNAME"
+    fi
+  else
+    USERNAME=$(gum input --placeholder="Username (Press enter to use default: docker)" --header="Enter Windows username:")
+    if [[ -z "$USERNAME" ]]; then
+      USERNAME="docker"
+    fi
+  fi
+
+  # Validate username (no quotes or special YAML chars)
+  if [[ "$USERNAME" =~ [\"\'\`\$\\] ]]; then
+    msg_error "Username cannot contain quotes, backticks, dollar signs, or backslashes"
+    echo "   These characters would break the configuration file"
+    exit 1
+  fi
+
+  # Password prompt - different logic for Quick reinstall vs Fresh install
+  if [[ -n "$PREVIOUS_USERNAME" ]]; then
+    # Quick reinstall - ask if user wants to change password
+    echo ""
+    if gum confirm --default=false "Change Windows password in docker-compose configuration?"; then
+      echo ""
+      msg_warning "Important: This only updates docker-compose.yml configuration"
+      echo "   Password in Windows VM remains unchanged"
+      echo "   To match: Change password in Windows first, then update here"
+      echo ""
+
+      PASSWORD=$(gum input --placeholder="Enter new password for docker-compose" --password --header="New Windows password:")
+      if [[ -z "$PASSWORD" ]]; then
+        echo "Password cannot be empty"
+        exit 1
+      fi
+      PASSWORD_DISPLAY="(changed)"
+    else
+      # Keep previous password (already extracted before COMPOSE_FILE was deleted)
+      if [[ -z "$PREVIOUS_PASSWORD" ]]; then
+        echo ""
+        msg_warning "Could not extract previous password from docker-compose.yml"
+        echo "   Please enter password for configuration:"
+        echo ""
+        PASSWORD=$(gum input --placeholder="Enter password" --password --header="Windows password:")
+        if [[ -z "$PASSWORD" ]]; then
+          echo "Password cannot be empty"
+          exit 1
+        fi
+        PASSWORD_DISPLAY="(re-entered)"
+      else
+        PASSWORD="$PREVIOUS_PASSWORD"
+        PASSWORD_DISPLAY="(kept previous)"
+      fi
+    fi
+  else
+    # Fresh install - prompt for password
+    PASSWORD=$(gum input --placeholder="Password (Press enter to use default: admin)" --password --header="Enter Windows password:")
+    if [[ -z "$PASSWORD" ]]; then
+      PASSWORD="admin"
+      PASSWORD_DISPLAY="(default)"
+    else
+      PASSWORD_DISPLAY="(user-defined)"
+    fi
+  fi
+
+  # Validate password (no quotes or special YAML chars)
+  if [[ "$PASSWORD" =~ [\"\'\`\$\\] ]]; then
+    msg_error "Password cannot contain quotes, backticks, dollar signs, or backslashes"
+    echo "   These characters would break the configuration file"
+    exit 1
+  fi
+
+  msg_success "Credentials: $USERNAME"
+  mkdir -p "$HOME/Windows"
+
+  # TPM & Secure Boot (optional, enables BitLocker/Windows Hello)
+  local TPM_DEFAULT=true
+  [[ "$PREVIOUS_TPM_ENABLED" == false ]] && TPM_DEFAULT=false
+
+  if gum confirm --default="$TPM_DEFAULT" "Enable TPM & Secure Boot?"; then
+    TPM_ENABLED=true
+    msg_success "Security: TPM + Secure Boot"
+  else
+    TPM_ENABLED=false
+    msg_info "Security: Disabled"
+  fi
+
+  # GPU detection and configuration prompts (decision only, no execution yet)
+  HAS_DEDICATED_GPU=false
+  GPU_INFO=""
+  GPU_PASSTHROUGH_READY=false
+  GPU_PASSTHROUGH_ENABLED=false
+  GPU_PASSTHROUGH_NEEDS_SETUP=false
+
+  # Looking Glass requires dedicated GPU (NVIDIA/AMD/Intel Arc), not integrated
+  if command -v lspci &>/dev/null; then
+    GPU_INFO=$(lspci | grep -iE 'VGA compatible|3D controller|Display controller' | grep -E 'NVIDIA|AMD|Arc' | grep -vE 'Intel.*(UHD|HD Graphics [0-9]{3,4}$)' | head -1)
+    if [[ -n "$GPU_INFO" ]]; then
+      HAS_DEDICATED_GPU=true
+
+      # Extract clean GPU name (e.g., "NVIDIA RTX 5070" instead of full lspci output)
+      # Use last bracket for AMD GPUs with multiple brackets: [AMD/ATI] ... [Radeon RX 7900 XT]
+      GPU_NAME=$(echo "$GPU_INFO" | grep -oP '\[[^\]]+\]' | tail -1 | tr -d '[]')
+
+      # Add vendor prefix and remove redundant prefixes
+      if [[ -n "$GPU_NAME" ]]; then
+        if [[ "$GPU_INFO" =~ NVIDIA ]]; then
+          GPU_NAME="${GPU_NAME#GeForce }"
+          GPU_NAME="NVIDIA $GPU_NAME"
+        elif [[ "$GPU_INFO" =~ AMD|ATI ]]; then
+          GPU_NAME="${GPU_NAME#Radeon }"
+          GPU_NAME="AMD $GPU_NAME"
+        elif [[ "$GPU_INFO" =~ Arc ]]; then
+          GPU_NAME="Intel $GPU_NAME"
+        fi
+      else
+        # Fallback if no brackets found (unlikely but safe)
+        GPU_NAME="$GPU_INFO"
+      fi
+
+      msg_success "Dedicated GPU detected: $GPU_NAME"
+    else
+      msg_warning "No dedicated GPU detected (NVIDIA/AMD/Arc required for Looking Glass)"
+    fi
+  else
+    msg_warning "lspci not available - cannot detect GPU"
+  fi
+
+  # Check GPU passthrough configuration
+  if [[ "$HAS_DEDICATED_GPU" == true ]]; then
+    if command -v omarchy-gpu-passthrough-info &>/dev/null; then
+      # Check if GPU passthrough is already configured
+      if omarchy-gpu-passthrough-info is-configured &>/dev/null; then
+        msg_success "GPU passthrough ready"
+
+        if gum confirm "Use GPU passthrough for this VM?"; then
+          GPU_PASSTHROUGH_READY=true
+          GPU_PASSTHROUGH_ENABLED=true
+
+          GPU_PCI_ADDR=""
+          GPU_IOMMU_GROUP=""
+          GPU_IOMMU_DEVICES=""
+          GPU_CONFIG=$(omarchy-gpu-passthrough-info get-docker-config 2>/dev/null)
+          if [[ -n "$GPU_CONFIG" ]]; then
+            read -r GPU_PCI_ADDR GPU_IOMMU_GROUP GPU_IOMMU_DEVICES <<<"$GPU_CONFIG"
+          fi
+        else
+          GPU_PASSTHROUGH_READY=false
+          GPU_PASSTHROUGH_ENABLED=false
+          msg_info "VM will use CPU-only graphics"
+        fi
+      else
+        msg_warning "GPU passthrough not configured"
+        echo "  Benefits: Native GPU performance, ray tracing, Looking Glass"
+
+        if gum confirm "Configure GPU passthrough now? (requires reboot)"; then
+          GPU_PASSTHROUGH_NEEDS_SETUP=true
+          GPU_PASSTHROUGH_ENABLED=true
+        else
+          msg_info "Skipping - configure later with: omarchy-gpu-passthrough setup"
+        fi
+      fi
+    else
+      msg_warning "omarchy-gpu-passthrough not found"
+    fi
+  fi
+
+  # Looking Glass configuration
+  LG_ENABLED=false
+  LG_NEEDS_INSTALL=false
+
+  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]]; then
+    if is_looking_glass_ready; then
+      msg_success "Looking Glass ready"
+      LG_ENABLED=true
+    else
+      if gum confirm "Do you have a display connected to GPU?"; then
+        if gum confirm "Enable Looking Glass?"; then
+          LG_ENABLED=true
+          LG_NEEDS_INSTALL=true
+
+          echo ""
+          echo "Select Looking Glass shared memory size:"
+          echo ""
+          echo "  Resolution     Minimum   Recommended"
+          echo "  1920×1080      32 MB     64 MB"
+          echo "  2560×1440      64 MB     128 MB"
+          echo "  3840×2160      128 MB    256 MB"
+          echo ""
+          echo "  Higher refresh rate (144Hz+) needs more memory."
+          echo "  If VM fails to start, try smaller size."
+          echo ""
+          echo "  Note: IVSHMEM size controls memory, not resolution."
+          echo ""
+          RESOLUTION_CHOICE=$(gum choose --selected="1080p (64MB) - recommended" \
+            "1080p (32MB) - minimal, low RAM" \
+            "1080p (64MB) - recommended" \
+            "1440p (128MB)" \
+            "4K (256MB)")
+
+          if [[ -z "$RESOLUTION_CHOICE" ]]; then
+            echo ""
+            echo "Installation cancelled by user"
+            exit 0
+          fi
+
+          case "$RESOLUTION_CHOICE" in
+          *32MB*) IVSHMEM_SIZE=32 ;;
+          *64MB*) IVSHMEM_SIZE=64 ;;
+          *128MB*) IVSHMEM_SIZE=128 ;;
+          *256MB*) IVSHMEM_SIZE=256 ;;
+          *) IVSHMEM_SIZE=64 ;;
+          esac
+          export IVSHMEM_SIZE
+          msg_success "IVSHMEM: ${IVSHMEM_SIZE}MB"
+        else
+          msg_info "Skipping - use VNC/RDP instead (add later: omarchy-looking-glass-install)"
+        fi
+      else
+        msg_info "Looking Glass requires display connected to GPU"
+        echo "  Options:"
+        echo "    • Second monitor on GPU"
+        echo "    • Same monitor with 2 cables"
+        echo "    • HDMI dummy plug (~\$5)"
+        echo "  Run: omarchy-looking-glass-install (after connecting display)"
+      fi
+    fi
+  fi
+
+  # Configuration summary
+  echo ""
+  echo "Configuration Summary"
+  echo "  Resources:  $SELECTED_RAM RAM, $SELECTED_CORES cores, $SELECTED_DISK disk"
+  echo "  User:       $USERNAME $PASSWORD_DISPLAY"
+  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]]; then
+    if [[ "$GPU_PASSTHROUGH_NEEDS_SETUP" == true ]]; then
+      echo "  GPU:        Will be configured (reboot required)"
+    else
+      echo "  GPU:        $GPU_NAME (passthrough)"
+    fi
+  else
+    echo "  GPU:        CPU-only (no passthrough)"
+  fi
+  if [[ "$LG_ENABLED" == true ]]; then
+    if [[ "$LG_NEEDS_INSTALL" == true ]]; then
+      echo "  Display:    Looking Glass (will install)"
+    else
+      echo "  Display:    Looking Glass (ready)"
+    fi
+  else
+    echo "  Display:    RDP/VNC"
+  fi
+  if [[ "$TPM_ENABLED" == true ]]; then
+    echo "  Security:   TPM 2.0 + Secure Boot"
+  else
+    echo "  Security:   Disabled"
+  fi
 
-check_prerequisites() {
-  local DISK_SIZE_GB=${1:-64}
-  local REQUIRED_SPACE=$((DISK_SIZE_GB + 10))  # Add 10GB for Windows ISO and overhead
+  if [[ "$GPU_PASSTHROUGH_NEEDS_SETUP" == true ]]; then
+    echo ""
+    msg_warning "GPU setup requires reboot - other steps will run after"
+  fi
 
-  # Check for KVM support
-  if [ ! -e /dev/kvm ]; then
-    gum style \
-      --border normal \
-      --padding "1 2" \
-      --margin "1" \
-      "❌ KVM virtualization not available!" \
-      "" \
-      "Please enable virtualization in BIOS or run:" \
-      "  sudo modprobe kvm-intel  # for Intel CPUs" \
-      "  sudo modprobe kvm-amd    # for AMD CPUs"
-    exit 1
+  if [[ "$LG_ENABLED" == true ]]; then
+    echo ""
+    msg_info "Reminder: Looking Glass needs display connected to GPU"
   fi
 
-  # Check disk space
-  AVAILABLE_SPACE=$(df "$HOME" | awk 'NR==2 {print int($4/1024/1024)}')
-  if [ "$AVAILABLE_SPACE" -lt "$REQUIRED_SPACE" ]; then
-    echo "❌ Insufficient disk space!"
-    echo "   Available: ${AVAILABLE_SPACE}GB"
-    echo "   Required: ${REQUIRED_SPACE}GB (${DISK_SIZE_GB}GB disk + 10GB for Windows image)"
+  echo ""
+  echo "Estimated time: 10-30 minutes"
+
+  if ! gum confirm "Proceed with installation?"; then
+    echo ""
+    echo "Installation cancelled by user"
+    echo ""
+    echo "You can restart installation later with: omarchy-windows-vm install"
+    exit 0
+  fi
+  echo ""
+
+  # Execute GPU passthrough setup if needed (may exit with reboot required)
+  if [[ "$GPU_PASSTHROUGH_NEEDS_SETUP" == true ]]; then
+    echo "Configuring GPU passthrough..."
+    echo ""
+
+    if omarchy-gpu-passthrough setup; then
+      msg_success "GPU passthrough configured successfully!"
+      echo ""
+      msg_warning "SYSTEM REBOOT REQUIRED"
+      echo ""
+      echo "Kernel parameters have been configured and require reboot."
+      echo ""
+      echo "After reboot:"
+      echo "   1. Verify GPU passthrough: omarchy-gpu-passthrough info verify"
+      echo "   2. Re-run Windows VM installation: omarchy-windows-vm install"
+      echo ""
+      exit 0
+    else
+      msg_error "GPU passthrough setup failed or was cancelled"
+      echo ""
+
+      if ! gum confirm "Continue installation without GPU passthrough?"; then
+        echo ""
+        echo "Installation cancelled"
+        exit 1
+      fi
+
+      echo ""
+      msg_info "Continuing without GPU passthrough"
+      msg_info "You can configure it later with: omarchy-gpu-passthrough setup"
+      echo ""
+
+      GPU_PASSTHROUGH_ENABLED=false
+      GPU_PASSTHROUGH_NEEDS_SETUP=false
+      LG_ENABLED=false
+      LG_NEEDS_INSTALL=false
+    fi
+  fi
+
+  # Execute Looking Glass installation if needed
+  NEEDS_REBOOT_FOR_LG=false
+  if [[ "$LG_NEEDS_INSTALL" == true ]]; then
+    install_looking_glass_client
+    LG_INSTALL_STATUS=$?
+
+    if [[ "$LG_INSTALL_STATUS" -eq 0 ]]; then
+      msg_success "Looking Glass ready"
+    elif [[ "$LG_INSTALL_STATUS" -eq 1 ]]; then
+      msg_warning "Looking Glass installed - reboot required"
+      NEEDS_REBOOT_FOR_LG=true
+    else
+      msg_error "Looking Glass installation failed"
+      [[ -d "$HOME/.config/windows/oem" ]] && rm -rf "$HOME/.config/windows/oem"
+      if ! gum confirm "Continue without Looking Glass?"; then
+        exit 1
+      fi
+      LG_ENABLED=false
+    fi
+  fi
+
+  # Refresh sudo credentials (interactive wizard may have taken time)
+  # This covers: GPU process detection, system configuration (dmidecode), Docker operations
+  if ! sudo -v 2>/dev/null; then
+    msg_error "sudo access required for system configuration"
     exit 1
   fi
-}
 
-install_windows() {
-  # Set up trap to handle Ctrl+C
-  trap "echo ''; echo 'Installation cancelled by user'; exit 1" INT
+  # Start OEM configuration
+  OEM_DIR="$HOME/.config/windows/oem"
+  mkdir -p "$OEM_DIR/wallpaper"
+
+  # Validate and resolve OMARCHY_PATH if set
+  if [[ -n "$OMARCHY_PATH" ]] && [[ -d "$OMARCHY_PATH" ]]; then
+    OMARCHY_PATH=$(realpath "$OMARCHY_PATH" 2>/dev/null)
+
+    if [[ -d "$OMARCHY_PATH" ]]; then
+      # Copy wallpaper if exists
+      if [[ -f "$OMARCHY_PATH/themes/rose-pine/backgrounds/3-leafy-dawn-omarchy.png" ]]; then
+        cp "$OMARCHY_PATH/themes/rose-pine/backgrounds/3-leafy-dawn-omarchy.png" "$OEM_DIR/wallpaper/omarchy.png"
+      fi
+
+      # Get git version
+      if [[ -d "$OMARCHY_PATH/.git" ]]; then
+        SCRIPT_VERSION="$(git -C "$OMARCHY_PATH" rev-parse --short HEAD 2>/dev/null || echo 'unknown')"
+      else
+        SCRIPT_VERSION="unknown"
+      fi
+    else
+      SCRIPT_VERSION="unknown"
+    fi
+  else
+    SCRIPT_VERSION="unknown"
+  fi
+  create_oem_powershell_script "$OEM_DIR" "$SCRIPT_VERSION"
+  create_oem_batch_script "$OEM_DIR"
+
+  # Download Looking Glass + SPICE installers silently (future-proof for quick reinstalls)
+  LG_ZIP="$OEM_DIR/looking-glass-host.zip"
+  LG_INSTALLER="$OEM_DIR/looking-glass-host-setup.exe"
+
+  if [[ ! -f "$LG_INSTALLER" ]]; then
+    if curl -L --max-time 300 --connect-timeout 30 -o "$LG_ZIP" "https://looking-glass.io/artifact/stable/host" 2>/dev/null; then
+      if unzip -q -o "$LG_ZIP" -d "$OEM_DIR" 2>/dev/null; then
+        rm "$LG_ZIP"
+      else
+        msg_warning "Looking Glass extraction failed"
+        echo "   Try manually: unzip $LG_ZIP -d $OEM_DIR"
+        echo "   Or download from: https://looking-glass.io/downloads"
+        rm -f "$LG_ZIP"
+      fi
+    else
+      msg_warning "Looking Glass download failed (check internet connection)"
+      echo "   Download manually: https://looking-glass.io/downloads"
+      echo "   Save to: $OEM_DIR/looking-glass-host-setup.exe"
+    fi
+  fi
 
-  check_prerequisites
+  SPICE_INSTALLER="$OEM_DIR/spice-guest-tools-setup.exe"
+
+  if [[ ! -f "$SPICE_INSTALLER" ]]; then
+    if ! curl -L --tlsv1.2 --max-time 300 --connect-timeout 30 -o "$SPICE_INSTALLER" "https://www.spice-space.org/download/windows/spice-guest-tools/spice-guest-tools-latest.exe" 2>/dev/null; then
+      msg_warning "SPICE Guest Tools download failed (check internet connection)"
+      echo "   Download manually: https://www.spice-space.org/download/windows/spice-guest-tools/spice-guest-tools-latest.exe"
+      echo "   Save to: $OEM_DIR/spice-guest-tools-setup.exe"
+    fi
+  fi
 
-  omarchy-pkg-add freerdp openbsd-netcat gum
+  # Use previous IVSHMEM size for quick reinstall, otherwise default 64
+  IVSHMEM_SIZE=${IVSHMEM_SIZE:-${PREVIOUS_IVSHMEM_SIZE:-64}}
+
+  # Detect GPU passthrough configuration
+  GPU_PASSTHROUGH_ENABLED=false
+  GPU_PCI_ADDR=""
+  GPU_IOMMU_GROUP=""
+  GPU_IOMMU_DEVICES=""
+
+  if [[ "$LG_ENABLED" == true ]] && command -v omarchy-gpu-passthrough-info &>/dev/null; then
+    if omarchy-gpu-passthrough-info is-configured &>/dev/null; then
+      GPU_PASSTHROUGH_ENABLED=true
+      GPU_CONFIG=$(omarchy-gpu-passthrough-info get-docker-config 2>/dev/null)
+      if [[ -n "$GPU_CONFIG" ]]; then
+        # Format: GPU_PCI_ADDR IOMMU_GROUP DEVICE1 DEVICE2 ...
+        read -r GPU_PCI_ADDR GPU_IOMMU_GROUP GPU_IOMMU_DEVICES <<<"$GPU_CONFIG"
+      fi
+    fi
+  fi
 
-  mkdir -p "$HOME/.windows"
-  mkdir -p "$HOME/.config/windows"
+  # Clean up old state files (for Quick reinstall only, after user confirmation)
+  # Note: docker-compose.yml will be overwritten by create_docker_compose_config, no need to delete
+  if [[ "${QUICK_REINSTALL_CLEANUP:-false}" == "true" ]]; then
+    rm -f "$HOME/Windows/installation-complete.txt" 2>/dev/null
+    rm -f "$HOME/.local/share/applications/windows-vm.desktop" "$HOME/.local/share/applications/windows-looking-glass.desktop" 2>/dev/null
+
+    # Update desktop database after removing old icons (new icons will be created shortly)
+    if command -v update-desktop-database &>/dev/null; then
+      update-desktop-database "$HOME/.local/share/applications" 2>/dev/null || true
+    fi
+  fi
+
+  create_docker_compose_config "$COMPOSE_FILE" "$SELECTED_RAM" "$SELECTED_CORES" "$SELECTED_DISK" \
+    "$USERNAME" "$PASSWORD" "$LG_ENABLED" "$IVSHMEM_SIZE" \
+    "$GPU_PASSTHROUGH_ENABLED" "$GPU_PCI_ADDR" "$GPU_IOMMU_GROUP" "$GPU_IOMMU_DEVICES" \
+    "$TPM_ENABLED"
+
+  msg_success "Configuration saved"
+  echo ""
+  msg_warning "Password stored in plain text in $COMPOSE_FILE"
+
+  # Create desktop entries (must be done AFTER LG_ENABLED is determined)
   mkdir -p "$HOME/.local/share/applications/icons"
 
-  # Install Windows VM icon and desktop file
-  if [ -f "$OMARCHY_PATH/applications/icons/windows.png" ]; then
-    cp "$OMARCHY_PATH/applications/icons/windows.png" "$HOME/.local/share/applications/icons/windows.png"
+  # Install Windows VM icon
+  ICON_SOURCE="$SCRIPT_DIR/../applications/icons/windows.png"
+  if [[ -f "$ICON_SOURCE" ]]; then
+    cp "$ICON_SOURCE" "$HOME/.local/share/applications/icons/windows.png"
+  else
+    msg_warning "Windows icon not found at: $ICON_SOURCE"
+    msg_info "Desktop entries will use default icon"
   fi
 
-  cat << EOF | tee "$HOME/.local/share/applications/windows-vm.desktop" > /dev/null
+  # Create Windows (RDP) desktop entry
+  cat <<EOF >"$HOME/.local/share/applications/windows-vm.desktop"
 [Desktop Entry]
 Name=Windows
 Comment=Start Windows VM via Docker and connect with RDP
-Exec=uwsm app -- omarchy-windows-vm launch
+Exec=uwsm-app -- omarchy-windows-vm launch --keep-alive
 Icon=$HOME/.local/share/applications/icons/windows.png
 Terminal=false
 Type=Application
 Categories=System;Virtualization;
 EOF
 
-  # Get system resources
-  TOTAL_RAM=$(free -h | awk 'NR==2 {print $2}')
-  TOTAL_RAM_GB=$(awk 'NR==1 {printf "%d", $2/1024/1024}' /proc/meminfo)
-  TOTAL_CORES=$(nproc)
+  # Create Windows [Looking Glass] desktop entry if enabled
+  if [[ "$LG_ENABLED" == true ]]; then
+    cat <<EOF >"$HOME/.local/share/applications/windows-looking-glass.desktop"
+[Desktop Entry]
+Name=Windows [Looking Glass]
+Comment=Connect to Windows VM via Looking Glass
+Exec=uwsm-app -- omarchy-windows-vm launch --lg --keep-alive --windowed
+Icon=$HOME/.local/share/applications/icons/windows.png
+Terminal=false
+Type=Application
+Categories=System;Virtualization;
+EOF
+  fi
 
-  echo ""
-  echo "System Resources Detected:"
-  echo "  Total RAM: $TOTAL_RAM"
-  echo "  Total CPU Cores: $TOTAL_CORES"
-  echo ""
+  # Set proper permissions for desktop files
+  chmod 644 "$HOME/.local/share/applications/windows-vm.desktop" 2>/dev/null
+  [[ -f "$HOME/.local/share/applications/windows-looking-glass.desktop" ]] &&
+    chmod 644 "$HOME/.local/share/applications/windows-looking-glass.desktop" 2>/dev/null
 
-  RAM_OPTIONS=""
-  for size in 2 4 8 16 32 64; do
-    if [ $size -le $TOTAL_RAM_GB ]; then
-      RAM_OPTIONS="$RAM_OPTIONS ${size}G"
+  # Update desktop database to make icons appear in application menu
+  if command -v update-desktop-database &>/dev/null; then
+    update-desktop-database "$HOME/.local/share/applications" 2>/dev/null || true
+  fi
+
+  # Bind GPU to VFIO before starting Docker (if GPU passthrough enabled)
+  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]]; then
+    if ! command -v omarchy-gpu-passthrough &>/dev/null; then
+      msg_error "omarchy-gpu-passthrough not found"
+      exit 1
     fi
-  done
 
-  SELECTED_RAM=$(echo $RAM_OPTIONS | tr ' ' '\n' | gum choose --selected="4G" --header="How much RAM would you like to allocate to Windows VM?")
+    # Check current GPU driver and bind if needed
+    CURRENT_DRIVER=$(lspci -k -s "$GPU_PCI_ADDR" 2>/dev/null | grep "Kernel driver in use" | awk '{print $5}')
+    if [[ "$CURRENT_DRIVER" != "vfio-pci" ]]; then
+      # omarchy-gpu-passthrough mode vm prints its own status messages
+      if ! omarchy-gpu-passthrough mode vm 2>&1; then
+        msg_error "Failed to bind GPU to VFIO"
+        exit 1
+      fi
+    fi
+  fi
 
-  # Check if user cancelled
-  if [ -z "$SELECTED_RAM" ]; then
-    echo "Installation cancelled by user"
-    exit 1
+  # Ensure Docker image has SPICE support (required for Looking Glass)
+  if [[ "$LG_ENABLED" == true ]]; then
+    if ! ensure_dockurr_windows_with_spice; then
+      msg_error "Failed to prepare Docker image with SPICE support"
+      echo "   Looking Glass requires SPICE for keyboard/mouse input"
+      exit 1
+    fi
   fi
 
-  SELECTED_CORES=$(gum input --placeholder="Number of CPU cores (1-$TOTAL_CORES)" --value="2" --header="How many CPU cores would you like to allocate to Windows VM?" --char-limit=2)
+  # Start or restart docker-compose with user's config
+  msg_info "Starting Windows VM..."
 
-  # Check if user cancelled (Ctrl+C in gum input returns empty string)
-  if [ -z "$SELECTED_CORES" ]; then
-    echo "Installation cancelled by user"
+  # Verify Looking Glass device exists before starting VM
+  if [[ "$LG_ENABLED" == true ]] && [[ ! -e /dev/kvmfr0 ]]; then
+    msg_error "/dev/kvmfr0 not found"
+    echo "   Looking Glass kernel module is not loaded."
+    echo "   Run: omarchy-looking-glass-launch (shows diagnostics)"
+    echo "   Or reinstall: omarchy-looking-glass-install"
     exit 1
   fi
 
-  if ! [[ "$SELECTED_CORES" =~ ^[0-9]+$ ]] || [ "$SELECTED_CORES" -lt 1 ] || [ "$SELECTED_CORES" -gt "$TOTAL_CORES" ]; then
-    echo "Invalid input. Using default: 2 cores"
-    SELECTED_CORES=2
+  # Start container (suppress verbose Docker output)
+  if ! docker-compose -f "$COMPOSE_FILE" up -d >/dev/null 2>&1; then
+    msg_error "Failed to start VM"
+    echo "  Check logs: docker logs omarchy-windows"
+    exit 1
   fi
 
-  AVAILABLE_SPACE=$(df "$HOME" | awk 'NR==2 {print int($4/1024/1024)}')
-  MAX_DISK_GB=$((AVAILABLE_SPACE - 10))  # Leave 10GB for Windows image
+  # Verify container is running (docker-compose up returns 0 even if QEMU crashes)
+  CONTAINER_RUNNING=false
+  for ((i = 0; i < 10; i++)); do
+    CONTAINER_STATUS=$(docker ps -a --filter "name=omarchy-windows" --format "{{.Status}}" 2>/dev/null)
+
+    if [[ "$CONTAINER_STATUS" =~ ^Up ]]; then
+      CONTAINER_RUNNING=true
+      break
+    elif [[ "$CONTAINER_STATUS" =~ ^Exited ]]; then
+      msg_error "VM crashed on startup"
+      echo "  Check logs: docker logs omarchy-windows"
+      exit 1
+    fi
 
-  # Check if we have enough space for minimum
-  if [ $MAX_DISK_GB -lt 32 ]; then
-    echo "❌ Insufficient disk space for Windows VM!"
-    echo "   Available: ${AVAILABLE_SPACE}GB"
-    echo "   Minimum required: 42GB (32GB disk + 10GB for Windows image)"
+    sleep 3
+  done
+
+  if [[ "$CONTAINER_RUNNING" != true ]]; then
+    msg_error "VM failed to start within 30s"
+    echo "  Check logs: docker logs omarchy-windows"
     exit 1
   fi
 
-  DISK_OPTIONS=""
-  for size in 32 64 128 256 512; do
-    if [ $size -le $MAX_DISK_GB ]; then
-      DISK_OPTIONS="$DISK_OPTIONS ${size}G"
+  msg_success "Docker container started"
+
+  # Verify QEMU is running (noVNC on 8006 indicates QEMU is alive)
+  echo "  Verifying VM startup..."
+  QEMU_CHECK=0
+  while [[ "$QEMU_CHECK" -lt 15 ]]; do
+    if nc -z 127.0.0.1 8006 2>/dev/null; then
+      break
     fi
+    sleep 2
+    QEMU_CHECK=$((QEMU_CHECK + 2))
   done
 
-  # Default to 64G if available, otherwise 32G
-  DEFAULT_DISK="64G"
-  if ! echo "$DISK_OPTIONS" | grep -q "64G"; then
-    DEFAULT_DISK="32G"
+  if ! nc -z 127.0.0.1 8006 2>/dev/null; then
+    msg_error "VM failed to start (QEMU not responding)"
+    echo "  Check logs: docker logs omarchy-windows"
+    exit 1
   fi
 
-  SELECTED_DISK=$(echo $DISK_OPTIONS | tr ' ' '\n' | gum choose --selected="$DEFAULT_DISK" --header="How much disk space would you like to give Windows VM? (64GB+ recommended)")
+  # Check if this is quick reinstall with VM already booted and RDP ready
+  if [[ "${SKIP_OEM_AUTORUN:-false}" == "true" ]] && nc -z 127.0.0.1 3389 2>/dev/null; then
+    msg_success "Windows is ready (RDP service responding)"
+
+    # Auto-launch RDP or Looking Glass
+    if [[ "$LG_ENABLED" == true ]]; then
+      echo "Launching Looking Glass..."
+      echo "   Toggle fullscreen: $(get_escape_key_display)"
+      sleep 1
+      launch_windows --lg
+    else
+      echo "Launching RDP connection..."
+      echo "   Toggle fullscreen: Super + F"
+      sleep 1
+      # Extract credentials
+      WIN_USER=$(grep -E '^\s*USERNAME:' "$COMPOSE_FILE" | head -1 | sed -E 's/^[^:]*:[[:space:]]*"?([^"]*)"?[[:space:]]*$/\1/' | xargs)
+      WIN_PASS=$(grep -E '^\s*PASSWORD:' "$COMPOSE_FILE" | head -1 | sed -E 's/^[^:]*:[[:space:]]*"?([^"]*)"?[[:space:]]*$/\1/' | xargs)
+      connect_rdp "$WIN_USER" "$WIN_PASS" true
+    fi
+    return 0
+  fi
 
-  # Check if user cancelled
-  if [ -z "$SELECTED_DISK" ]; then
-    echo "Installation cancelled by user"
-    exit 1
+  # Auto-fix Looking Glass config if using old SPICE socket path
+  if [[ "$LG_ENABLED" == true ]]; then
+    LG_CONFIG="$HOME/.config/looking-glass/client.ini"
+    if [[ -f "$LG_CONFIG" ]] && grep -q "host=/tmp/spice/spice.sock" "$LG_CONFIG" 2>/dev/null; then
+      sed -i 's|host=/tmp/spice/spice.sock|host=/var/run/omarchy-windows/spice.sock|g' "$LG_CONFIG"
+    fi
   fi
 
-  # Extract just the number for prerequisite check
-  DISK_SIZE_NUM=$(echo "$SELECTED_DISK" | sed 's/G//')
+  # Open VNC in browser for monitoring
+  echo ""
+  echo "Monitor progress: http://127.0.0.1:8006"
+  sleep 1
+  xdg-open "http://127.0.0.1:8006" &>/dev/null &
+  echo ""
 
-  # Re-check prerequisites with selected disk size
-  check_prerequisites "$DISK_SIZE_NUM"
+  [[ "${SKIP_OEM_AUTORUN:-false}" == "false" ]] &&
+    monitor_installation_progress "$USERNAME" "$PASSWORD" "true" "$LG_ENABLED" ||
+    monitor_installation_progress "$USERNAME" "$PASSWORD" "false" "$LG_ENABLED"
 
-  # Prompt for username and password
-  USERNAME=$(gum input --placeholder="Username (Press enter to use default: docker)" --header="Enter Windows username:")
-  if [ -z "$USERNAME" ]; then
-    USERNAME="docker"
-  fi
-
-  PASSWORD=$(gum input --placeholder="Password (Press enter to use default: admin)" --password --header="Enter Windows password:")
-  if [ -z "$PASSWORD" ]; then
-    PASSWORD="admin"
-    PASSWORD_DISPLAY="(default)"
-  else
-    PASSWORD_DISPLAY="(user-defined)"
-  fi
-
-  # Display configuration summary
-  gum style \
-    --border normal \
-    --padding "1 2" \
-    --margin "1" \
-    --align left \
-    --bold \
-    "Windows VM Configuration" \
-    "" \
-    "RAM:       $SELECTED_RAM" \
-    "CPU:       $SELECTED_CORES cores" \
-    "Disk:      $SELECTED_DISK" \
-    "Username:  $USERNAME" \
-    "Password:  $PASSWORD_DISPLAY"
-
-  # Ask for confirmation
+  if [[ "$NEEDS_REBOOT_FOR_LG" == true ]]; then
+    if [[ "$LG_REBOOT_REASON" == "kvm group membership" ]]; then
+      msg_warning "Re-login required for Looking Glass (kvm group)"
+    else
+      msg_warning "Reboot required for Looking Glass ($LG_REBOOT_REASON)"
+    fi
+  fi
+}
+
+remove_windows() {
+  echo "Removing Windows VM configuration..."
   echo ""
-  if ! gum confirm "Proceed with this configuration?"; then
-    echo "Installation cancelled by user"
-    exit 1
+  echo "This will remove Docker container and config files."
+  echo "VM disk and your data will be preserved."
+  echo ""
+
+  if ! gum confirm "Remove VM configuration only (keep VM disk)?"; then
+    echo "Cancelled"
+    return 0
   fi
 
-  mkdir -p $HOME/Windows
+  # Stop and remove container
+  echo "• Stopping container..."
+  docker-compose -f "$COMPOSE_FILE" down 2>/dev/null || true
 
-  # Create docker-compose.yml in user config directory
-  cat << EOF | tee "$COMPOSE_FILE" > /dev/null
-services:
-  windows:
-    image: dockurr/windows
-    container_name: omarchy-windows
-    environment:
-      VERSION: "11"
-      RAM_SIZE: "$SELECTED_RAM"
-      CPU_CORES: "$SELECTED_CORES"
-      DISK_SIZE: "$SELECTED_DISK"
-      USERNAME: "$USERNAME"
-      PASSWORD: "$PASSWORD"
-    devices:
-      - /dev/kvm
-      - /dev/net/tun
-    cap_add:
-      - NET_ADMIN
-    ports:
-      - 8006:8006
-      - 3389:3389/tcp
-      - 3389:3389/udp
-    volumes:
-      - $HOME/.windows:/storage
-      - $HOME/Windows:/shared
-    restart: always
-    stop_grace_period: 2m
-EOF
+  # Remove Docker image
+  echo "• Removing Docker image..."
+  if docker rmi dockurr/windows >/dev/null 2>&1; then
+    msg_success "Docker image removed"
+  else
+    msg_info "Image already removed"
+  fi
 
-  echo ""
-  echo "Starting Windows VM installation..."
-  echo "This will download a Windows 11 image (may take 10-15 minutes)."
-  echo ""
-  echo "Monitor installation progress at: http://127.0.0.1:8006"
-  echo ""
+  # Remove desktop files and shortcuts
+  echo "• Removing desktop shortcuts..."
+  rm -f "$HOME/.local/share/applications/windows-vm.desktop"
+  rm -f "$HOME/.local/share/applications/windows-looking-glass.desktop"
 
-  # Start docker-compose with user's config
-  echo "Starting Windows VM with docker-compose..."
-  if ! docker-compose -f "$COMPOSE_FILE" up -d 2>&1; then
-    echo "❌ Failed to start Windows VM!"
-    echo "   Common issues:"
-    echo "   - Docker daemon not running: sudo systemctl start docker"
-    echo "   - Port already in use: check if another VM is running"
-    echo "   - Permission issues: make sure you're in the docker group"
-    exit 1
+  # Update desktop database to remove icons from application menu
+  if command -v update-desktop-database &>/dev/null; then
+    update-desktop-database "$HOME/.local/share/applications" 2>/dev/null || true
   fi
 
-  echo ""
-  echo "Windows VM is starting up!"
-  echo ""
-  echo "Opening browser to monitor installation..."
+  # Remove installation log files (not user data)
+  echo "• Removing installation logs..."
+  rm -f "$HOME/Windows/install-log.txt"
+  rm -f "$HOME/Windows/installation-complete.txt"
 
-  # Open browser to monitor installation
-  sleep 3
-  xdg-open "http://127.0.0.1:8006"
+  # Remove configuration (but keep data)
+  echo "• Removing configuration..."
+  rm -rf "$HOME/.config/windows"
 
   echo ""
-  echo "Installation is running in the background."
-  echo "You can monitor progress at: http://127.0.0.1:8006"
-  echo ""
-  echo "Once finished, launch 'Windows' via Super + Space"
+  msg_success "Windows VM configuration removed!"
   echo ""
-  echo "To stop the VM: omarchy-windows-vm stop"
-  echo "To change resources: ~/.config/windows/docker-compose.yml"
+  echo "Preserved:"
+  echo "  ✓  VM disk: $HOME/.windows/ (reusable for quick reinstall)"
+  echo "  ✓  Shared files: $HOME/Windows/ (your data)"
   echo ""
+  echo "To completely remove all data:"
+  echo "   sudo rm -rf $HOME/.windows/      # Delete VM disk and Windows OS"
 }
 
-remove_windows() {
-  echo "Removing Windows VM..."
+check_passwordless_configuration() {
+  # Check if system is configured for passwordless VM operations
+  # Returns: 0 if OK, 1 if missing configuration
 
-  docker-compose -f "$COMPOSE_FILE" down 2>/dev/null || true
+  local issues_found=false
+  local issue_list=""
 
-  docker rmi dockurr/windows 2>/dev/null || echo "Image already removed or not found"
+  if [[ ! -f /etc/tmpfiles.d/omarchy-windows.conf ]]; then
+    issues_found=true
+    issue_list="${issue_list}  ❌ Missing: /etc/tmpfiles.d/omarchy-windows.conf\n"
+  elif [[ ! -d /var/run/omarchy-windows ]]; then
+    issues_found=true
+    issue_list="${issue_list}  ❌ SPICE directory not created by tmpfiles.d\n"
+  fi
 
-  rm "$HOME/.local/share/applications/windows-vm.desktop"
-  rm -rf "$HOME/.config/windows"
-  rm -rf "$HOME/.windows"
+  if ! sudo -n /usr/bin/mkdir -p /var/run/omarchy-windows 2>/dev/null; then
+    issues_found=true
+    if [[ ! -f /etc/sudoers.d/omarchy-looking-glass ]]; then
+      issue_list="${issue_list}  ❌ Missing: /etc/sudoers.d/omarchy-looking-glass\n"
+    else
+      issue_list="${issue_list}  ❌ Sudoers rules not working (run: omarchy-looking-glass-install)\n"
+    fi
+  fi
 
-  echo ""
-  echo "Windows VM removal completed!"
-}
+  if [[ "$issues_found" == false ]]; then
+    return 0
+  fi
 
-wait_for_rdp_ready() {
-  local WIN_USER="$1"
-  local WIN_PASS="$2"
-  local TIMEOUT=240
-  local SECONDS=0
+  echo ""
+  msg_warning "System configuration incomplete for desktop launcher:"
+  echo ""
+  echo -e "$issue_list"
+  echo ""
+  echo "Desktop launcher may not work (requires terminal for password prompt)."
+  echo ""
+  echo "Fix: omarchy-looking-glass-install"
+  echo ""
 
-  echo "Waiting for Windows VM to be ready..."
+  # If running from desktop (no TTY), fail immediately
+  if [[ ! -t 0 ]]; then
+    msg_error "Cannot continue: No terminal available for password prompts"
+    echo ""
+    echo "Run from terminal: omarchy-windows-vm launch --lg"
+    echo "Or fix configuration: omarchy-looking-glass-install"
+    notify_silent "Windows VM" "Configuration error - check terminal" "critical"
+    exit 1
+  fi
 
-  while ! timeout 5s xfreerdp3 /auth-only /cert:ignore /u:"$WIN_USER" /p:"$WIN_PASS" /v:127.0.0.1:3389 &>/dev/null; do
-    sleep 2
-    if [ $SECONDS -gt $TIMEOUT ]; then
-      echo "❌ Timeout waiting for RDP!"
-      echo "   The VM might still be installing Windows."
-      echo "   Check progress at: http://127.0.0.1:8006"
-      return 1
+  if command -v gum &>/dev/null; then
+    if ! gum confirm "Continue anyway (you will be prompted for password)?"; then
+      echo "Cancelled"
+      exit 0
     fi
-  done
+  else
+    read -p "Continue anyway? (y/N) " -n 1 -r
+    echo
+    if [[ ! "$REPLY" =~ ^[Yy]$ ]]; then
+      echo "Cancelled"
+      exit 0
+    fi
+  fi
+
+  return 0
 }
 
 launch_windows() {
   KEEP_ALIVE=false
-  if [ "$1" = "--keep-alive" ] || [ "$1" = "-k" ]; then
-    KEEP_ALIVE=true
-  fi
+  USE_LOOKING_GLASS=false
+  USE_WINDOWED=false
+  USER_PROVIDED_PARAMS=false
+
+  # Parse command line arguments
+  while [[ "$#" -gt 0 ]]; do
+    case "$1" in
+    --keep-alive | -k)
+      KEEP_ALIVE=true
+      USER_PROVIDED_PARAMS=true
+      shift
+      ;;
+    --looking-glass | --lg)
+      USE_LOOKING_GLASS=true
+      USER_PROVIDED_PARAMS=true
+      shift
+      ;;
+    --windowed | -w)
+      USE_WINDOWED=true
+      USER_PROVIDED_PARAMS=true
+      shift
+      ;;
+    *)
+      shift
+      ;;
+    esac
+  done
 
-  # Check if config exists
-  if [ ! -f "$COMPOSE_FILE" ]; then
-    echo "Windows VM not configured. Please run: omarchy-windows-vm install"
-    exit 1
+  check_vm_configured
+  check_docker_running
+
+  # Interactive mode if no params provided
+  if [[ "$USER_PROVIDED_PARAMS" == false ]]; then
+    # Check if Looking Glass is available
+    LG_AVAILABLE=false
+    if grep -q "ivshmem-plain" "$COMPOSE_FILE" 2>/dev/null &&
+      command -v looking-glass-client &>/dev/null &&
+      grep -q "vfio-pci" "$COMPOSE_FILE" 2>/dev/null; then
+      LG_AVAILABLE=true
+    fi
+
+    # Combined prompt for connection method and lifecycle
+    if [[ "$LG_AVAILABLE" == true ]]; then
+      echo "Windows VM Launch Options:"
+      echo ""
+      echo "Connection method:"
+      echo "  • Looking Glass: Ultra-low latency (GPU passthrough)"
+      echo "  • RDP: Standard remote desktop"
+      echo ""
+      echo "VM lifecycle:"
+      echo "  • Auto-stop: VM stops when you disconnect"
+      echo "  • Keep-alive: VM keeps running in background"
+      echo ""
+
+      LAUNCH_CONFIG=$(gum choose --selected="Looking Glass + Auto-stop" \
+        "Looking Glass + Auto-stop" \
+        "Looking Glass + Keep-alive" \
+        "RDP + Auto-stop" \
+        "RDP + Keep-alive")
+
+      # Parse combined choice
+      if [[ "$LAUNCH_CONFIG" == "Looking Glass"* ]]; then
+        USE_LOOKING_GLASS=true
+      fi
+
+      if [[ "$LAUNCH_CONFIG" == *"Keep-alive"* ]]; then
+        KEEP_ALIVE=true
+      fi
+    else
+      # LG not available, only offer RDP options
+      echo "Windows VM Launch Options:"
+      echo ""
+      echo "Connection: RDP (standard remote desktop)"
+      echo "  (Looking Glass not configured)"
+      echo ""
+      echo "VM lifecycle:"
+      echo "  • Auto-stop: VM stops when you disconnect"
+      echo "  • Keep-alive: VM keeps running in background"
+
+      LAUNCH_CONFIG=$(gum choose --selected="RDP + Auto-stop" \
+        "RDP + Auto-stop" \
+        "RDP + Keep-alive")
+
+      if [[ "$LAUNCH_CONFIG" == *"Keep-alive"* ]]; then
+        KEEP_ALIVE=true
+      fi
+    fi
   fi
 
-  # Extract credentials from compose file
-  WIN_USER=$(grep "USERNAME:" "$COMPOSE_FILE" | sed 's/.*USERNAME: "\(.*\)"/\1/')
-  WIN_PASS=$(grep "PASSWORD:" "$COMPOSE_FILE" | sed 's/.*PASSWORD: "\(.*\)"/\1/')
+  [[ "$USE_LOOKING_GLASS" == true ]] && check_passwordless_configuration
 
-  # Use defaults if not found
-  [ -z "$WIN_USER" ] && WIN_USER="docker"
-  [ -z "$WIN_PASS" ] && WIN_PASS="admin"
+  CONTAINER_STATUS=$(get_container_status)
 
-  # Check if container is already running
-  CONTAINER_STATUS=$(docker inspect --format='{{.State.Status}}' omarchy-windows 2>/dev/null)
+  WAS_ALREADY_RUNNING=false
+  if [[ "$CONTAINER_STATUS" == "running" ]]; then
+    WAS_ALREADY_RUNNING=true
+  fi
 
-  if [ "$CONTAINER_STATUS" != "running" ]; then
+  if [[ "$CONTAINER_STATUS" != "running" ]]; then
     echo "Starting Windows VM..."
 
+    # Check if GPU passthrough is configured in docker-compose.yml
+    if grep -q "vfio-pci" "$COMPOSE_FILE" 2>/dev/null; then
+      echo "  Detected GPU passthrough configuration"
+
+      # Check GPU health before attempting to start VM (IOTLB errors require cold boot)
+      if command -v omarchy-gpu-passthrough-info &>/dev/null; then
+        if omarchy-gpu-passthrough-info gpu-health &>/dev/null; then
+          echo ""
+          msg_error "GPU Health: IOTLB_INV_TIMEOUT detected"
+          echo ""
+          echo "The GPU cannot be used for passthrough in this state."
+          echo "This happens when AMD GPUs with 'reset bug' are reset too many times."
+          echo ""
+          echo "Solution: Cold boot"
+          echo ""
+          echo "  1. sudo poweroff"
+          echo "  2. Unplug power for 30 seconds"
+          echo "  3. Power on"
+          echo ""
+          echo "Details: omarchy-gpu-passthrough-info health"
+          exit 1
+        fi
+      fi
+
+      # Load GPU configuration and auto-bind if needed
+      if command -v omarchy-gpu-passthrough-info &>/dev/null; then
+        if omarchy-gpu-passthrough-info is-configured &>/dev/null; then
+          # Check if GPU is already bound to VFIO
+          GPU_CONFIG=$(omarchy-gpu-passthrough-info get-docker-config 2>/dev/null)
+          if [[ -n "$GPU_CONFIG" ]]; then
+            # Format: GPU_PCI_ADDR IOMMU_GROUP DEVICE1 DEVICE2 ...
+            read -r GPU_PCI_ADDR _IOMMU_GROUP _REST <<<"$GPU_CONFIG"
+
+            # Validate PCI address format (security check)
+            if [[ ! "$GPU_PCI_ADDR" =~ ^([0-9a-fA-F]{4}:)?[0-9a-fA-F]{2}:[0-9a-fA-F]{2}\.[0-7]$ ]]; then
+              msg_warning "Invalid PCI address format: $GPU_PCI_ADDR"
+            else
+              # Check current driver binding
+              CURRENT_DRIVER=$(lspci -k -s "$GPU_PCI_ADDR" 2>/dev/null | grep "Kernel driver in use" | awk '{print $5}')
+
+              if [[ "$CURRENT_DRIVER" != "vfio-pci" ]]; then
+                echo "  GPU not bound to VFIO, binding now..."
+                if command -v omarchy-gpu-passthrough &>/dev/null; then
+                  if omarchy-gpu-passthrough mode vm 2>&1; then
+                    msg_success "GPU switched to VM mode successfully"
+                  else
+                    msg_warning "GPU mode switch may have failed, check with: omarchy-gpu-passthrough mode"
+                  fi
+                fi
+              else
+                msg_success "GPU already bound to VFIO"
+              fi
+            fi
+          fi
+        fi
+      fi
+    fi
+
     # Send desktop notification
-    notify-send "    Starting Windows VM" "      This can take 15-30 seconds" -t 15000
+    notify_silent "Windows VM" "Starting... (15-30 seconds)" "normal"
+
+    # Verify Looking Glass device exists before starting VM
+    if grep -q "ivshmem-plain" "$COMPOSE_FILE" 2>/dev/null; then
+      if [[ ! -e /dev/kvmfr0 ]]; then
+        echo ""
+        msg_error "Looking Glass device /dev/kvmfr0 not found!"
+        echo "   Run: omarchy-looking-glass-launch (shows diagnostics)"
+        echo "   Or reinstall: omarchy-looking-glass-install"
+        echo ""
+        notify_silent "Windows VM" "Looking Glass device not found" "critical"
+        exit 1
+      fi
+    fi
+
+    if ! docker-compose -f "$COMPOSE_FILE" up -d >/dev/null 2>&1; then
+      msg_error "Failed to start VM"
+      echo "  Check logs: docker logs omarchy-windows"
+      notify_silent "Windows VM" "VM failed to start" "critical"
+      exit 1
+    fi
 
-    if ! docker-compose -f "$COMPOSE_FILE" up -d 2>&1; then
-      echo "❌ Failed to start Windows VM!"
-      echo "   Try checking: omarchy-windows-vm status"
-      echo "   View logs: docker logs omarchy-windows"
-      notify-send -u critical "Windows VM" "Failed to start Windows VM"
+    # Verify container is running (docker-compose up returns 0 even if QEMU crashes)
+    CONTAINER_RUNNING=false
+    for ((i = 0; i < 10; i++)); do
+      CONTAINER_STATUS=$(docker ps -a --filter "name=omarchy-windows" --format "{{.Status}}" 2>/dev/null)
+
+      if [[ "$CONTAINER_STATUS" =~ ^Up ]]; then
+        CONTAINER_RUNNING=true
+        break
+      elif [[ "$CONTAINER_STATUS" =~ ^Exited ]]; then
+        msg_error "VM crashed on startup"
+        echo "  Check logs: docker logs omarchy-windows"
+        notify_silent "Windows VM" "VM crashed" "critical"
+        exit 1
+      fi
+
+      sleep 3
+    done
+
+    if [[ "$CONTAINER_RUNNING" != true ]]; then
+      msg_error "VM failed to start within 30s"
+      echo "  Check logs: docker logs omarchy-windows"
+      notify_silent "Windows VM" "VM startup timeout" "critical"
       exit 1
     fi
+
+    # Wait for SPICE socket if GPU passthrough is enabled
+    if grep -q "vfio-pci" "$COMPOSE_FILE" 2>/dev/null; then
+      echo "  Waiting for SPICE socket..."
+      SPICE_WAIT=0
+      while [[ "$SPICE_WAIT" -lt 30 ]]; do
+        # Check socket and fix permissions if needed
+        if sudo -n test -S "$SPICE_SOCKET_PATH" 2>/dev/null; then
+          msg_success "SPICE socket created"
+          sudo -n chmod 660 "$SPICE_SOCKET_PATH" 2>/dev/null || true
+          sudo -n chgrp kvm "$SPICE_SOCKET_PATH" 2>/dev/null || true
+          break
+        fi
+        sleep 1
+        SPICE_WAIT=$((SPICE_WAIT + 1))
+      done
+
+      if [[ "$SPICE_WAIT" -ge 30 ]]; then
+        msg_warning "SPICE socket not created within 30s"
+        echo "  Looking Glass input may not work properly"
+      fi
+    fi
+  fi
+
+  # Fix SPICE socket permissions if GPU passthrough is enabled (even if container already running)
+  if grep -q "vfio-pci" "$COMPOSE_FILE" 2>/dev/null; then
+    # Check socket and fix permissions if needed
+    if sudo -n test -S "$SPICE_SOCKET_PATH" 2>/dev/null && [[ ! -r "$SPICE_SOCKET_PATH" ]]; then
+      sudo -n chmod 660 "$SPICE_SOCKET_PATH" 2>/dev/null || true
+      sudo -n chgrp kvm "$SPICE_SOCKET_PATH" 2>/dev/null || true
+    fi
   fi
 
-  if ! wait_for_rdp_ready "$WIN_USER" "$WIN_PASS"; then
-    notify-send -u critical "Windows VM" "Did not come alive in time."
+  # Verify QEMU is running before waiting for RDP (noVNC on 8006 indicates QEMU is alive)
+  echo "  Verifying VM startup..."
+  QEMU_CHECK=0
+  while [[ "$QEMU_CHECK" -lt 15 ]]; do
+    if nc -z 127.0.0.1 8006 2>/dev/null; then
+      break
+    fi
+    sleep 2
+    QEMU_CHECK=$((QEMU_CHECK + 2))
+  done
+
+  if ! nc -z 127.0.0.1 8006 2>/dev/null; then
+    msg_error "VM failed to start (QEMU not responding)"
+    echo "  Check logs: docker logs omarchy-windows"
+    notify_silent "Windows VM" "QEMU failed" "critical"
     exit 1
   fi
 
-  # Build the connection info
-  if [ "$KEEP_ALIVE" = true ]; then
-    LIFECYCLE="VM will keep running after RDP closes
-To stop: omarchy-windows-vm stop"
-  else
-    LIFECYCLE="VM will auto-stop when RDP closes"
+  # Wait for RDP port to open (Windows may still be booting or installing)
+  if ! nc -z 127.0.0.1 3389 2>/dev/null; then
+    echo "Waiting for Windows VM to be ready..."
+    WAIT_START=$(date +%s)
+    WAIT_COUNT=0
+    while ! nc -z 127.0.0.1 3389 2>/dev/null; do
+      sleep 5
+      WAIT_COUNT=$((WAIT_COUNT + 1))
+
+      # Check if container is still running
+      if [[ "$(get_container_status)" != "running" ]]; then
+        echo ""
+        msg_error "VM crashed while waiting for Windows to boot"
+        echo ""
+        echo "   Check logs: docker logs omarchy-windows"
+        echo ""
+        warn_if_gpu_iotlb_error
+        exit 1
+      fi
+
+      if [[ "$((WAIT_COUNT % 60))" -eq 0 ]]; then
+        CURRENT_TIME=$(date +%s)
+        TOTAL_ELAPSED=$((CURRENT_TIME - WAIT_START))
+        echo ""
+        msg_warning "Windows is taking longer than expected (${TOTAL_ELAPSED}s elapsed)"
+        echo ""
+        echo "Options:"
+        echo "   1. Keep waiting - VM might still be installing"
+        echo "   2. Check progress at: http://127.0.0.1:8006"
+        echo "   3. View logs: docker logs -f omarchy-windows"
+        echo ""
+        read -p "Continue waiting? (Y/n) " -n 1 -r
+        echo
+        if [[ "$REPLY" =~ ^[Nn]$ ]]; then
+          echo "VM will keep running in background"
+          echo "Connect later: omarchy-windows-vm launch"
+          exit 0
+        fi
+      elif [[ "$((WAIT_COUNT % 6))" -eq 0 ]]; then
+        CURRENT_TIME=$(date +%s)
+        ELAPSED=$((CURRENT_TIME - WAIT_START))
+        echo "Still waiting... (${ELAPSED}s elapsed)"
+        echo "Check progress at: http://127.0.0.1:8006"
+      fi
+    done
+
+    WAIT_END=$(date +%s)
+    WAIT_TIME=$((WAIT_END - WAIT_START))
+    msg_success "RDP port open (took ${WAIT_TIME}s)"
   fi
 
-  gum style \
-    --border normal \
-    --padding "1 2" \
-    --margin "1" \
-    --align center \
-    "Connecting to Windows VM" \
-    "" \
-    "$LIFECYCLE"
+  if [[ "$USE_LOOKING_GLASS" == true ]]; then
+    connect_looking_glass "$KEEP_ALIVE" "$USE_WINDOWED"
 
-  # Detect display scale from Hyprland
-  HYPR_SCALE=$(hyprctl monitors -j | jq -r '.[] | select (.focused == true) | .scale')
-  SCALE_PERCENT=$(echo "$HYPR_SCALE" | awk '{print int($1 * 100)}')
+  else
+    # Extract credentials for RDP connection
+    WIN_USER=$(grep -E '^\s*USERNAME:' "$COMPOSE_FILE" | head -1 | sed -E 's/^[^:]*:[[:space:]]*"?([^"]*)"?[[:space:]]*$/\1/' | xargs)
+    WIN_PASS=$(grep -E '^\s*PASSWORD:' "$COMPOSE_FILE" | head -1 | sed -E 's/^[^:]*:[[:space:]]*"?([^"]*)"?[[:space:]]*$/\1/' | xargs)
+
+    if [[ -z "$WIN_USER" ]] || [[ -z "$WIN_PASS" ]]; then
+      msg_error "Failed to extract credentials from $COMPOSE_FILE"
+      echo "   Configuration file may be corrupted or in unexpected format."
+      echo ""
+      echo "   Try reinstalling: omarchy-windows-vm remove && omarchy-windows-vm install"
+      exit 1
+    fi
 
-  RDP_SCALE=""
-  if [ "$SCALE_PERCENT" -ge 170 ]; then
-    RDP_SCALE="/scale:180"
-  elif [ "$SCALE_PERCENT" -ge 130 ]; then
-    RDP_SCALE="/scale:140"
-  fi
-  # If scale is less than 130%, don't set any scale (use default 100)
+    # Always verify RDP service readiness before connecting
+    # Port being open (nc -z) doesn't mean Windows RDP service is ready -
+    # QEMU may forward the port before Windows finishes booting.
+    MAX_WAIT=90
+    if [[ "$WAS_ALREADY_RUNNING" == false ]]; then
+      echo "Waiting for RDP service to become ready..."
+    else
+      echo "Verifying RDP service..."
+    fi
 
-  # Connect with RDP in fullscreen (auto-detects resolution)
-  xfreerdp3 /u:"$WIN_USER" /p:"$WIN_PASS" /v:127.0.0.1:3389 -grab-keyboard /sound /microphone /cert:ignore /title:"Windows VM - Omarchy" /dynamic-resolution /gfx:AVC444 /floatbar:sticky:off,default:visible,show:fullscreen $RDP_SCALE
+    # Test RDP readiness with X.224 handshake
+    RETRY_INTERVAL=5
+    ELAPSED=0
+    RDP_READY=false
+    CONTAINER_DIED=false
+
+    # Quick first check (don't wait if already ready)
+    if test_rdp_ready; then
+      RDP_READY=true
+    else
+      while [[ "$ELAPSED" -lt "$MAX_WAIT" ]]; do
+        sleep "$RETRY_INTERVAL"
+        ELAPSED=$((ELAPSED + RETRY_INTERVAL))
+
+        # Check if container is still running
+        if [[ "$(get_container_status)" != "running" ]]; then
+          CONTAINER_DIED=true
+          break
+        fi
+
+        if test_rdp_ready; then
+          RDP_READY=true
+          break
+        fi
+        if [[ "$ELAPSED" -lt "$MAX_WAIT" ]]; then
+          echo "  Testing RDP protocol... (${ELAPSED}s elapsed, next check in ${RETRY_INTERVAL}s)"
+        fi
+      done
+    fi
 
-  # After RDP closes, stop the container unless --keep-alive was specified
-  if [ "$KEEP_ALIVE" = false ]; then
     echo ""
-    echo "RDP session closed. Stopping Windows VM..."
-    docker-compose -f "$COMPOSE_FILE" down
-    echo "Windows VM stopped."
-  else
+    if [[ "$CONTAINER_DIED" == true ]]; then
+      msg_error "VM crashed during startup"
+      echo ""
+      echo "   Check logs: docker logs omarchy-windows"
+      echo ""
+      warn_if_gpu_iotlb_error
+      exit 1
+    elif [[ "$RDP_READY" == true ]]; then
+      msg_success "RDP service is ready"
+    else
+      if [[ "$WAS_ALREADY_RUNNING" == false ]]; then
+        msg_warning "RDP service did not respond within ${MAX_WAIT}s"
+        echo "   Proceeding anyway, but connection may fail"
+      else
+        msg_warning "RDP not responding - Windows may be restarting"
+        echo "   Will retry connection..."
+      fi
+    fi
+
+    # Build the connection info
+    if [[ "$KEEP_ALIVE" == true ]]; then
+      LIFECYCLE="VM will keep running after RDP closes
+To stop: omarchy-windows-vm stop"
+    else
+      LIFECYCLE="VM will auto-stop when RDP closes"
+    fi
+
+    gum style \
+      --border normal \
+      --padding "1 2" \
+      --margin "1" \
+      --align center \
+      "Connecting to Windows VM" \
+      "" \
+      "$LIFECYCLE"
+
+    echo "   Toggle fullscreen: Super + F"
+    echo "   Close RDP window: Super + W (or shutdown Windows)"
+    if [[ "$KEEP_ALIVE" == false ]]; then
+      echo "   Ctrl+C            - Close terminal (RDP/VM keep running)"
+    fi
     echo ""
-    echo "RDP session closed. Windows VM is still running."
-    echo "To stop it: omarchy-windows-vm stop"
+    echo "   Manual connect: xfreerdp3 /u:$WIN_USER /p:yourPassword /v:127.0.0.1:3389 -grab-keyboard /sound /microphone /cert:ignore /dynamic-resolution /gfx:AVC444 (requires running VM)"
+
+    # Connect with RDP (foreground mode)
+    connect_rdp "$WIN_USER" "$WIN_PASS" false
+
+    # After RDP closes, stop the container unless --keep-alive was specified
+    if [[ "$KEEP_ALIVE" == false ]]; then
+      echo ""
+      echo "RDP session closed. Stopping Windows VM..."
+      docker-compose -f "$COMPOSE_FILE" stop
+      echo "Windows VM stopped."
+      echo ""
+      msg_info "Container is stopped but preserved for fast restart"
+      echo "   Quick start: omarchy-windows-vm launch"
+      echo "   Full cleanup: omarchy-windows-vm stop (removes container)"
+    else
+      echo ""
+      echo "RDP session closed. Windows VM is still running."
+      echo "To stop it: omarchy-windows-vm stop"
+    fi
   fi
 }
 
 stop_windows() {
-  if [ ! -f "$COMPOSE_FILE" ]; then
-    echo "Windows VM not configured."
-    exit 1
+  check_vm_configured
+
+  # Check if GPU restore will be needed (read once, use multiple times)
+  local gpu_mode=""
+  [[ -r /var/run/omarchy-vm-gpu-mode ]] && gpu_mode=$(<"/var/run/omarchy-vm-gpu-mode") 2>/dev/null
+
+  # Pre-authenticate sudo immediately before docker operations
+  # (GPU restore needs sudo, better to ask upfront than mid-operation)
+  if [[ "$gpu_mode" == "vm" ]]; then
+    sudo -v
   fi
 
-  echo "Stopping Windows VM..."
+  echo "Stopping Windows VM and removing container..."
   docker-compose -f "$COMPOSE_FILE" down
-  echo "Windows VM stopped."
+  echo "Windows VM stopped and container removed."
+  echo "(Container will be recreated fresh on next launch)"
+
+  # Phase 2: Auto-unbind GPU if it was bound for this VM
+  # NOTE: For AMD GPUs with "reset bug" (Vega, Fiji, Navi, etc.), we skip auto-unbind
+  # because these GPUs cannot be reliably rebound after unbind without a system reboot.
+  # The GPU stays in vm mode (vfio-pci) for the next VM session.
+  if [[ "$gpu_mode" == "vm" ]]; then
+    echo ""
+
+    if command -v omarchy-gpu-passthrough &>/dev/null; then
+      # Check if GPU has AMD reset bug (requires reboot to rebind to native driver)
+      # Affected: Vega 10/20, Fiji, Tonga, Hawaii, some Polaris, some Navi 10/14
+      local has_reset_bug=false
+      if command -v omarchy-gpu-passthrough-info &>/dev/null; then
+        if omarchy-gpu-passthrough-info needs-reset 2>/dev/null; then
+          has_reset_bug=true
+        fi
+      fi
+
+      if [[ "$has_reset_bug" == true ]]; then
+        # GPUs with reset bug: keep in vm mode (vfio-pci) for next session
+        msg_info "AMD GPU with reset bug: keeping in VM mode (vfio-pci)"
+        echo "   GPU stays ready for next VM session"
+        echo "   To use on host: reboot system, then: omarchy-gpu-passthrough mode host"
+        notify_silent "Windows VM" "GPU stays in VM mode (reset bug)" "normal"
+      else
+        # GPUs without reset bug: restore to none mode
+        echo "GPU passthrough detected - restoring GPU to host..."
+
+        # Verify GPU mode (marker may be stale after reboot)
+        local actual_mode=""
+        if command -v omarchy-gpu-passthrough-info &>/dev/null; then
+          actual_mode=$(omarchy-gpu-passthrough-info mode 2>/dev/null)
+        fi
+
+        if [[ "$actual_mode" == "vm" ]]; then
+          if omarchy-gpu-passthrough mode none 2>/dev/null; then
+            msg_success "GPU restored to mode=none"
+            notify_silent "Windows VM" "GPU restored to mode=none" "normal"
+          else
+            msg_warning "Failed to restore GPU"
+            echo "   You can manually restore: omarchy-gpu-passthrough mode none"
+            notify_silent "Windows VM" "Failed to restore GPU" "critical"
+          fi
+        else
+          msg_info "GPU already restored (marker was stale, actual mode: ${actual_mode:-none})"
+          # Clean up stale marker
+          sudo -n /usr/bin/rm -f /var/run/omarchy-vm-gpu-mode 2>/dev/null || true
+        fi
+      fi
+    else
+      msg_warning "GPU passthrough tools not found"
+      echo "   GPU may still be bound to vfio-pci"
+      echo "   Manual restore: omarchy-gpu-passthrough mode none"
+    fi
+    echo ""
+  fi
 }
 
-status_windows() {
-  if [ ! -f "$COMPOSE_FILE" ]; then
-    echo "Windows VM not configured."
-    echo "To set up: omarchy-windows-vm install"
+show_compose() {
+  # Check if docker-compose.yml exists
+  if [[ ! -f "$COMPOSE_FILE" ]]; then
+    msg_error "Windows VM not configured"
+    echo "   Run: omarchy-windows-vm install"
     exit 1
   fi
 
-  CONTAINER_STATUS=$(docker inspect --format='{{.State.Status}}' omarchy-windows 2>/dev/null)
+  # Extract configuration from existing docker-compose.yml
+  local SELECTED_RAM=$(grep 'RAM_SIZE:' "$COMPOSE_FILE" | awk '{print $2}' | tr -d '"')
+  local SELECTED_CORES=$(grep 'CPU_CORES:' "$COMPOSE_FILE" | awk '{print $2}' | tr -d '"')
+  local SELECTED_DISK=$(grep 'DISK_SIZE:' "$COMPOSE_FILE" | awk '{print $2}' | tr -d '"')
+  local USERNAME=$(grep 'USERNAME:' "$COMPOSE_FILE" | awk '{print $2}' | tr -d '"')
+  local PASSWORD=$(grep 'PASSWORD:' "$COMPOSE_FILE" | awk '{print $2}' | tr -d '"')
+
+  # Detect Looking Glass (check for kvmfr device)
+  local LG_ENABLED=false
+  if grep -q '/dev/kvmfr0' "$COMPOSE_FILE"; then
+    LG_ENABLED=true
+  fi
+
+  # Detect GPU passthrough (check for vfio devices)
+  local GPU_PASSTHROUGH_ENABLED=false
+  local GPU_PCI_ADDR=""
+  local GPU_IOMMU_GROUP=""
+  local GPU_IOMMU_DEVICES=""
 
-  if [ -z "$CONTAINER_STATUS" ]; then
+  if grep -q 'vfio-pci,host=' "$COMPOSE_FILE"; then
+    GPU_PASSTHROUGH_ENABLED=true
+
+    GPU_IOMMU_DEVICES=$(grep -oP 'vfio-pci,host=0000:\K[0-9a-f:.]+' "$COMPOSE_FILE" | tr '\n' ' ' | sed 's/ $//')
+    GPU_PCI_ADDR=$(echo "$GPU_IOMMU_DEVICES" | awk '{print $1}')
+
+    # Extract all IOMMU groups from devices section
+    # Returns comma-separated list of unique group numbers
+    GPU_IOMMU_GROUP=$(grep -oP '/dev/vfio/\K[0-9]+' "$COMPOSE_FILE" | sort -u | tr '\n' ',' | sed 's/,$//')
+  fi
+
+  # Detect IVSHMEM size (default 64)
+  local IVSHMEM_SIZE=64
+  if grep -q 'size=' "$COMPOSE_FILE"; then
+    IVSHMEM_SIZE=$(grep -oP 'size=\K[0-9]+' "$COMPOSE_FILE" | head -1)
+  fi
+
+  # Detect TPM (check for TPM: "Y")
+  local TPM_ENABLED=false
+  if grep -q 'TPM:.*Y' "$COMPOSE_FILE"; then
+    TPM_ENABLED=true
+  fi
+
+  # Generate docker-compose.yml to stdout
+  create_docker_compose_config "-" "$SELECTED_RAM" "$SELECTED_CORES" "$SELECTED_DISK" \
+    "$USERNAME" "$PASSWORD" "$LG_ENABLED" "$IVSHMEM_SIZE" \
+    "$GPU_PASSTHROUGH_ENABLED" "$GPU_PCI_ADDR" "$GPU_IOMMU_GROUP" "$GPU_IOMMU_DEVICES" \
+    "$TPM_ENABLED"
+}
+
+status_windows() {
+  check_vm_configured
+
+  CONTAINER_STATUS=$(get_container_status)
+
+  if [[ -z "$CONTAINER_STATUS" ]]; then
     echo "Windows VM container not found."
     echo "To start: omarchy-windows-vm launch"
-  elif [ "$CONTAINER_STATUS" = "running" ]; then
+  elif [[ "$CONTAINER_STATUS" == "running" ]]; then
+    # Check if Looking Glass is available
+    LG_STATUS=""
+    if is_looking_glass_ready; then
+      LG_STATUS="Looking Glass: Available"
+    else
+      LG_STATUS="Looking Glass: Not installed"
+    fi
+
     gum style \
       --border normal \
       --padding "1 2" \
@@ -394,9 +3824,11 @@ status_windows() {
       "" \
       "Web interface: http://127.0.0.1:8006" \
       "RDP available: port 3389" \
+      "$LG_STATUS" \
       "" \
-      "To connect: omarchy-windows-vm launch" \
-      "To stop:    omarchy-windows-vm stop"
+      "To connect (RDP):          omarchy-windows-vm launch" \
+      "To connect (Looking Glass): omarchy-windows-vm launch --lg" \
+      "To stop:                   omarchy-windows-vm stop"
   else
     echo "Windows VM is stopped (status: $CONTAINER_STATUS)"
     echo "To start: omarchy-windows-vm launch"
@@ -409,44 +3841,52 @@ show_usage() {
   echo "Commands:"
   echo "  install              Install and configure Windows VM"
   echo "  remove               Remove Windows VM and optionally its data"
-  echo "  launch [options]     Start Windows VM (if needed) and connect via RDP"
+  echo "  launch [options]     Start Windows VM (if needed) and connect (RDP default, --lg for Looking Glass)"
   echo "                       Options:"
-  echo "                         --keep-alive, -k   Keep VM running after RDP closes"
+  echo "                         --keep-alive, -k        Keep VM running after RDP closes"
+  echo "                         --looking-glass, --lg   Connect via Looking Glass"
+  echo "                         --windowed, -w          Start Looking Glass in windowed mode"
   echo "  stop                 Stop the running Windows VM"
   echo "  status               Show current VM status"
+  echo "  show-compose         Display generated docker-compose.yml configuration (for testing/debugging)"
   echo "  help                 Show this help message"
   echo ""
   echo "Examples:"
   echo "  omarchy-windows-vm install           # Set up Windows VM for first time"
   echo "  omarchy-windows-vm launch            # Connect to VM (auto-stop on exit)"
   echo "  omarchy-windows-vm launch -k         # Connect to VM (keep running)"
+  echo "  omarchy-windows-vm show-compose      # View generated config without creating file"
   echo "  omarchy-windows-vm stop              # Shut down the VM"
 }
 
 # Main command dispatcher
 case "$1" in
-  install)
-    install_windows
-    ;;
-  remove)
-    remove_windows
-    ;;
-  launch|start)
-    launch_windows "$2"
-    ;;
-  stop|down)
-    stop_windows
-    ;;
-  status)
-    status_windows
-    ;;
-  help|--help|-h|"")
-    show_usage
-    ;;
-  *)
-    echo "Unknown command: $1" >&2
-    echo "" >&2
-    show_usage >&2
-    exit 1
-    ;;
+install)
+  install_windows
+  ;;
+remove)
+  remove_windows
+  ;;
+launch | start)
+  shift # Remove the command name from arguments
+  launch_windows "$@"
+  ;;
+stop | down)
+  stop_windows
+  ;;
+status)
+  status_windows
+  ;;
+show-compose)
+  show_compose
+  ;;
+help | --help | -h | "")
+  show_usage
+  ;;
+*)
+  echo "Unknown command: $1" >&2
+  echo "" >&2
+  show_usage >&2
+  exit 1
+  ;;
 esac
