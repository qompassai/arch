diff --git a/bin/omarchy-gpu-passthrough b/bin/omarchy-gpu-passthrough
new file mode 100755
index 0000000000..7766951537
--- /dev/null
+++ b/bin/omarchy-gpu-passthrough
@@ -0,0 +1,110 @@
+#!/bin/bash
+#
+# omarchy-gpu-passthrough - GPU Passthrough for VMs
+# Purpose: Main entry point for GPU passthrough tool suite
+#
+
+set -uo pipefail
+
+# Load shared utilities
+SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
+if ! source "$SCRIPT_DIR/omarchy-gpu-passthrough-utils"; then
+  echo "ERROR: Cannot load omarchy-gpu-passthrough-utils" >&2
+  echo "Please ensure omarchy-gpu-passthrough-utils exists in: $SCRIPT_DIR" >&2
+  exit 1
+fi
+
+# Main Help Function
+show_main_help() {
+  cat <<EOF
+GPU Passthrough for Virtual Machines
+
+USAGE:
+  omarchy-gpu-passthrough <command> [options]
+
+COMMANDS:
+  mode [none|vm|host]   Control GPU driver binding
+                        none - No driver (power saving, boot state)
+                        vm   - Bind to vfio-pci (ready for VM passthrough)
+                        host - Bind to native driver (nvidia/amdgpu)
+
+  setup                 Interactive setup wizard (one-time configuration)
+                        Configures kernel parameters, IOMMU, drivers
+
+  info <subcommand>     Information and diagnostics
+    status              Show current system status
+    verify              Verify configuration is correct
+    detect              Check if hardware supports passthrough
+    diagnose            Generate diagnostic report
+
+  help                  Show this help message
+
+GPU MODES:
+  Mode lifecycle: none (boot) → vm (for VM) → host (for host) → none
+
+  none  - GPU blacklisted, no driver loaded (power saving)
+  vm    - GPU bound to vfio-pci driver (ready for VM passthrough)
+  host  - GPU bound to native driver (available for host: CUDA, gaming)
+
+EXAMPLES:
+  omarchy-gpu-passthrough info detect   # Check if hardware compatible
+  omarchy-gpu-passthrough setup         # Run setup wizard (one-time)
+  omarchy-gpu-passthrough mode vm       # Before starting VM
+  omarchy-gpu-passthrough mode host     # After stopping VM (optional)
+  omarchy-gpu-passthrough info status   # Check current state
+
+TROUBLESHOOTING:
+  omarchy-gpu-passthrough info diagnose # Full diagnostic report
+  omarchy-gpu-passthrough info verify   # Verify configuration
+
+BIOS REQUIREMENTS (one-time setup):
+  • Enable CPU Virtualization (AMD-V/SVM or Intel VT-x)
+  • Enable IOMMU (AMD-Vi or Intel VT-d)
+  • Set Primary Display to IGD (integrated graphics)
+  • Connect monitor to MOTHERBOARD ports (not GPU)
+
+  After BIOS changes, run: omarchy-gpu-passthrough setup
+
+QUICK START (typical workflow):
+  1. omarchy-gpu-passthrough info detect   # Verify hardware
+  2. Configure BIOS (see BIOS REQUIREMENTS above)
+  3. omarchy-gpu-passthrough setup         # One-time setup
+  4. reboot                                # Apply kernel parameters
+  5. omarchy-gpu-passthrough mode vm       # Before starting VM
+  6. [start your VM with GPU passthrough]
+  7. omarchy-gpu-passthrough mode host     # After VM (optional)
+
+MORE HELP:
+  omarchy-gpu-passthrough mode --help   # GPU mode operations details
+  omarchy-gpu-passthrough info --help   # Information commands details
+  omarchy-gpu-passthrough setup --help  # Setup wizard details
+EOF
+}
+
+# Main Dispatcher
+case "${1:-}" in
+mode)
+  shift
+  if [[ "${1:-}" == "--help" || "${1:-}" == "-h" || "${1:-}" == "help" ]]; then
+    exec "$SCRIPT_DIR/omarchy-gpu-passthrough-bind" mode --help
+  else
+    exec "$SCRIPT_DIR/omarchy-gpu-passthrough-bind" mode "$@"
+  fi
+  ;;
+setup)
+  shift
+  exec "$SCRIPT_DIR/omarchy-gpu-passthrough-setup" "$@"
+  ;;
+info)
+  shift
+  exec "$SCRIPT_DIR/omarchy-gpu-passthrough-info" "$@"
+  ;;
+-h | --help | help | "")
+  show_main_help
+  ;;
+*)
+  echo "Unknown command: \"$1\""
+  echo "Run 'omarchy-gpu-passthrough --help' for usage information"
+  exit 1
+  ;;
+esac
diff --git a/bin/omarchy-gpu-passthrough-bind b/bin/omarchy-gpu-passthrough-bind
new file mode 100755
index 0000000000..8651a70af4
--- /dev/null
+++ b/bin/omarchy-gpu-passthrough-bind
@@ -0,0 +1,1229 @@
+#!/bin/bash
+#
+# omarchy-gpu-passthrough-bind - Bind/unbind GPU operations
+#
+
+set -uo pipefail
+
+# Load shared utilities
+SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
+if ! source "$SCRIPT_DIR/omarchy-gpu-passthrough-utils"; then
+  echo "ERROR: Cannot load omarchy-gpu-passthrough-utils" >&2
+  echo "Please ensure omarchy-gpu-passthrough-utils exists in: $SCRIPT_DIR" >&2
+  exit 1
+fi
+
+# GPU Binding Functions
+
+# Safety Check: Check for processes using GPU
+# Returns: 0 if safe to proceed, exits with 1 if GPU in use
+check_gpu_processes() {
+  local current_driver="$1"
+
+  if [[ -z "$current_driver" || "$current_driver" == "none" ]]; then
+    return 0
+  fi
+
+  log_info "Checking for processes using GPU..."
+
+  # For AMD/Intel: detect passthrough GPU's DRM card (used throughout function)
+  local drm_card="" card_num="" render_num=""
+  if [[ "$current_driver" == "amdgpu" || "$current_driver" == "i915" ]]; then
+    drm_card=$(get_drm_card_for_pci "$GPU_PCI_ADDR" 2>/dev/null) || drm_card=""
+    if [[ -n "$drm_card" ]]; then
+      card_num="${drm_card#card}"
+      render_num=$((128 + card_num))
+      log_info "Passthrough GPU DRM: /dev/dri/$drm_card, /dev/dri/renderD${render_num}"
+    fi
+  fi
+
+  local gpu_processes=""
+  if [[ "$current_driver" == "nvidia" ]]; then
+    gpu_processes=$(sudo -n /usr/bin/fuser -v /dev/nvidia* 2>/dev/null | grep -v "USER" | tr -d '\n')
+  elif [[ "$current_driver" == "amdgpu" || "$current_driver" == "i915" ]]; then
+    # Only check the passthrough GPU's DRM card, not all cards (hybrid GPU fix)
+    if [[ -n "$drm_card" ]]; then
+      gpu_processes=$(sudo -n /usr/bin/fuser -v "/dev/dri/$drm_card" "/dev/dri/renderD${render_num}" 2>/dev/null | grep -v "USER" | tr -d '\n')
+    else
+      # Fallback if we can't determine specific card
+      gpu_processes=$(sudo -n /usr/bin/fuser -v /dev/dri/* 2>/dev/null | grep -v "USER" | tr -d '\n')
+    fi
+  elif [[ "$current_driver" == "vfio-pci" ]]; then
+    # Check for QEMU/VM processes (fuser on /dev/vfio/* may not work reliably)
+    gpu_processes=$(pgrep -f 'qemu.*vfio' 2>/dev/null | tr '\n' ' ')
+    if [[ -z "$gpu_processes" ]]; then
+      # Fallback: check fuser (no sudoers rule, may prompt)
+      gpu_processes=$(sudo -n /usr/bin/fuser -v /dev/vfio/* 2>/dev/null | grep -v "USER" | tr -d '\n')
+    fi
+  fi
+
+  if [[ -z "$gpu_processes" ]]; then
+    log_info "No processes using GPU"
+    return 0
+  fi
+
+  log_info "Processes detected using GPU, checking if active or idle..."
+
+  if [[ "$current_driver" == "nvidia" ]]; then
+    local gpu_memory_usage=0
+    if command -v nvidia-smi &>/dev/null; then
+      gpu_memory_usage=$(nvidia-smi --query-compute-apps=used_memory --format=csv,noheader,nounits 2>/dev/null | awk '{sum+=$1} END {print sum+0}')
+    fi
+
+    log_info "GPU memory usage: ${gpu_memory_usage}MiB"
+
+    if [[ "$gpu_memory_usage" -le 10 ]]; then
+      msg_info "Closing idle GPU file handles (${gpu_memory_usage}MiB usage)..."
+      log_info "Detected idle file handles, attempting to close (${gpu_memory_usage}MiB usage)"
+      log_info "Sending HUP signal to close idle handles..."
+
+      sudo -n fuser -k -HUP /dev/nvidia* 2>/dev/null || true
+      sleep 1
+
+      gpu_processes=$(sudo -n /usr/bin/fuser -v /dev/nvidia* 2>/dev/null | grep -v "USER" | tr -d '\n')
+
+      if [[ -n "$gpu_processes" ]]; then
+        log_info "Checking if Hyprland is holding handles..."
+
+        local compositor_pids=$(sudo -n /usr/bin/fuser -v /dev/nvidia* 2>&1 | grep -i "Hyprland" | awk '{print $2}' | tr '\n' ' ')
+
+        if [[ -n "$compositor_pids" ]]; then
+          echo ""
+          msg_error "SAFETY: Compositor has NVIDIA handle!"
+          msg_error "Compositor holding NVIDIA device - unbind will crash it (blackscreen)!"
+          echo ""
+          sudo -n /usr/bin/fuser -v /dev/nvidia* 2>&1 | grep -iE "Hyprland|USER" | head -10
+          echo ""
+          msg_warning "Solution: Run from TTY or SSH"
+          echo "   1. Switch to TTY (Ctrl+Alt+F2) or SSH from another machine"
+          echo "   2. Run: omarchy-gpu-passthrough mode vm"
+          echo "   3. Start VM from there"
+          echo ""
+          log_error "Bind aborted: Compositor (${compositor_pids}) holding NVIDIA handle (would crash on unbind)"
+          exit 1
+        fi
+
+        log_info "Handles still present but GPU is idle (${gpu_memory_usage}MiB), proceeding with caution"
+      else
+        log_success "Idle file handles closed successfully"
+      fi
+    else
+      echo ""
+      msg_error "GPU actively in use (${gpu_memory_usage}MiB memory):"
+      GPU_PROCESSES=$(sudo -n /usr/bin/fuser -v /dev/nvidia* 2>&1 | grep -v "USER\|kernel" | head -20)
+      echo "$GPU_PROCESSES"
+      echo ""
+
+      # Offer to kill processes interactively
+      if command -v gum &>/dev/null; then
+        if gum confirm "Kill all GPU processes and continue?"; then
+          # Extract process names and kill
+          PROCESS_NAMES=$(echo "$GPU_PROCESSES" | awk '{print $NF}' | grep -v "^$" | sort -u)
+
+          for proc in $PROCESS_NAMES; do
+            echo "Killing $proc..."
+            sudo -n pkill -9 "$proc" 2>/dev/null || true
+          done
+
+          sleep 2
+
+          # Re-check GPU usage
+          gpu_memory_usage=$(nvidia-smi --query-gpu=memory.used --format=csv,noheader,nounits 2>/dev/null | awk '{print int($1)}')
+          if [[ "$gpu_memory_usage" -lt 10 ]]; then
+            log_success "GPU processes terminated, continuing..."
+          else
+            echo ""
+            msg_error "GPU still in use (${gpu_memory_usage}MiB memory)"
+            log_error "Cannot bind: GPU actively in use after kill attempt"
+            exit 1
+          fi
+        else
+          msg_info "Close GPU apps manually: sudo pkill -9 -f '<name>'"
+          log_error "Cannot bind: GPU actively in use (${gpu_memory_usage}MiB memory used)"
+          exit 1
+        fi
+      else
+        msg_info "Close GPU apps or kill processes: sudo pkill -9 -f '<name>'"
+        log_error "Cannot bind: GPU actively in use (${gpu_memory_usage}MiB memory used)"
+        exit 1
+      fi
+    fi
+  elif [[ "$current_driver" == "vfio-pci" ]]; then
+    echo ""
+    msg_error "GPU in use by VM or VFIO process"
+    echo ""
+    local first_pid=""
+    if [[ -n "$gpu_processes" ]]; then
+      echo "Processes using GPU:"
+      for pid in $gpu_processes; do
+        if ps -p "$pid" &>/dev/null; then
+          [[ -z "$first_pid" ]] && first_pid="$pid"
+          local proc_info=$(ps -p "$pid" -o pid,comm,cmd --no-headers 2>/dev/null)
+          echo "   PID $proc_info"
+        fi
+      done
+      echo ""
+    fi
+
+    msg_warning "GPU is bound to vfio-pci and in use (likely by running VM)"
+    echo "To unbind GPU:"
+    echo "   1. Stop your VM: omarchy-windows-vm stop"
+    if [[ -n "$first_pid" ]]; then
+      echo "   2. Or kill QEMU: sudo kill -9 $first_pid"
+    else
+      echo "   2. Or kill QEMU: sudo pkill -9 qemu-system-x86_64"
+    fi
+    echo "   3. Then retry: omarchy-gpu-passthrough mode host"
+    echo ""
+    log_error "Cannot unbind: GPU in use by VFIO process (VM likely running)"
+    exit 1
+  else
+    echo ""
+    msg_error "GPU in use by processes:"
+    # Use passthrough GPU's DRM card if detected, fallback to all
+    if [[ -n "$drm_card" ]]; then
+      GPU_PROCESSES=$(sudo -n /usr/bin/fuser -v "/dev/dri/$drm_card" "/dev/dri/renderD${render_num}" 2>&1 | grep -v "USER\|kernel" | head -20)
+    else
+      GPU_PROCESSES=$(sudo -n /usr/bin/fuser -v /dev/dri/* 2>&1 | grep -v "USER\|kernel" | head -20)
+    fi
+    echo "$GPU_PROCESSES"
+    echo ""
+
+    # Offer to kill processes interactively
+    if command -v gum &>/dev/null; then
+      if gum confirm "Kill all GPU processes and continue?"; then
+        # Extract process names and kill
+        PROCESS_NAMES=$(echo "$GPU_PROCESSES" | awk '{print $NF}' | grep -v "^$" | sort -u)
+
+        for proc in $PROCESS_NAMES; do
+          echo "Killing $proc..."
+          sudo -n pkill -9 "$proc" 2>/dev/null || true
+        done
+
+        sleep 2
+
+        # Re-check GPU usage (passthrough GPU only)
+        if [[ -n "$drm_card" ]]; then
+          GPU_PROCESSES_AFTER=$(sudo -n /usr/bin/fuser -v "/dev/dri/$drm_card" "/dev/dri/renderD${render_num}" 2>&1 | grep -v "USER\|kernel" || true)
+        else
+          GPU_PROCESSES_AFTER=$(sudo -n /usr/bin/fuser -v /dev/dri/* 2>&1 | grep -v "USER\|kernel" || true)
+        fi
+        if [[ -z "$GPU_PROCESSES_AFTER" ]]; then
+          log_success "GPU processes terminated, continuing..."
+        else
+          echo ""
+          msg_error "GPU still in use by processes"
+          echo "$GPU_PROCESSES_AFTER"
+          log_error "Cannot bind: GPU still in use after kill attempt"
+          exit 1
+        fi
+      else
+        msg_info "Close GPU apps manually: sudo pkill -9 -f '<name>'"
+        log_error "Cannot bind: GPU in use by processes"
+        exit 1
+      fi
+    else
+      msg_info "Close GPU apps or kill processes: sudo pkill -9 -f '<name>'"
+      log_error "Cannot bind: GPU in use by processes"
+      exit 1
+    fi
+  fi
+
+  return 0
+}
+
+# Safety Check: Check if display is connected to dedicated GPU
+# Returns: 0 if safe, exits with 1 if monitor connected
+check_display_safety() {
+  local current_driver="$1"
+
+  if [[ -z "$current_driver" || "$current_driver" == "none" ]]; then
+    return 0
+  fi
+
+  msg_info "Checking display safety..."
+  log_info "Checking if display is using dedicated GPU..."
+
+  if [[ -n "${WAYLAND_DISPLAY:-}" ]] || [[ -n "${XDG_SESSION_TYPE:-}" ]]; then
+    local connected_displays=$(count_connected_monitors_for_pci "$GPU_PCI_ADDR")
+
+    if [[ "$connected_displays" -gt 0 ]]; then
+      local gpu_drm_card=$(get_drm_card_for_pci "$GPU_PCI_ADDR")
+      echo ""
+      msg_error "SAFETY: Monitor connected to dedicated GPU!"
+      msg_error "Detected $connected_displays monitor(s) on ${gpu_drm_card:-GPU} - unbind will cause BLACKSCREEN!"
+      echo ""
+      msg_warning "Solution:"
+      echo "   1. Move monitor cable to iGPU port (motherboard HDMI/DP)"
+      echo "   2. Set BIOS: Primary Display = IGD"
+      echo "   3. Reboot and run: omarchy-gpu-passthrough setup"
+      echo ""
+      log_error "Bind aborted: Monitor connected to dedicated GPU (would cause blackscreen)"
+      exit 1
+    else
+      log_success "Display safety check passed (no monitors on dedicated GPU)"
+    fi
+  fi
+
+  return 0
+}
+
+# Try to reset GPU using SBR (Secondary Bus Reset) or FLR (Function Level Reset)
+# Required for AMD GPUs to properly unbind from vfio-pci
+try_reset_gpu() {
+  local pci_addr="$1"
+  local pci_full
+  pci_full=$(normalize_pci_addr "$pci_addr") || return 1
+
+  local reset_file="/sys/bus/pci/devices/${pci_full}/reset"
+
+  if [[ -w "$reset_file" ]] || sudo -n test -w "$reset_file" 2>/dev/null; then
+    log_info "Attempting GPU reset via sysfs..."
+    if echo 1 | sudo -n tee "$reset_file" >/dev/null 2>&1; then
+      log_success "GPU reset successful"
+      sleep 1
+      return 0
+    else
+      log_warn "GPU reset failed (may not support FLR)"
+    fi
+  else
+    log_info "GPU reset not available (no reset file or permission denied)"
+  fi
+
+  return 1
+}
+
+# Set driver_override to prevent automatic driver binding
+# Critical for AMD GPUs with vfio-pci.ids in kernel cmdline
+set_driver_override() {
+  local pci_addr="$1"
+  local driver="$2"
+  local pci_full
+  pci_full=$(normalize_pci_addr "$pci_addr") || return 1
+
+  local override_file="/sys/bus/pci/devices/${pci_full}/driver_override"
+
+  if [[ -e "$override_file" ]]; then
+    if echo "$driver" | sudo -n tee "$override_file" >/dev/null 2>&1; then
+      log_info "Set driver_override=$driver for $pci_addr"
+      return 0
+    else
+      log_warn "Failed to set driver_override for $pci_addr"
+    fi
+  else
+    log_info "driver_override not available for $pci_addr"
+  fi
+
+  return 1
+}
+
+# Clear driver_override to allow automatic driver binding
+clear_driver_override() {
+  local pci_addr="$1"
+  local pci_full
+  pci_full=$(normalize_pci_addr "$pci_addr") || return 1
+
+  local override_file="/sys/bus/pci/devices/${pci_full}/driver_override"
+
+  if [[ -e "$override_file" ]]; then
+    # Writing empty string clears the override (use -n to avoid trailing newline)
+    if echo -n "" | sudo -n tee "$override_file" >/dev/null 2>&1; then
+      log_info "Cleared driver_override for $pci_addr"
+      return 0
+    else
+      log_warn "Failed to clear driver_override for $pci_addr"
+    fi
+  fi
+
+  return 1
+}
+
+# Clear driver_override for all AMD GPU IOMMU devices
+# Ensures clean state before bind/unbind operations
+clear_amd_driver_overrides() {
+  local iommu_devices="$1"
+  [[ "$GPU_VENDOR_ID" != "1002" ]] && return 0
+
+  for dev_pci in $iommu_devices; do
+    clear_driver_override "$dev_pci"
+  done
+}
+
+# Unload NVIDIA modules in dependency order (drm→modeset→uvm→nvidia)
+unload_nvidia_modules() {
+  msg_info "Unloading NVIDIA modules..."
+  log_info "Unloading NVIDIA modules..."
+
+  for mod in nvidia_drm nvidia_modeset nvidia_uvm nvidia; do
+    if is_module_loaded "$mod"; then
+      if sudo -n /usr/bin/modprobe -r "$mod" 2>/dev/null; then
+        log_info "$mod unloaded"
+      else
+        log_warn "$mod: in use (will retry during unbind)"
+      fi
+    fi
+  done
+
+  return 0
+}
+
+cmd_bind() {
+  log_init
+
+  if ! load_gpu_config; then
+    msg_section "GPU Mode: VM"
+    msg_error "GPU passthrough not configured"
+    msg_info "Run: omarchy-gpu-passthrough setup"
+    log_error "Bind failed: GPU passthrough not configured"
+    exit 1
+  fi
+
+  local gpu_pci_full
+  gpu_pci_full=$(normalize_pci_addr "$GPU_PCI_ADDR") || {
+    msg_error "Invalid GPU PCI address: $GPU_PCI_ADDR"
+    exit 1
+  }
+
+  msg_section "GPU Mode: Switch to VM"
+
+  local current_driver=$(get_pci_driver "$GPU_PCI_ADDR")
+
+  log_info "=== BIND OPERATION START ==="
+  log_info "GPU: $GPU_NAME ($GPU_PCI_ADDR)"
+  log_info "Current driver: ${current_driver:-none}"
+
+  if [[ "$current_driver" == "vfio-pci" ]]; then
+    msg_success "GPU already bound to vfio-pci (ready for VM)"
+    log_info "GPU already bound to vfio-pci (no action needed)"
+
+    # Still check and enable persistent mode for reset-bug GPUs
+    if [[ "$GPU_VENDOR_ID" == "1002" ]] && gpu_has_reset_bug "$GPU_PCI_ADDR"; then
+      if ! is_persistent_vfio_enabled "$GPU_PCI_ADDR" "$GPU_VENDOR_ID" "$GPU_DEVICE_ID"; then
+        echo ""
+        msg_info "AMD GPU with reset bug - enabling persistent VM mode"
+        msg_info "GPU will boot directly to vfio-pci after reboot"
+        if enable_persistent_vfio "$GPU_PCI_ADDR" "$GPU_VENDOR_ID" "$GPU_DEVICE_ID"; then
+          msg_success "Persistent VM mode enabled (effective after reboot)"
+          log_success "Persistent VFIO enabled for reset-bug GPU"
+        else
+          msg_warning "Failed to enable persistent mode"
+          msg_info "GPU may require rebind after each reboot"
+          log_warn "Failed to enable persistent VFIO for reset-bug GPU"
+        fi
+      else
+        log_info "Persistent VFIO already enabled for this GPU"
+      fi
+    fi
+    exit 0
+  fi
+
+  msg_info "Binding GPU to vfio-pci..."
+  log_info "GPU: $GPU_NAME ($GPU_PCI_ADDR), Current: ${current_driver:-none}"
+
+  check_gpu_processes "$current_driver"
+  check_display_safety "$current_driver"
+
+  [[ "$current_driver" == "nvidia" ]] && unload_nvidia_modules
+
+  if [[ -n "$current_driver" && "$current_driver" != "none" ]]; then
+    log_info "Unbinding GPU from $current_driver..."
+    if [[ -f "/sys/bus/pci/devices/${gpu_pci_full}/driver/unbind" ]]; then
+      if ! echo "$gpu_pci_full" | sudo -n tee "/sys/bus/pci/devices/${gpu_pci_full}/driver/unbind" >/dev/null 2>&1; then
+        msg_error "Failed to unbind GPU from $current_driver"
+        msg_info "This usually means a process is still using the GPU"
+        log_error "Failed to unbind GPU from $current_driver (process still using GPU)"
+        exit 1
+      fi
+      log_success "GPU unbound from $current_driver"
+    fi
+  fi
+
+  if ! is_module_loaded vfio_pci; then
+    log_info "Loading vfio-pci module..."
+    if sudo -n /usr/bin/modprobe vfio-pci 2>/dev/null; then
+      log_success "vfio-pci module loaded"
+    else
+      if is_module_loaded vfio_pci; then
+        log_info "vfio-pci already loaded"
+      else
+        msg_error "Failed to load vfio-pci module"
+        log_error "vfio-pci module failed to load - cannot bind GPU"
+        exit 1
+      fi
+    fi
+  fi
+
+  # Get all IOMMU group devices (supports laptops with 4-5 devices in group and AMD with separate audio group)
+  local iommu_devices
+  iommu_devices=$(get_cached_iommu_devices "$GPU_PCI_ADDR")
+
+  local device_count=$(echo "$iommu_devices" | wc -w)
+  log_info "IOMMU group contains $device_count device(s): $iommu_devices"
+
+  clear_amd_driver_overrides "$iommu_devices"
+
+  # Register GPU vendor/device ID with vfio-pci (requires root)
+  echo "$GPU_VENDOR_ID $GPU_DEVICE_ID" | sudo -n tee /sys/bus/pci/drivers/vfio-pci/new_id >/dev/null 2>&1 || true
+
+  for dev_pci in $iommu_devices; do
+    local dev_pci_full
+    dev_pci_full=$(normalize_pci_addr "$dev_pci") || continue
+
+    if [[ ! -e "/sys/bus/pci/devices/${dev_pci_full}" ]]; then
+      log_warn "Device $dev_pci not found, skipping"
+      continue
+    fi
+
+    # Skip PCI bridges (class 0604) - defense in depth
+    local dev_class=$(get_pci_class "$dev_pci")
+    if [[ "$dev_class" == "0604" ]]; then
+      log_info "Skipping PCI bridge $dev_pci (class 0604)"
+      continue
+    fi
+
+    # Unbind from current driver (requires root)
+    if [[ -f "/sys/bus/pci/devices/${dev_pci_full}/driver/unbind" ]]; then
+      echo "$dev_pci_full" | sudo -n tee "/sys/bus/pci/devices/${dev_pci_full}/driver/unbind" >/dev/null 2>&1 || true
+    fi
+
+    # Register device ID with vfio-pci (requires root)
+    local dev_ids=$(get_pci_device_id "$dev_pci")
+    if [[ -n "$dev_ids" ]]; then
+      echo "${dev_ids/:/ }" | sudo -n tee /sys/bus/pci/drivers/vfio-pci/new_id >/dev/null 2>&1 || true
+    fi
+
+    # Bind to vfio-pci (requires root)
+    if [[ ! -d "/sys/bus/pci/drivers/vfio-pci/${dev_pci_full}" ]]; then
+      echo "$dev_pci_full" | sudo -n tee /sys/bus/pci/drivers/vfio-pci/bind >/dev/null 2>&1 || true
+    fi
+    log_info "Bound $dev_pci to vfio-pci"
+  done
+  log_success "All IOMMU group devices bound to vfio-pci"
+
+  # Verify all devices are actually bound (USB controllers may be rebound by xhci_hcd)
+  local bind_issues=0
+  for dev_pci in $iommu_devices; do
+    local dev_class=$(get_pci_class "$dev_pci")
+    [[ "$dev_class" == "0604" ]] && continue  # Skip bridges
+
+    local dev_driver=$(get_pci_driver "$dev_pci")
+    if [[ "$dev_driver" != "vfio-pci" ]]; then
+      log_warn "Device $dev_pci not bound to vfio-pci (driver: ${dev_driver:-none})"
+      if [[ "$dev_class" == "0c03" ]]; then
+        bind_issues=1
+        msg_warning "USB controller $dev_pci rebound to ${dev_driver:-none}"
+      fi
+    fi
+  done
+
+  if [[ "$bind_issues" -eq 1 ]]; then
+    msg_info "Fix: Re-run 'omarchy-gpu-passthrough setup' then reboot"
+  fi
+
+  show_spinner 1 "Verifying GPU binding..."
+  current_driver=$(get_pci_driver "$GPU_PCI_ADDR")
+
+  echo ""
+  if [[ "$current_driver" == "vfio-pci" ]]; then
+    msg_success "GPU bound to vfio-pci (ready for VM)"
+    log_success "=== BIND SUCCESS: GPU ready for VM passthrough ==="
+
+    update_state_marker "vm"
+
+    # For AMD GPUs with reset bug: enable persistent VFIO mode
+    # This ensures GPU stays on vfio-pci after reboot (avoids rebind problem)
+    if [[ "$GPU_VENDOR_ID" == "1002" ]] && gpu_has_reset_bug "$GPU_PCI_ADDR"; then
+      if ! is_persistent_vfio_enabled "$GPU_PCI_ADDR" "$GPU_VENDOR_ID" "$GPU_DEVICE_ID"; then
+        echo ""
+        msg_info "AMD GPU with reset bug - enabling persistent VM mode"
+        msg_info "GPU will boot directly to vfio-pci after reboot"
+        if enable_persistent_vfio "$GPU_PCI_ADDR" "$GPU_VENDOR_ID" "$GPU_DEVICE_ID"; then
+          msg_success "Persistent VM mode enabled (effective after reboot)"
+          log_success "Persistent VFIO enabled for reset-bug GPU"
+        else
+          msg_warning "Failed to enable persistent mode"
+          msg_info "GPU may require rebind after each reboot"
+          log_warn "Failed to enable persistent VFIO for reset-bug GPU"
+        fi
+      else
+        log_info "Persistent VFIO already enabled for this GPU"
+      fi
+    fi
+  else
+    msg_error "Failed to bind (current: ${current_driver:-none})"
+    log_error "=== BIND FAILED: driver ${current_driver:-none} ==="
+    exit 1
+  fi
+}
+
+cmd_set_none() {
+  log_init
+
+  if ! load_gpu_config; then
+    msg_section "GPU Mode: None"
+    msg_error "GPU passthrough not configured"
+    msg_info "Run: omarchy-gpu-passthrough setup"
+    log_error "Set none failed: GPU passthrough not configured"
+    exit 1
+  fi
+
+  local gpu_pci_full
+  gpu_pci_full=$(normalize_pci_addr "$GPU_PCI_ADDR") || {
+    msg_error "Invalid GPU PCI address: $GPU_PCI_ADDR"
+    exit 1
+  }
+
+  msg_section "GPU Mode: Switch to None"
+
+  local current_driver=$(get_pci_driver "$GPU_PCI_ADDR")
+
+  log_info "=== SET NONE OPERATION START ==="
+  log_info "GPU: $GPU_NAME ($GPU_PCI_ADDR)"
+  log_info "Current driver: ${current_driver:-none}"
+
+  if [[ -z "$current_driver" ]]; then
+    msg_success "GPU already in none mode (no driver)"
+    log_info "Already in none mode"
+
+    update_state_marker "none"
+    exit 0
+  fi
+
+  check_gpu_processes "$current_driver"
+  [[ "$current_driver" == "nvidia" ]] && unload_nvidia_modules
+
+  msg_info "Unbinding GPU from $current_driver..."
+  log_info "Unbinding from $current_driver to none state"
+
+  # Get all IOMMU group devices (supports laptops with 4-5 devices in group)
+  local iommu_devices
+  iommu_devices=$(get_cached_iommu_devices "$GPU_PCI_ADDR")
+
+  local device_count=$(echo "$iommu_devices" | wc -w)
+  log_info "IOMMU group contains $device_count device(s): $iommu_devices"
+
+  for dev_pci in $iommu_devices; do
+    local dev_pci_full
+    dev_pci_full=$(normalize_pci_addr "$dev_pci") || continue
+
+    if [[ -f "/sys/bus/pci/devices/${dev_pci_full}/driver/unbind" ]]; then
+      log_info "Unbinding $dev_pci from driver..."
+      if ! echo "$dev_pci_full" | sudo -n tee "/sys/bus/pci/devices/${dev_pci_full}/driver/unbind" >/dev/null 2>&1; then
+        # Only fail on main GPU, others are non-fatal
+        if [[ "$dev_pci_full" == "$gpu_pci_full" ]]; then
+          msg_error "Failed to unbind GPU from $current_driver"
+          msg_info "This usually means a process is still using the GPU"
+          log_error "Failed to unbind GPU (process still using GPU)"
+          exit 1
+        fi
+        log_warn "Failed to unbind $dev_pci (non-fatal)"
+      fi
+    fi
+  done
+  log_success "All IOMMU group devices unbound"
+
+  if [[ "$current_driver" == "vfio-pci" ]]; then
+    remove_vfio_device_ids "$iommu_devices"
+    rebind_usb_controllers_to_xhci "$iommu_devices"
+  fi
+
+  show_spinner 1 "Verifying GPU state..."
+  current_driver=$(get_pci_driver "$GPU_PCI_ADDR")
+
+  echo ""
+  if [[ -z "$current_driver" ]]; then
+    msg_success "GPU set to none mode (no driver loaded)"
+    log_success "=== SET NONE SUCCESS: GPU inactive ==="
+
+    update_state_marker "none"
+  else
+    msg_error "Failed to unbind (current: $current_driver)"
+    log_error "=== SET NONE FAILED: driver $current_driver still loaded ==="
+    exit 1
+  fi
+}
+
+cmd_unbind() {
+  log_init
+
+  if ! load_gpu_config; then
+    msg_section "GPU Mode: Host"
+    msg_error "GPU passthrough not configured"
+    msg_info "Run: omarchy-gpu-passthrough setup"
+    log_error "Unbind failed: GPU passthrough not configured"
+    exit 1
+  fi
+
+  local gpu_pci_full
+  gpu_pci_full=$(normalize_pci_addr "$GPU_PCI_ADDR") || {
+    msg_error "Invalid GPU PCI address: $GPU_PCI_ADDR"
+    exit 1
+  }
+
+  msg_section "GPU Mode: Switch to Host"
+
+  local current_driver=$(get_pci_driver "$GPU_PCI_ADDR")
+
+  log_info "=== UNBIND OPERATION START ==="
+  log_info "GPU: $GPU_NAME ($GPU_PCI_ADDR)"
+  log_info "Current driver: ${current_driver:-none}"
+
+  # Early exit only if GPU is already using native driver
+  if [[ "$current_driver" == "$GPU_DRIVER_ORIGINAL" ]]; then
+    msg_success "GPU already using $GPU_DRIVER_ORIGINAL"
+    log_info "Already using original driver ($GPU_DRIVER_ORIGINAL)"
+    exit 0
+  fi
+
+  # AMD Reset Bug check: affected GPUs need reboot after vfio-pci use to work with native driver
+  # Affected: Vega 10/20, Fiji, Tonga, Hawaii, some Polaris, some Navi 10/14
+  if gpu_needs_reboot_for_native_driver "$GPU_PCI_ADDR" "$GPU_VENDOR_ID"; then
+    echo ""
+    msg_warning "AMD GPU with reset bug detected"
+    msg_warning "This GPU cannot rebind to amdgpu without reboot"
+    echo ""
+
+    local has_persistent=false
+    is_persistent_vfio_enabled "$GPU_PCI_ADDR" "$GPU_VENDOR_ID" "$GPU_DEVICE_ID" && has_persistent=true
+
+    if command -v gum &>/dev/null && [[ -t 0 ]]; then
+      local choice
+      if [[ "$has_persistent" == "true" ]]; then
+        choice=$(gum choose \
+          "Prepare for host (disable VM mode, then reboot)" \
+          "Keep VM mode" \
+          "Cancel")
+      else
+        choice=$(gum choose \
+          "Reboot now to use GPU on host" \
+          "Keep VM mode" \
+          "Cancel")
+      fi
+
+      case "$choice" in
+      "Prepare for host"*)
+        echo ""
+        msg_info "Disabling persistent VM mode..."
+        if disable_persistent_vfio "$GPU_PCI_ADDR" "$GPU_VENDOR_ID" "$GPU_DEVICE_ID"; then
+          echo ""
+          msg_success "Persistent VM mode disabled"
+          msg_info "GPU will use $GPU_DRIVER_ORIGINAL after reboot"
+          echo ""
+          if gum confirm "Reboot now?"; then
+            log_info "User chose to reboot after disabling persistent VFIO"
+            sudo reboot
+          else
+            msg_info "Run 'sudo reboot' when ready"
+          fi
+        else
+          msg_error "Failed to disable persistent mode"
+        fi
+        ;;
+      "Reboot now"*)
+        log_info "User chose to reboot for host mode"
+        sudo reboot
+        ;;
+      "Keep VM mode")
+        msg_info "GPU stays in VM mode"
+        ;;
+      *)
+        msg_info "Cancelled"
+        ;;
+      esac
+    else
+      # Fallback without gum
+      if [[ "$has_persistent" == "true" ]]; then
+        echo "To use GPU on host:"
+        echo "  1. Disable persistent mode: omarchy-gpu-passthrough persistent off"
+        echo "  2. Reboot: sudo reboot"
+      else
+        echo "To use GPU on host: sudo reboot"
+      fi
+    fi
+
+    log_warn "AMD GPU with reset bug needs reboot to use native driver after vfio-pci"
+    exit 1
+  fi
+
+  # Safety check: ensure no processes using GPU before unbind
+  check_gpu_processes "$current_driver"
+
+  if [[ "$current_driver" == "vfio-pci" ]]; then
+    msg_info "Unbinding from vfio-pci..."
+    log_info "GPU: $GPU_NAME ($GPU_PCI_ADDR)"
+
+    # Get all IOMMU group devices (supports laptops with 4-5 devices in group and AMD with separate audio group)
+    local iommu_devices
+    iommu_devices=$(get_cached_iommu_devices "$GPU_PCI_ADDR")
+
+    local device_count=$(echo "$iommu_devices" | wc -w)
+    log_info "IOMMU group contains $device_count device(s): $iommu_devices"
+
+    clear_amd_driver_overrides "$iommu_devices"
+
+    for dev_pci in $iommu_devices; do
+      local dev_pci_full
+      dev_pci_full=$(normalize_pci_addr "$dev_pci") || continue
+
+      if [[ -d "/sys/bus/pci/drivers/vfio-pci/${dev_pci_full}" ]]; then
+        log_info "Unbinding $dev_pci from vfio-pci..."
+        echo "$dev_pci_full" | sudo -n tee /sys/bus/pci/drivers/vfio-pci/unbind >/dev/null 2>&1 || true
+      fi
+    done
+
+    remove_vfio_device_ids "$iommu_devices"
+
+    # For AMD GPUs: try GPU reset before rebinding to native driver
+    if [[ "$GPU_VENDOR_ID" == "1002" ]]; then
+      msg_info "Resetting AMD GPU..."
+      try_reset_gpu "$GPU_PCI_ADDR" || log_warn "GPU reset not available (continuing anyway)"
+    fi
+
+    log_success "All IOMMU group devices unbound from vfio-pci"
+
+    rebind_usb_controllers_to_xhci "$iommu_devices"
+  else
+    # GPU not bound to vfio-pci (e.g., driver is "none")
+    msg_info "GPU driver: ${current_driver:-none} (binding to $GPU_DRIVER_ORIGINAL)..."
+    log_info "Current driver: ${current_driver:-none}, binding to $GPU_DRIVER_ORIGINAL"
+  fi
+
+  # Bind to native driver (works from any state: vfio-pci, none, or other)
+
+  # Fallback: infer native driver from vendor ID if config has "none" or empty
+  # (backwards compatibility with old configs)
+  if [[ "$GPU_DRIVER_ORIGINAL" == "none" || -z "$GPU_DRIVER_ORIGINAL" ]]; then
+    local inferred_driver=""
+    case "$GPU_VENDOR_ID" in
+    10de) inferred_driver="nvidia" ;;
+    1002) inferred_driver="amdgpu" ;;
+    8086) inferred_driver="i915" ;;
+    *)
+      msg_error "Cannot determine native driver for vendor: $GPU_VENDOR_ID"
+      msg_info "Re-run setup: omarchy-gpu-passthrough setup"
+      log_error "Invalid GPU_DRIVER_ORIGINAL and cannot infer from vendor ID"
+      exit 1
+      ;;
+    esac
+
+    GPU_DRIVER_ORIGINAL="$inferred_driver"
+    log_info "Inferred native driver: $GPU_DRIVER_ORIGINAL (from vendor $GPU_VENDOR_ID)"
+    msg_info "Auto-updating config: GPU_DRIVER_ORIGINAL=$GPU_DRIVER_ORIGINAL"
+
+    # Auto-update config file (fix old configs permanently)
+    if [[ -f "$GPU_PASSTHROUGH_CONF" ]]; then
+      if sudo -n /usr/bin/sed -i "s/^GPU_DRIVER_ORIGINAL=.*/GPU_DRIVER_ORIGINAL=\"$inferred_driver\"/" "$GPU_PASSTHROUGH_CONF" 2>/dev/null; then
+        log_info "Config updated: GPU_DRIVER_ORIGINAL=\"$inferred_driver\""
+      else
+        log_warn "Failed to update config file (continuing with inferred driver)"
+      fi
+    fi
+  fi
+
+  msg_info "Binding to native driver ($GPU_DRIVER_ORIGINAL)..."
+  log_info "Binding to native driver ($GPU_DRIVER_ORIGINAL)..."
+
+  if [[ "$GPU_DRIVER_ORIGINAL" == "nvidia" ]]; then
+    # Use -i flag to bypass blacklist (install nvidia /bin/false)
+    for mod in nvidia nvidia_uvm; do
+      if sudo -n /usr/bin/modprobe -i "$mod" 2>/dev/null; then
+        log_success "$mod loaded"
+      elif is_module_loaded "$mod"; then
+        log_info "$mod already loaded"
+      else
+        log_warn "$mod failed to load"
+      fi
+    done
+    # Load nvidia_drm only if monitor is on dGPU (detected during setup)
+    if [[ "${DGPU_HAS_EXTERNAL_MONITOR:-false}" == "true" ]]; then
+      if sudo -n /usr/bin/modprobe -i nvidia_drm modeset=1 2>/dev/null; then
+        log_success "nvidia_drm loaded with modeset=1 (external monitor on dGPU)"
+      elif is_module_loaded nvidia_drm; then
+        log_info "nvidia_drm already loaded"
+      else
+        log_warn "nvidia_drm failed to load"
+      fi
+    else
+      log_info "Display modules NOT loaded (monitor on iGPU)"
+    fi
+  else
+    if sudo -n /usr/bin/modprobe "$GPU_DRIVER_ORIGINAL" 2>/dev/null; then
+      log_success "$GPU_DRIVER_ORIGINAL loaded"
+    elif is_module_loaded "$GPU_DRIVER_ORIGINAL"; then
+      log_info "$GPU_DRIVER_ORIGINAL already loaded"
+    else
+      log_warn "$GPU_DRIVER_ORIGINAL failed to load"
+    fi
+  fi
+
+  # Trigger PCI rescan (requires root)
+  log_info "Triggering PCI rescan..."
+  echo 1 | sudo -n tee /sys/bus/pci/rescan >/dev/null 2>&1
+  show_spinner 1 "Scanning PCI bus..."
+
+  # Bind via sysfs (requires root)
+  if [[ -d "/sys/bus/pci/drivers/$GPU_DRIVER_ORIGINAL" ]]; then
+    log_info "Binding GPU to $GPU_DRIVER_ORIGINAL via sysfs..."
+    if echo "$gpu_pci_full" | sudo -n tee "/sys/bus/pci/drivers/$GPU_DRIVER_ORIGINAL/bind" >/dev/null 2>&1; then
+      log_success "GPU bound to $GPU_DRIVER_ORIGINAL"
+    fi
+  fi
+
+  show_spinner 2 "Loading driver..."
+
+  current_driver=$(get_pci_driver "$GPU_PCI_ADDR")
+  log_info "Final driver: ${current_driver:-none}"
+
+  echo ""
+  if [[ "$current_driver" == "$GPU_DRIVER_ORIGINAL" ]] || [[ -n "$current_driver" && "$current_driver" != "vfio-pci" ]]; then
+    msg_success "GPU restored to $GPU_DRIVER_ORIGINAL (available to host)"
+    log_success "=== UNBIND SUCCESS: GPU restored to $GPU_DRIVER_ORIGINAL ==="
+
+    update_state_marker "host"
+
+    # Disable persistent VFIO mode if it was enabled
+    # This allows GPU to boot with native driver after next reboot
+    if is_persistent_vfio_enabled "$GPU_PCI_ADDR" "$GPU_VENDOR_ID" "$GPU_DEVICE_ID"; then
+      echo ""
+      msg_info "Disabling persistent VM mode"
+      msg_info "GPU will boot with native driver after reboot"
+      if disable_persistent_vfio "$GPU_PCI_ADDR" "$GPU_VENDOR_ID" "$GPU_DEVICE_ID"; then
+        msg_success "Persistent VM mode disabled (effective after reboot)"
+        log_success "Persistent VFIO disabled"
+      else
+        msg_warning "Failed to disable persistent mode"
+        msg_info "GPU may still boot to vfio-pci after reboot"
+        log_warn "Failed to disable persistent VFIO"
+      fi
+    fi
+  else
+    msg_warning "Unbound but driver not auto-loaded (current: ${current_driver:-none})"
+    msg_info "Manual reload: sudo modprobe -i $GPU_DRIVER_ORIGINAL"
+    log_warn "=== UNBIND PARTIAL: driver not loaded (${current_driver:-none}) ==="
+
+    # Still update marker to host (partial success)
+    update_state_marker "host"
+  fi
+}
+
+# Mode Command Functions
+
+ensure_state_marker() {
+  # Use flock for atomic state marker operations (prevent race conditions)
+  # Use user runtime directory (systemd standard) to avoid permission issues
+  local lockfile
+  if [[ -d "/run/user/$UID" ]]; then
+    lockfile="/run/user/$UID/omarchy-gpu-mode.lock"
+  else
+    # Fallback to /tmp with user suffix
+    lockfile="/tmp/omarchy-gpu-mode-$USER.lock"
+  fi
+
+  # Execute with exclusive lock
+  (
+    # Acquire exclusive lock (FD 200)
+    if ! flock -x -w 5 200; then
+      log_warn "Failed to acquire lock for state marker (timeout)"
+      return 1
+    fi
+
+    if [[ ! -f "$STATE_MARKER_FILE" ]]; then
+      if ! load_gpu_config 2>/dev/null; then
+        return 0
+      fi
+
+      local current_driver=$(get_pci_driver "$GPU_PCI_ADDR")
+      local detected_mode=$(detect_gpu_mode_from_driver "$current_driver")
+
+      if ! echo "$detected_mode" | sudo -n /usr/bin/tee "$STATE_MARKER_FILE" >/dev/null 2>&1; then
+        log_warn "Failed to create state marker (state detection may be incorrect)"
+      else
+        log_info "State marker initialized to: $detected_mode (detected from actual GPU state)"
+      fi
+      return 0
+    fi
+
+    local marker_mode=""
+    [[ -r "$STATE_MARKER_FILE" ]] && marker_mode=$(<"$STATE_MARKER_FILE") 2>/dev/null
+
+    # Validate marker content (must be none/vm/host)
+    case "$marker_mode" in
+    none | vm | host) ;; # Valid
+    *)
+      log_warn "Invalid state marker content: '$marker_mode' (treating as missing)"
+      marker_mode="" # Treat as invalid/missing
+      ;;
+    esac
+
+    if ! load_gpu_config 2>/dev/null; then
+      return 0
+    fi
+
+    local current_driver=$(get_pci_driver "$GPU_PCI_ADDR")
+    local actual_mode=$(detect_gpu_mode_from_driver "$current_driver")
+
+    if [[ "$marker_mode" != "$actual_mode" ]]; then
+      log_warn "State marker mismatch: marker=$marker_mode, actual=$actual_mode (fixing)"
+      if ! echo "$actual_mode" | sudo -n /usr/bin/tee "$STATE_MARKER_FILE" >/dev/null 2>&1; then
+        log_warn "Failed to update state marker (state may be out of sync)"
+      fi
+    fi
+
+    return 0
+  ) 200>"$lockfile"
+}
+
+cmd_persistent() {
+  local action="${1:-}"
+  log_init
+
+  if ! load_gpu_config; then
+    msg_section "GPU Persistent Mode"
+    msg_error "GPU passthrough not configured"
+    msg_info "Run: omarchy-gpu-passthrough setup"
+    exit 1
+  fi
+
+  local is_enabled=false
+  is_persistent_vfio_enabled "$GPU_PCI_ADDR" "$GPU_VENDOR_ID" "$GPU_DEVICE_ID" && is_enabled=true
+
+  case "$action" in
+  on)
+    msg_section "GPU Persistent Mode: Enable"
+    if [[ "$is_enabled" == "true" ]]; then
+      msg_info "Persistent VM mode already enabled"
+      msg_info "GPU will boot to vfio-pci (ready for VM)"
+      exit 0
+    fi
+    msg_info "Enabling persistent VM mode..."
+    if enable_persistent_vfio "$GPU_PCI_ADDR" "$GPU_VENDOR_ID" "$GPU_DEVICE_ID"; then
+      echo ""
+      msg_success "Persistent VM mode enabled"
+      msg_info "GPU will boot to vfio-pci after reboot"
+      log_success "Persistent VFIO enabled"
+    else
+      msg_error "Failed to enable persistent mode"
+      exit 1
+    fi
+    ;;
+  off)
+    msg_section "GPU Persistent Mode: Disable"
+    if [[ "$is_enabled" == "false" ]]; then
+      msg_info "Persistent VM mode not enabled"
+      msg_info "GPU will boot with native driver ($GPU_DRIVER_ORIGINAL)"
+      exit 0
+    fi
+    msg_info "Disabling persistent VM mode..."
+    if disable_persistent_vfio "$GPU_PCI_ADDR" "$GPU_VENDOR_ID" "$GPU_DEVICE_ID"; then
+      echo ""
+      msg_success "Persistent VM mode disabled"
+      msg_info "GPU will boot with $GPU_DRIVER_ORIGINAL after reboot"
+      log_success "Persistent VFIO disabled"
+    else
+      msg_error "Failed to disable persistent mode"
+      exit 1
+    fi
+    ;;
+  ""|status)
+    msg_section "GPU Persistent Mode"
+    echo "GPU: $GPU_NAME ($GPU_PCI_ADDR)"
+    if [[ "$is_enabled" == "true" ]]; then
+      msg_success "Persistent: on"
+      echo "GPU will boot to vfio-pci (ready for VM)"
+    else
+      msg_info "Persistent: off"
+      echo "GPU will boot with native driver ($GPU_DRIVER_ORIGINAL)"
+    fi
+    echo ""
+    echo "Usage: omarchy-gpu-passthrough persistent [on|off]"
+    ;;
+  *)
+    msg_error "Invalid action: $action"
+    echo "Usage: omarchy-gpu-passthrough persistent [on|off]"
+    exit 1
+    ;;
+  esac
+}
+
+cmd_mode_set() {
+  local target="$1"
+
+  # Ensure state marker exists (non-fatal if it fails - continue with operation)
+  if ! ensure_state_marker; then
+    log_warn "State marker sync failed - continuing anyway (state detection may be inaccurate)"
+  fi
+
+  case "$target" in
+  none)
+    cmd_set_none
+    ;;
+  vm)
+    cmd_bind
+    ;;
+  host)
+    cmd_unbind
+    ;;
+  *)
+    echo ""
+    msg_error "Invalid mode: $target"
+    echo "Valid modes: none, vm, host"
+    echo "Usage: omarchy-gpu-passthrough mode [none|vm|host]"
+    echo ""
+    exit 1
+    ;;
+  esac
+}
+
+cmd_mode_get() {
+  # Ensure state marker exists (non-fatal if it fails)
+  if ! ensure_state_marker; then
+    log_warn "State marker sync failed - mode detection may be inaccurate"
+  fi
+
+  if ! load_gpu_config; then
+    echo ""
+    msg_error "GPU passthrough not configured"
+    msg_info "Run: omarchy-gpu-passthrough setup"
+    exit 1
+  fi
+
+  local current_driver=$(get_pci_driver "$GPU_PCI_ADDR")
+  local binding_type="runtime"
+  local persistent_mode="false"
+
+  if is_early_binding_enabled "$GPU_PCI_ADDR"; then
+    binding_type="early"
+  fi
+
+  if is_persistent_vfio_enabled "$GPU_PCI_ADDR" "$GPU_VENDOR_ID" "$GPU_DEVICE_ID"; then
+    persistent_mode="true"
+  fi
+
+  local has_reset_bug="false"
+  if [[ "$GPU_VENDOR_ID" == "1002" ]] && gpu_has_reset_bug "$GPU_PCI_ADDR"; then
+    has_reset_bug="true"
+  fi
+
+  echo ""
+  echo "GPU: $GPU_NAME ($GPU_PCI_ADDR)"
+  case "$current_driver" in
+  vfio-pci)
+    msg_success "Mode: vm"
+    echo "Driver: vfio-pci"
+    if [[ "$persistent_mode" == "true" ]]; then
+      echo "Binding: persistent (vfio-pci from boot)"
+    else
+      echo "Binding: $binding_type (vfio-pci $([ "$binding_type" == "early" ] && echo "from boot" || echo "on demand"))"
+    fi
+    echo "Status: Ready for VM passthrough"
+    if [[ "$has_reset_bug" == "true" ]]; then
+      if [[ "$persistent_mode" == "true" ]]; then
+        echo "Note: AMD reset bug GPU - persistent mode active"
+      else
+        echo "Note: AMD reset bug GPU - reboot needed to return to host"
+      fi
+    fi
+    ;;
+  nvidia | amdgpu | i915)
+    msg_success "Mode: host"
+    echo "Driver: $current_driver"
+    if [[ "$persistent_mode" == "true" ]]; then
+      echo "Binding: persistent (vfio-pci at next boot)"
+    else
+      echo "Binding: $binding_type"
+    fi
+    echo "Status: Available to host"
+    if [[ "$has_reset_bug" == "true" && "$persistent_mode" != "true" ]]; then
+      echo "Note: AMD reset bug GPU - use 'mode vm' to enable persistent mode"
+    fi
+    ;;
+  "")
+    msg_success "Mode: none"
+    echo "Driver: none"
+    if [[ "$persistent_mode" == "true" ]]; then
+      echo "Binding: persistent (vfio-pci at next boot)"
+    else
+      echo "Binding: $binding_type$([ "$binding_type" == "early" ] && echo " (vfio-pci at next boot)")"
+    fi
+    echo "Status: No driver loaded (boot state)"
+    ;;
+  *)
+    msg_info "Mode: unknown"
+    echo "Driver: $current_driver"
+    echo "Binding: $binding_type"
+    echo "Status: Unknown state"
+    ;;
+  esac
+  echo ""
+}
+
+# Help Function
+
+show_bind_help() {
+  cat <<EOF
+GPU Passthrough Binding Operations
+
+Usage: omarchy-gpu-passthrough mode [none|vm|host]
+       omarchy-gpu-passthrough persistent [on|off]
+
+MODE COMMANDS:
+  mode              Show current GPU mode
+  mode none         No driver (inactive, power save)
+  mode vm           Bind to vfio-pci (ready for VM)
+  mode host         Bind to native driver (available to host)
+
+PERSISTENT MODE:
+  persistent        Show persistent mode status
+  persistent on     GPU boots to vfio-pci (for VM)
+  persistent off    GPU boots with native driver (for host)
+
+OPTIONS:
+  -h, --help        Show this help
+
+EXAMPLES:
+  omarchy-gpu-passthrough mode         # Show current mode
+  omarchy-gpu-passthrough mode vm      # Switch to VM mode
+  omarchy-gpu-passthrough persistent   # Show persistent status
+  omarchy-gpu-passthrough persistent off  # Disable, then reboot for host
+
+AMD RESET BUG:
+  Some AMD GPUs (Vega, Navi, Polaris) cannot rebind to native driver
+  after vfio-pci without reboot. For these GPUs:
+  - 'mode vm' auto-enables persistent mode
+  - 'mode host' shows TUI to disable persistent + reboot
+  - Or manually: 'persistent off' then reboot
+EOF
+}
+
+# Main Dispatcher
+
+case "${1:-}" in
+mode)
+  shift
+  if [[ -z "${1:-}" ]]; then
+    cmd_mode_get
+  else
+    cmd_mode_set "$1"
+  fi
+  ;;
+persistent)
+  shift
+  cmd_persistent "${1:-}"
+  ;;
+-h | --help | help)
+  show_bind_help
+  ;;
+*)
+  if [[ -z "${1:-}" ]]; then
+    echo ""
+    echo "Missing command. Usage: omarchy-gpu-passthrough mode [none|vm|host]"
+    echo ""
+  else
+    echo ""
+    echo "Unknown option: $1"
+    echo ""
+  fi
+  show_bind_help
+  exit 1
+  ;;
+esac
diff --git a/bin/omarchy-gpu-passthrough-info b/bin/omarchy-gpu-passthrough-info
new file mode 100755
index 0000000000..ca10e7df0a
--- /dev/null
+++ b/bin/omarchy-gpu-passthrough-info
@@ -0,0 +1,2746 @@
+#!/bin/bash
+#
+# omarchy-gpu-passthrough-info - Information and diagnostics
+#
+
+set -uo pipefail
+
+SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
+if ! source "$SCRIPT_DIR/omarchy-gpu-passthrough-utils"; then
+  echo "ERROR: Cannot load omarchy-gpu-passthrough-utils" >&2
+  echo "Please ensure omarchy-gpu-passthrough-utils exists in: $SCRIPT_DIR" >&2
+  exit 1
+fi
+
+verify_hardware_requirements() {
+  local quiet="$1"
+  local is_configured="$2"
+  local errors=0
+
+  [[ "$quiet" != "true" ]] && echo ""
+  [[ "$quiet" != "true" ]] && echo "Hardware:"
+
+  if [[ "$GPU_COUNT" -ge 2 ]]; then
+    local iommu_status=""
+    if check_iommu_support; then
+      local iommu_groups=$(find /dev/vfio/ -maxdepth 1 -type c -name '[0-9]*' 2>/dev/null | wc -l)
+      if [[ "$iommu_groups" -gt 0 ]]; then
+        iommu_status=", IOMMU enabled ($iommu_groups groups)"
+      else
+        iommu_status=", IOMMU enabled"
+      fi
+    else
+      iommu_status=", IOMMU not detected"
+      [[ "$quiet" != "true" ]] && msg_error "  IOMMU not detected"
+      [[ "$quiet" != "true" ]] && echo "    Fix: omarchy-gpu-passthrough setup (adds kernel params + BIOS guidance)"
+      ((errors++))
+    fi
+    [[ "$quiet" != "true" ]] && msg_success "  $GPU_COUNT GPUs detected$iommu_status"
+  elif [[ "$GPU_COUNT" -eq 1 ]]; then
+    [[ "$quiet" != "true" ]] && msg_warning "  Only 1 GPU detected (need 2+ for passthrough)"
+    if [[ "$is_configured" == "true" ]]; then
+      ((errors++))
+    fi
+  else
+    [[ "$quiet" != "true" ]] && msg_error "  No GPUs detected"
+    ((errors++))
+  fi
+
+  return "$errors"
+}
+
+verify_kernel_config() {
+  local quiet="$1"
+  local is_configured="$2"
+  local cmdline="$3"
+  local errors=0
+
+  [[ "$quiet" != "true" ]] && echo ""
+  [[ "$quiet" != "true" ]] && echo "Kernel Configuration:"
+
+  if [[ "$quiet" != "true" ]]; then
+    echo "  Current cmdline:"
+    local line_width=120
+    local remaining="$cmdline"
+    while [[ -n "$remaining" ]]; do
+      if [[ "${#remaining}" -le "$line_width" ]]; then
+        echo "    $remaining"
+        break
+      else
+        # Find last space before line_width
+        local cut_pos="$line_width"
+        local substring="${remaining:0:$line_width}"
+        if [[ "$substring" =~ (.* ) ]]; then
+          cut_pos="${#BASH_REMATCH[1]}"
+        fi
+        echo "    ${remaining:0:$cut_pos}"
+        remaining="${remaining:$cut_pos}"
+        remaining="${remaining# }" # Trim leading space
+      fi
+    done
+  fi
+
+  local has_iommu_param=false
+  local has_iommu_pt=false
+  local has_vfio_ids=false
+
+  [[ "$cmdline" =~ (amd_iommu|intel_iommu)=on ]] && has_iommu_param=true
+  [[ "$cmdline" =~ iommu=pt ]] && has_iommu_pt=true
+  [[ "$cmdline" =~ vfio-pci\.ids= ]] && has_vfio_ids=true
+
+  if [[ "$has_iommu_param" == "true" ]]; then
+    local kernel_status="IOMMU parameter ✓"
+    [[ "$has_iommu_pt" == "true" ]] && kernel_status+=", iommu=pt ✓"
+
+    if [[ "$has_vfio_ids" == "true" ]]; then
+      local vfio_ids=""
+      [[ "$cmdline" =~ vfio-pci\.ids=([^[:space:]]+) ]] && vfio_ids="${BASH_REMATCH[1]}"
+      kernel_status+=", vfio-pci.ids=$vfio_ids (static)"
+    else
+      kernel_status+=", dynamic binding"
+    fi
+
+    [[ "$quiet" != "true" ]] && msg_success "  $kernel_status"
+  else
+    if [[ "$is_configured" == "true" ]]; then
+      [[ "$quiet" != "true" ]] && msg_error "  IOMMU parameter missing - did you reboot after setup?"
+      ((errors++))
+    else
+      [[ "$quiet" != "true" ]] && msg_info "  Not configured - run setup first"
+    fi
+  fi
+
+  if [[ "$quiet" != "true" ]] && [[ "$is_configured" == "true" ]]; then
+    local bootloader=$(detect_bootloader)
+    echo ""
+    case "$bootloader" in
+      limine)
+        echo "  Limine config ($LIMINE_DEFAULT):"
+        local limine_params
+        limine_params=$(grep '^KERNEL_CMDLINE\[default\]' "$LIMINE_DEFAULT" 2>/dev/null) || limine_params=""
+        if [[ "$limine_params" =~ (amd_iommu|intel_iommu)=on ]]; then
+          msg_success "    IOMMU parameters present"
+        else
+          msg_warning "    IOMMU parameters NOT in config - run setup to reconfigure"
+        fi
+        ;;
+      grub)
+        echo "  GRUB config ($GRUB_DEFAULT):"
+        local grub_line grub_params=""
+        grub_line=$(grep '^GRUB_CMDLINE_LINUX_DEFAULT=' "$GRUB_DEFAULT" 2>/dev/null) || grub_line=""
+        [[ "$grub_line" =~ ^GRUB_CMDLINE_LINUX_DEFAULT=\"([^\"]*)\" ]] && grub_params="${BASH_REMATCH[1]}"
+        if [[ "$grub_params" =~ (amd_iommu|intel_iommu)=on ]]; then
+          msg_success "    IOMMU parameters present"
+        else
+          msg_warning "    IOMMU parameters NOT in config - run setup to reconfigure"
+        fi
+        ;;
+      *)
+        echo "  $(get_bootloader_display_name "$bootloader") config ($(get_bootloader_config_path "$bootloader")):"
+        msg_info "    Manual configuration - check bootloader config directly"
+        ;;
+    esac
+  fi
+
+  return "$errors"
+}
+
+verify_vfio_setup() {
+  local quiet="$1"
+  local is_configured="$2"
+
+  [[ "$quiet" != "true" ]] && echo ""
+  [[ "$quiet" != "true" ]] && echo "VFIO Setup:"
+
+  local vfio_module_loaded=false
+  local vfio_conf_exists=false
+  local vfio_dev_exists=false
+
+  is_module_loaded vfio_pci && vfio_module_loaded=true
+  [[ -f "$VFIO_CONF" ]] && vfio_conf_exists=true
+  [[ -c /dev/vfio/vfio ]] && vfio_dev_exists=true
+
+  if [[ "$is_configured" == "true" ]]; then
+    local vfio_status=""
+    [[ "$vfio_module_loaded" == "true" ]] && vfio_status="vfio-pci loaded"
+    [[ "$vfio_conf_exists" == "true" ]] && vfio_status="${vfio_status:+$vfio_status, }config exists"
+    [[ "$vfio_dev_exists" == "true" ]] && vfio_status="${vfio_status:+$vfio_status, }/dev/vfio/vfio exists"
+
+    if [[ -n "$vfio_status" ]]; then
+      [[ "$quiet" != "true" ]] && msg_success "  $vfio_status"
+    else
+      [[ "$quiet" != "true" ]] && msg_info "  VFIO not active (normal if no GPU bound yet)"
+    fi
+  else
+    [[ "$quiet" != "true" ]] && msg_info "  VFIO not configured - run setup first"
+  fi
+
+  return 0
+}
+
+verify_usb_controller_setup() {
+  local quiet="$1"
+  local is_configured="$2"
+  local errors=0
+
+  [[ "$quiet" != "true" ]] && echo ""
+  [[ "$quiet" != "true" ]] && echo "USB Controller Setup (laptops with NVIDIA USB-C):"
+
+  if [[ "$is_configured" != "true" ]]; then
+    [[ "$quiet" != "true" ]] && msg_info "  Not configured - run setup first"
+    return 0
+  fi
+
+  # Check if vfio.conf has ids= line for USB controllers
+  local has_usb_ids=false
+  if [[ -f "$VFIO_CONF" ]] && grep -q "^options vfio-pci ids=" "$VFIO_CONF"; then
+    has_usb_ids=true
+    [[ "$quiet" != "true" ]] && msg_success "  vfio.conf has ids= line for early binding"
+  fi
+
+  # Check softdep
+  local has_softdep=false
+  if [[ -f "$VFIO_CONF" ]] && grep -q "softdep xhci" "$VFIO_CONF"; then
+    has_softdep=true
+    [[ "$quiet" != "true" ]] && msg_success "  softdep configured (vfio-pci loads before xhci_pci)"
+  fi
+
+  # Check udev rule
+  local usb_udev_rule="/etc/udev/rules.d/99-vfio-usb-override.rules"
+  local has_udev_rule=false
+  if [[ -f "$usb_udev_rule" ]]; then
+    has_udev_rule=true
+    [[ "$quiet" != "true" ]] && msg_success "  udev driver_override rule exists"
+  fi
+
+  # Find USB controllers in IOMMU groups and check their driver
+  local found_usb_issue=false
+  for i in "${!GPU_PCI_ADDR[@]}"; do
+    local pci="${GPU_PCI_ADDR[$i]}"
+    local pci_full
+    pci_full=$(normalize_pci_addr "$pci") || continue
+
+    local iommu_group_path=$(readlink -f "/sys/bus/pci/devices/${pci_full}/iommu_group" 2>/dev/null)
+    if [[ -d "$iommu_group_path/devices" ]]; then
+      for dev_path in "$iommu_group_path/devices"/*; do
+        if [[ -d "$dev_path" ]]; then
+          local dev_addr=$(basename "$dev_path")
+          local dev_addr_short="${dev_addr#0000:}"
+          local dev_class=$(get_pci_class "$dev_addr_short")
+          # USB controller class: 0c03
+          if [[ "$dev_class" == "0c03" ]]; then
+            local current_driver=$(get_pci_driver "$dev_addr_short")
+            if [[ "$current_driver" == "vfio-pci" ]]; then
+              [[ "$quiet" != "true" ]] && msg_success "  USB $dev_addr_short bound to vfio-pci ✓"
+            elif [[ "$current_driver" == "xhci_hcd" ]]; then
+              found_usb_issue=true
+              [[ "$quiet" != "true" ]] && msg_warning "USB $dev_addr_short bound to xhci_hcd (should be vfio-pci)"
+              ((errors++))
+            fi
+          fi
+        fi
+      done
+    fi
+  done
+
+  # Summary and recommendations
+  if [[ "$found_usb_issue" == "true" ]]; then
+    [[ "$quiet" != "true" ]] && echo ""
+    [[ "$quiet" != "true" ]] && msg_info "USB controller is bound to wrong driver. Possible fixes:"
+    [[ "$quiet" != "true" ]] && echo "    1. Re-run: omarchy-gpu-passthrough setup"
+    [[ "$quiet" != "true" ]] && echo "    2. Reboot after setup"
+    if [[ "$has_usb_ids" != "true" ]]; then
+      [[ "$quiet" != "true" ]] && echo "    Note: vfio.conf missing ids= line"
+    fi
+    if [[ "$has_softdep" != "true" ]]; then
+      [[ "$quiet" != "true" ]] && echo "    Note: vfio.conf missing softdep"
+    fi
+    if [[ "$has_udev_rule" != "true" ]]; then
+      [[ "$quiet" != "true" ]] && echo "    Note: udev driver_override rule missing"
+    fi
+  elif [[ "$has_usb_ids" != "true" && "$has_softdep" != "true" && "$has_udev_rule" != "true" ]]; then
+    [[ "$quiet" != "true" ]] && msg_info "  No USB controllers in GPU IOMMU groups (or not detected)"
+  fi
+
+  return $errors
+}
+
+verify_setup() {
+  local quiet="${1:-false}"
+  local total_errors=0
+  local is_configured=false
+
+  [[ "$quiet" != "true" ]] && msg_section "GPU Passthrough Verification"
+
+  # Load config to get configured GPU address BEFORE detect_gpus resets the arrays
+  local configured_gpu_pci=""
+  if load_gpu_config 2>/dev/null; then
+    configured_gpu_pci="$GPU_PCI_ADDR"
+    is_configured=true
+  fi
+
+  detect_gpus
+
+  if [[ "$quiet" != "true" ]]; then
+    echo ""
+    echo "System Information:"
+    local cpu_vendor=$(get_cpu_vendor)
+    case "$cpu_vendor" in
+    amd) echo "  CPU Vendor:     AMD" ;;
+    intel) echo "  CPU Vendor:     Intel" ;;
+    *) echo "  CPU Vendor:     Unknown" ;;
+    esac
+
+    echo "  Bootloader:     $(get_bootloader_display_name)"
+
+    echo "  Passthrough:    $(if [[ "$is_configured" == "true" ]]; then echo "Configured ✓"; else echo "Not configured"; fi)"
+  fi
+
+  verify_hardware_requirements "$quiet" "$is_configured"
+  ((total_errors += $?))
+
+  local cmdline=""
+  [[ -r /proc/cmdline ]] && cmdline=$(<"/proc/cmdline")
+  verify_kernel_config "$quiet" "$is_configured" "$cmdline"
+  ((total_errors += $?))
+
+  verify_vfio_setup "$quiet" "$is_configured"
+
+  verify_usb_controller_setup "$quiet" "$is_configured"
+  ((total_errors += $?))
+
+  [[ "$quiet" != "true" ]] && echo ""
+  [[ "$quiet" != "true" ]] && echo "GPU Status:"
+
+  local vfio_gpus=0
+  for i in "${!GPU_PCI_ADDR[@]}"; do
+    local name="${GPU_NAME[$i]}"
+    local driver="${GPU_DRIVER[$i]}"
+    local pci="${GPU_PCI_ADDR[$i]}"
+    local type="${GPU_TYPE[$i]}"
+
+    if [[ "$quiet" != "true" ]]; then
+      # Build one-line status per GPU
+      local status_msg="  [$((i + 1))] $name ($pci) → $driver"
+
+      if [[ "$driver" == "vfio-pci" ]]; then
+        msg_success "$status_msg (ready for VM)"
+        ((vfio_gpus++))
+      elif [[ "$driver" == "none" ]]; then
+        # Check if this is the configured passthrough GPU - "none" is expected state after boot
+        if [[ -n "$configured_gpu_pci" ]] && [[ "$pci" == "$configured_gpu_pci" ]]; then
+          msg_info "$status_msg (ready for passthrough)"
+        else
+          msg_warning "$status_msg (no driver)"
+        fi
+      else
+        if [[ "$type" == "integrated" ]]; then
+          msg_info "$status_msg (host display)"
+        else
+          msg_info "$status_msg (host)"
+        fi
+      fi
+    fi
+  done
+
+  # DISPLAY INFO
+  if [[ "$quiet" != "true" ]] && command -v glxinfo &>/dev/null; then
+    echo ""
+    echo "Display Rendering:"
+
+    local glx_output=$(glxinfo 2>/dev/null)
+    if [[ -n "$glx_output" ]]; then
+      local renderer=$(echo "$glx_output" | grep "OpenGL renderer" | cut -d: -f2- | xargs)
+      local version=$(echo "$glx_output" | grep "OpenGL version" | cut -d: -f2- | xargs)
+      local vendor=$(echo "$glx_output" | grep "OpenGL vendor" | cut -d: -f2- | xargs)
+
+      [[ -n "$vendor" ]] && echo "  Vendor:   $vendor"
+      [[ -n "$renderer" ]] && msg_success "  Renderer: $renderer"
+      [[ -n "$version" ]] && echo "  OpenGL:   $version"
+    else
+      msg_warning "  Unable to query OpenGL info"
+    fi
+  fi
+
+  # SUMMARY
+  if [[ "$quiet" != "true" ]]; then
+    echo ""
+
+    if [[ "$is_configured" == "false" ]]; then
+      msg_info "Status: Not configured"
+      echo ""
+      echo "Next steps:"
+      echo "   1. Run: omarchy-gpu-passthrough setup"
+      echo "   2. Reboot system"
+      echo "   3. Run: omarchy-gpu-passthrough info verify"
+    elif [[ "$total_errors" -eq 0 ]] && [[ "$vfio_gpus" -gt 0 ]]; then
+      msg_success "Status: Ready for GPU passthrough!"
+      echo ""
+      echo "GPU passthrough is properly configured:"
+      msg_success "$vfio_gpus GPU(s) bound to vfio-pci"
+      msg_success "IOMMU enabled and configured"
+      msg_success "Kernel parameters active"
+    elif [[ "$total_errors" -eq 0 ]] && [[ "$vfio_gpus" -eq 0 ]]; then
+      # Detect current GPU mode (dynamic binding design supports 3 states)
+      local gpu_mode="unknown"
+      if [[ -n "$configured_gpu_pci" ]]; then
+        local current_driver="$(get_pci_driver "$configured_gpu_pci")"
+        gpu_mode="$(detect_gpu_mode_from_driver "$current_driver")"
+      fi
+
+      case "$gpu_mode" in
+      none)
+        msg_success "Status: GPU in boot state (dynamic binding)"
+        echo ""
+        echo "GPU is reserved for VM and inactive (by design)."
+        msg_success "IOMMU enabled and configured"
+        msg_success "Kernel parameters active"
+        echo ""
+        echo "To use GPU:"
+        echo "  • For VM: omarchy-gpu-passthrough mode vm"
+        echo "  • For host (CUDA/compute): omarchy-gpu-passthrough mode host"
+        ;;
+      host)
+        msg_success "Status: GPU bound to native driver"
+        echo ""
+        echo "GPU is available for host use (CUDA/compute)."
+        msg_success "IOMMU enabled and configured"
+        msg_success "GPU bound to native driver"
+
+        # Check nvidia_drm for display output support (NVIDIA only)
+        if [[ "$current_driver" == "nvidia" ]]; then
+          if is_module_loaded nvidia_drm; then
+            local modeset_param="/sys/module/nvidia_drm/parameters/modeset"
+            local modeset_val=""
+            [[ -r "$modeset_param" ]] && modeset_val=$(<"$modeset_param")
+            # Kernel params can be Y/y/1 for enabled
+            if [[ "$modeset_val" =~ ^[Yy1]$ ]]; then
+              msg_success "nvidia_drm loaded with modeset=1 (display output ready)"
+            else
+              msg_warning "nvidia_drm loaded but modeset disabled (value: ${modeset_val:-unreadable})"
+              echo "  External displays may not work. Fix: re-run setup"
+            fi
+          else
+            msg_warning "nvidia_drm not loaded (external displays won't work)"
+            echo "  Fix: re-run 'omarchy-gpu-passthrough setup' then reboot"
+          fi
+        fi
+        echo ""
+        echo "To use GPU in VM:"
+        echo "  • Run: omarchy-gpu-passthrough mode vm"
+        ;;
+      *)
+        # Unknown state (shouldn't happen, but keep old message as fallback)
+        msg_warning "Status: Configured (GPU mode: $gpu_mode)"
+        echo ""
+        echo "Configuration exists. GPU not bound to vfio-pci."
+        echo "   Hint: Use 'omarchy-gpu-passthrough mode vm' to bind for VM"
+        echo "   Hint: Use 'omarchy-gpu-passthrough mode host' for host use"
+        ;;
+      esac
+    else
+      msg_error "Status: $total_errors issue(s) found"
+      echo ""
+      msg_info "Fix issues above and run: omarchy-gpu-passthrough info verify"
+    fi
+  fi
+
+  return $total_errors
+}
+
+cmd_diagnose() {
+  # Check sudo access - use -n first to avoid blocking in non-interactive contexts
+  local has_sudo=false
+  if [[ "$EUID" -eq 0 ]]; then
+    has_sudo=true
+  elif sudo -n true 2>/dev/null; then
+    has_sudo=true
+  else
+    # Interactive fallback - only prompt if terminal available
+    if [[ -t 0 ]]; then
+      msg_info "Full diagnostics requires sudo (for motherboard/BIOS info)"
+      if sudo -v 2>/dev/null; then
+        has_sudo=true
+      fi
+    fi
+  fi
+
+  if [[ "$has_sudo" != "true" ]]; then
+    msg_warning "Running diagnostics without sudo (some data will be incomplete)"
+  fi
+
+  msg_section "GPU Passthrough Diagnostics"
+
+  # Check and install dependencies if needed
+  check_dependencies
+
+  msg_info "Collecting system information..."
+
+  local output_file="/tmp/omarchy-gpu-passthrough-diagnostics-$(date +%Y%m%d_%H%M%S).txt"
+
+  {
+    echo "[GPU PASSTHROUGH DIAGNOSTICS REPORT]"
+    echo "Generated: $(date)"
+    echo "Hostname: $(hostname)"
+    echo ""
+
+    echo "[SYSTEM INFORMATION]"
+    echo ""
+
+    echo "[CPU]"
+    echo '```'
+    if [[ -f /proc/cpuinfo ]]; then
+      grep "model name" /proc/cpuinfo | head -1 | sed 's/model name\s*: //'
+      echo "CPU Vendor: $(get_cpu_vendor)"
+    fi
+    echo '```'
+    echo ""
+
+    echo "[Operating System]"
+    echo '```'
+    if command -v lsb_release &>/dev/null; then
+      lsb_release -d | sed 's/Description:\s*//'
+    fi
+    uname -r | sed 's/^/Kernel: /'
+    echo '```'
+    echo ""
+
+    echo "[Bootloader]"
+    echo '```'
+    echo "$(detect_bootloader)"
+    echo '```'
+    echo ""
+
+    echo "[Motherboard]"
+    echo '```'
+    if command -v dmidecode &>/dev/null && [[ "$has_sudo" == "true" ]]; then
+      local mobo_vendor=$(sudo -n dmidecode -t baseboard 2>/dev/null | grep "Manufacturer:" | cut -d: -f2 | xargs)
+      local mobo_model=$(sudo -n dmidecode -t baseboard 2>/dev/null | grep "Product Name:" | cut -d: -f2 | xargs)
+      local bios_version=$(sudo -n dmidecode -t bios 2>/dev/null | grep "Version:" | cut -d: -f2 | xargs)
+      echo "Vendor: ${mobo_vendor:-Unknown}"
+      echo "Model: ${mobo_model:-Unknown}"
+      [[ -n "$bios_version" ]] && echo "BIOS: $bios_version"
+    else
+      echo "(requires sudo for motherboard info)"
+    fi
+    echo '```'
+    echo ""
+
+    echo "[Display Session]"
+    echo '```'
+    echo "Session Type: ${XDG_SESSION_TYPE:-not set}"
+    echo "Wayland Display: ${WAYLAND_DISPLAY:-not set}"
+    echo "Desktop: ${XDG_CURRENT_DESKTOP:-not set}"
+    echo '```'
+    echo ""
+
+    echo "[System Memory]"
+    echo '```'
+    local mem_total_kb mem_available_kb mem_total_mb mem_available_mb
+    mem_total_kb=$(grep "^MemTotal:" /proc/meminfo 2>/dev/null | awk '{print $2}')
+    mem_available_kb=$(grep "^MemAvailable:" /proc/meminfo 2>/dev/null | awk '{print $2}')
+    mem_total_kb="${mem_total_kb:-0}"
+    mem_available_kb="${mem_available_kb:-0}"
+    mem_total_mb=$((mem_total_kb / 1024))
+    mem_available_mb=$((mem_available_kb / 1024))
+    if [[ "$mem_total_mb" -gt 0 ]]; then
+      echo "Total RAM: ${mem_total_mb} MB ($((mem_total_mb / 1024)) GB)"
+      echo "Available: ${mem_available_mb} MB ($((mem_available_mb / 1024)) GB)"
+    else
+      echo "(memory info not available)"
+    fi
+
+    # VM sizing recommendations (only if memory info available)
+    if [[ "$mem_total_mb" -gt 0 ]]; then
+      local recommended_vm_ram=$((mem_total_mb / 2))
+      local ivshmem_size=64
+      if [[ -f "$GPU_PASSTHROUGH_CONF" ]]; then
+        local conf_ivshmem
+        conf_ivshmem=$(grep "^IVSHMEM_SIZE=" "$GPU_PASSTHROUGH_CONF" 2>/dev/null | cut -d'"' -f2)
+        [[ -n "$conf_ivshmem" ]] && ivshmem_size="${conf_ivshmem%M}"
+      fi
+      echo ""
+      echo "VM Sizing Recommendations:"
+      echo "  Recommended VM RAM: ${recommended_vm_ram} MB (50% of total)"
+      echo "  IVSHMEM (Looking Glass): ${ivshmem_size} MB"
+      echo "  Host reserved: $((mem_total_mb - recommended_vm_ram - ivshmem_size)) MB"
+
+      # Warning if low memory
+      if [[ "$mem_total_mb" -lt 16384 ]]; then
+        echo ""
+        echo "⚠️  Less than 16GB RAM - VM performance may be limited"
+      fi
+    fi
+    echo '```'
+    echo ""
+
+    echo "[GPU INFORMATION]"
+    echo ""
+
+    detect_gpus
+
+    for i in "${!GPU_PCI_ADDR[@]}"; do
+      echo "[GPU $((i + 1)): ${GPU_NAME[$i]}]"
+      echo '```'
+      echo "PCI Address: ${GPU_PCI_ADDR[$i]}"
+      echo "Vendor:Device ID: ${GPU_VENDOR_ID[$i]}:${GPU_DEVICE_ID[$i]}"
+      echo "Type: ${GPU_TYPE[$i]}"
+      echo "Current Driver: ${GPU_DRIVER[$i]}"
+      if [[ -n "${GPU_AUDIO_ID[$i]:-}" ]]; then
+        local audio_pci="${GPU_PCI_ADDR[$i]%%.*}.1"
+        echo "Audio Device: $audio_pci"
+      fi
+
+      if [[ "${GPU_TYPE[$i]}" == "dedicated" ]]; then
+        local bar_mb=$(get_gpu_bar_size_mb "${GPU_PCI_ADDR[$i]}")
+        local bar_formatted=$(format_memory_size "$bar_mb")
+        [[ -n "$bar_formatted" ]] && echo "Largest BAR: $bar_formatted"
+        if check_resizable_bar "${GPU_PCI_ADDR[$i]}"; then
+          echo "Resizable BAR: Enabled"
+        else
+          echo "Resizable BAR: Disabled"
+        fi
+      fi
+
+      local gpu_drm_card=$(get_drm_card_for_pci "${GPU_PCI_ADDR[$i]}")
+      if [[ -n "$gpu_drm_card" ]]; then
+        echo "DRM Card: $gpu_drm_card"
+        echo "Display Connectors:"
+        local found_connectors=false
+        for connector in /sys/class/drm/${gpu_drm_card}-*/status; do
+          if [[ -f "$connector" ]]; then
+            found_connectors=true
+            local connector_name=$(basename "$(dirname "$connector")")
+            local connector_status=""
+            [[ -r "$connector" ]] && connector_status=$(<"$connector")
+            echo "  $connector_name: $connector_status"
+          fi
+        done
+        if [[ "$found_connectors" == "false" ]]; then
+          echo "  (no connectors found)"
+        fi
+      fi
+      echo '```'
+      echo ""
+    done
+
+    # GPU Classification Debug - shows how each GPU was classified
+    echo "[GPU Classification Debug]"
+    echo '```'
+    for i in "${!GPU_PCI_ADDR[@]}"; do
+      local name="${GPU_NAME[$i]}"
+      local vendor_id="${GPU_VENDOR_ID[$i]}"
+      local gpu_type="${GPU_TYPE[$i]}"
+      local name_lower="${name,,}"
+
+      # Shorten name for display
+      local short_name="${name//Advanced Micro Devices, Inc. /}"
+      short_name="${short_name//\[AMD\/ATI\] /}"
+      short_name="${short_name//Intel Corporation /}"
+      short_name="${short_name//NVIDIA Corporation /}"
+
+      echo "GPU $((i+1)): $short_name"
+      echo "  Result: $gpu_type"
+
+      # Show which pattern matched (extract just the keyword)
+      local matched_keyword="(none - default dedicated)"
+      if [[ "$vendor_id" == "8086" ]]; then
+        # Test each Intel keyword (sync with INTEL_IGPU_REGEX in utils)
+        for kw in uhd "hd graphics" iris "intel.*graphics" meteor lunar arrow panther; do
+          if [[ "$name_lower" =~ $kw ]]; then
+            matched_keyword="Intel iGPU pattern: '$kw'"
+            break
+          fi
+        done
+      elif [[ "$vendor_id" == "1002" ]]; then
+        # Test each AMD APU keyword (sync with AMD_APU_REGEX in utils)
+        for kw in "radeon [0-9]+m" "vega.*igpu" phoenix rembrandt cezanne renoir lucienne barcelo strix raphael hawk mendocino krackan; do
+          if [[ "$name_lower" =~ $kw ]]; then
+            matched_keyword="AMD APU pattern: '$kw'"
+            break
+          fi
+        done
+      fi
+      echo "  Matched: $matched_keyword"
+      echo ""
+    done
+    echo '```'
+    echo ""
+
+    # PCIe Link Status - shows current/max link speed and width
+    echo "[PCIe Link Status]"
+    echo '```'
+    for i in "${!GPU_PCI_ADDR[@]}"; do
+      local pci="${GPU_PCI_ADDR[$i]}"
+      local name="${GPU_NAME[$i]}"
+      local pci_full
+      pci_full=$(normalize_pci_addr "$pci") || pci_full="0000:${pci}"
+
+      # Shorten name
+      local short_name="${name//Advanced Micro Devices, Inc. /}"
+      short_name="${short_name//\[AMD\/ATI\] /}"
+      short_name="${short_name//Intel Corporation /}"
+      short_name="${short_name//NVIDIA Corporation /}"
+      short_name="${short_name:0:40}"
+
+      echo "GPU $((i+1)): $short_name ($pci)"
+
+      # Read link status from sysfs
+      local link_speed="" link_width="" max_speed="" max_width=""
+      local sysfs_path="/sys/bus/pci/devices/${pci_full}"
+
+      if [[ -r "$sysfs_path/current_link_speed" ]]; then
+        link_speed=$(<"$sysfs_path/current_link_speed")
+      fi
+      if [[ -r "$sysfs_path/current_link_width" ]]; then
+        link_width=$(<"$sysfs_path/current_link_width")
+      fi
+      if [[ -r "$sysfs_path/max_link_speed" ]]; then
+        max_speed=$(<"$sysfs_path/max_link_speed")
+      fi
+      if [[ -r "$sysfs_path/max_link_width" ]]; then
+        max_width=$(<"$sysfs_path/max_link_width")
+      fi
+
+      # Check for valid link info (not "Unknown" or "0")
+      local has_valid_link=false
+      if [[ -n "$link_speed" && "$link_speed" != "Unknown" && -n "$link_width" && "$link_width" != "0" ]]; then
+        has_valid_link=true
+      fi
+
+      if [[ "$has_valid_link" == "true" ]]; then
+        local status_icon="✓"
+        # Check if running at max speed/width
+        if [[ -n "$max_speed" && -n "$max_width" && ( "$link_speed" != "$max_speed" || "$link_width" != "$max_width" ) ]]; then
+          status_icon="⚠️"
+        fi
+        echo "  Current: ${link_speed} x${link_width} $status_icon"
+        [[ -n "$max_speed" && "$max_speed" != "Unknown" && -n "$max_width" && "$max_width" != "0" ]] && \
+          echo "  Maximum: ${max_speed} x${max_width}"
+      else
+        # Try lspci as fallback
+        local lspci_link
+        lspci_link=$(lspci -vvs "$pci" 2>/dev/null | grep -i "LnkSta:" | head -1 | sed 's/^[[:space:]]*//')
+        if [[ -n "$lspci_link" ]]; then
+          echo "  $lspci_link"
+        else
+          # Integrated GPU or no PCIe link
+          local gpu_type="${GPU_TYPE[$i]}"
+          if [[ "$gpu_type" == "integrated" ]]; then
+            echo "  N/A (integrated GPU - no PCIe link)"
+          else
+            echo "  (link info not available)"
+          fi
+        fi
+      fi
+      echo ""
+    done
+    echo '```'
+    echo ""
+
+    echo "[IOMMU INFORMATION]"
+    echo '```'
+    if [[ -d /sys/class/iommu ]]; then
+      echo "IOMMU Status: Enabled"
+      echo "IOMMU Devices: $(ls -1 /sys/class/iommu | wc -l)"
+    else
+      echo "IOMMU Status: Disabled or not available"
+    fi
+
+    if [[ -d /dev/vfio ]]; then
+      local iommu_groups=$(find /dev/vfio/ -maxdepth 1 -type c -name '[0-9]*' 2>/dev/null | wc -l)
+      echo "Active VFIO IOMMU Groups: $iommu_groups"
+    else
+      echo "VFIO not available"
+    fi
+    echo '```'
+    echo ""
+
+    for i in "${!GPU_PCI_ADDR[@]}"; do
+      local pci="${GPU_PCI_ADDR[$i]}"
+      local iommu_group=$(get_iommu_group "$pci")
+      if [[ -n "$iommu_group" && "$iommu_group" != "unknown" ]]; then
+        echo "[GPU $((i+1)): ${GPU_NAME[$i]} - IOMMU Group $iommu_group]"
+        echo '```'
+        echo "PCI Address: $pci"
+        local iommu_group_path="/sys/kernel/iommu_groups/${iommu_group}/devices"
+        if [[ -d "$iommu_group_path" ]]; then
+          local device_count=$(ls -1 "$iommu_group_path" 2>/dev/null | wc -l)
+          echo "Devices in group ($device_count):"
+          for dev_path in "$iommu_group_path"/*; do
+            if [[ -d "$dev_path" ]]; then
+              local dev_addr=$(basename "$dev_path")
+              local dev_addr_short="${dev_addr#0000:}"
+              local dev_info=$(lspci -nns "$dev_addr_short" 2>/dev/null)
+              if [[ -n "$dev_info" ]]; then
+                echo "  $dev_info"
+              else
+                echo "  $dev_addr_short (unknown)"
+              fi
+            fi
+          done
+        fi
+        echo '```'
+        echo ""
+      fi
+    done
+
+    echo "[KERNEL CONFIGURATION]"
+    echo ""
+
+    echo "[Kernel Command Line]"
+    echo '```'
+    cat /proc/cmdline
+    echo '```'
+    echo ""
+
+    echo "[IOMMU Parameters]"
+    echo '```'
+    if grep -qE "amd_iommu=on|intel_iommu=on" /proc/cmdline; then
+      grep -oE "(amd_iommu|intel_iommu)=[^ ]+" /proc/cmdline || echo "(enabled)"
+      echo "Status: ✓ Enabled"
+    else
+      echo "Status: ✗ Not found in kernel cmdline"
+    fi
+    if grep -q "iommu=pt" /proc/cmdline; then
+      echo "iommu=pt: ✓ Enabled"
+    else
+      echo "iommu=pt: ✗ Not found"
+    fi
+    echo '```'
+    echo ""
+
+    echo "[LOADED KERNEL MODULES]"
+    echo ""
+
+    echo "[VFIO Modules]"
+    echo '```'
+    lsmod | grep "^vfio" || echo "None loaded"
+    echo '```'
+    echo ""
+
+    echo "[NVIDIA Modules]"
+    echo '```'
+    lsmod | grep "^nvidia" || echo "None loaded"
+    local modeset_param="/sys/module/nvidia_drm/parameters/modeset"
+    if [[ -r "$modeset_param" ]]; then
+      echo "nvidia_drm modeset: $(<"$modeset_param")"
+    fi
+    echo '```'
+    echo ""
+
+    echo "[AMD GPU Modules]"
+    echo '```'
+    lsmod | grep "^amdgpu" || echo "None loaded"
+    echo '```'
+    echo ""
+
+    echo "[DRIVER VERSIONS]"
+    echo ""
+
+    echo "[NVIDIA Driver]"
+    echo '```'
+    if is_module_loaded nvidia; then
+      local nvidia_version=""
+      [[ -r /proc/driver/nvidia/version ]] && nvidia_version=$(head -1 /proc/driver/nvidia/version 2>/dev/null)
+      if [[ -n "$nvidia_version" ]]; then
+        echo "$nvidia_version"
+      elif command -v nvidia-smi &>/dev/null; then
+        nvidia-smi --query-gpu=driver_version --format=csv,noheader 2>/dev/null | head -1 | awk '{print "NVIDIA Driver Version: " $1}'
+      else
+        echo "Version info not available"
+      fi
+    else
+      echo "Not loaded"
+    fi
+    echo '```'
+    echo ""
+
+    echo "[AMD GPU Driver]"
+    echo '```'
+    if is_module_loaded amdgpu; then
+      local amdgpu_version=$(modinfo amdgpu 2>/dev/null | grep "^version:" | awk '{print $2}')
+      if [[ -n "$amdgpu_version" ]]; then
+        echo "Kernel module version: $amdgpu_version"
+      fi
+      if command -v glxinfo &>/dev/null; then
+        local mesa_version=$(glxinfo 2>/dev/null | grep "OpenGL version" | cut -d: -f2 | xargs)
+        [[ -n "$mesa_version" ]] && echo "Mesa/OpenGL: $mesa_version"
+      fi
+      if command -v vulkaninfo &>/dev/null; then
+        local vulkan_info
+        vulkan_info=$(vulkaninfo --summary 2>/dev/null | grep -A2 "vendorID.*0x1002" | grep "driverInfo" | head -1)
+        [[ -n "$vulkan_info" ]] && echo "Vulkan: $(echo "$vulkan_info" | cut -d= -f2 | xargs)"
+      fi
+    else
+      echo "Not loaded"
+    fi
+    echo '```'
+    echo ""
+
+    echo "[GPU Runtime Stats]"
+    echo '```'
+    for i in "${!GPU_PCI_ADDR[@]}"; do
+      local pci="${GPU_PCI_ADDR[$i]}"
+      local vendor_id="${GPU_VENDOR_ID[$i]}"
+      local name="${GPU_NAME[$i]}"
+      local driver="${GPU_DRIVER[$i]}"
+
+      # Shorten name
+      local short_name="${name//Advanced Micro Devices, Inc. /}"
+      short_name="${short_name//\[AMD\/ATI\] /}"
+      short_name="${short_name//Intel Corporation /}"
+      short_name="${short_name//NVIDIA Corporation /}"
+
+      # AMD GPUs with amdgpu driver
+      if [[ "$vendor_id" == "1002" && "$driver" == "amdgpu" ]]; then
+        echo "--- $short_name ($pci) [AMD] ---"
+
+        local stats_output
+        if stats_output=$(get_amd_gpu_stats "$pci" 2>/dev/null); then
+          eval "$stats_output"
+          [[ "$vram_total_mb" -gt 0 ]] && echo "VRAM: ${vram_used_mb}MB / ${vram_total_mb}MB ($((vram_used_mb * 100 / vram_total_mb))%)"
+          [[ "$gtt_total_mb" -gt 0 ]] && echo "GTT:  ${gtt_used_mb}MB / ${gtt_total_mb}MB"
+          [[ "$temp_c" -gt 0 ]] && echo "Temp: ${temp_c}°C"
+          [[ "$power_w" -gt 0 ]] && echo "Power: ${power_w}W"
+          [[ "$fan_rpm" -gt 0 ]] && echo "Fan: ${fan_rpm} RPM"
+          [[ -n "$vbios" ]] && echo "VBIOS: $vbios"
+          [[ -n "$gpu_clock_mhz" ]] && echo "GPU Clock: ${gpu_clock_mhz} MHz"
+          [[ -n "$mem_clock_mhz" ]] && echo "Mem Clock: ${mem_clock_mhz} MHz"
+        else
+          echo "(stats not available - GPU may be on vfio-pci)"
+        fi
+        echo ""
+
+      # Intel GPUs (i915 for legacy, xe for Arc)
+      elif [[ "$vendor_id" == "8086" && ( "$driver" == "i915" || "$driver" == "xe" ) ]]; then
+        echo "--- $short_name ($pci) [Intel] ---"
+
+        local stats_output
+        if stats_output=$(get_intel_gpu_stats "$pci" 2>/dev/null); then
+          eval "$stats_output"
+          if [[ "$gpu_freq_mhz" -gt 0 ]]; then
+            if [[ "$gpu_freq_max_mhz" -gt 0 ]]; then
+              echo "GPU Clock: ${gpu_freq_mhz} MHz (range: ${gpu_freq_min_mhz}-${gpu_freq_max_mhz} MHz)"
+            else
+              echo "GPU Clock: ${gpu_freq_mhz} MHz"
+            fi
+          fi
+          [[ "$temp_c" -gt 0 ]] && echo "Temp: ${temp_c}°C"
+          [[ "$power_w" -gt 0 ]] && echo "Power: ${power_w}W"
+          echo "Memory: Shared (system RAM)"
+        else
+          echo "(stats not available)"
+        fi
+        echo ""
+
+      # NVIDIA GPUs
+      elif [[ "$vendor_id" == "10de" && "$driver" == "nvidia" ]]; then
+        echo "--- $short_name ($pci) [NVIDIA] ---"
+
+        local stats_output
+        if stats_output=$(get_nvidia_gpu_stats "$pci" 2>/dev/null); then
+          eval "$stats_output"
+          [[ "$vram_total_mb" -gt 0 ]] && echo "VRAM: ${vram_used_mb}MB / ${vram_total_mb}MB ($((vram_used_mb * 100 / vram_total_mb))%)"
+          [[ "$temp_c" -gt 0 ]] && echo "Temp: ${temp_c}°C"
+          [[ "$power_w" -gt 0 ]] && echo "Power: ${power_w}W"
+          [[ "$gpu_clock_mhz" -gt 0 ]] && echo "GPU Clock: ${gpu_clock_mhz} MHz"
+          [[ "$mem_clock_mhz" -gt 0 ]] && echo "Mem Clock: ${mem_clock_mhz} MHz"
+          [[ -n "$vbios" ]] && echo "VBIOS: $vbios"
+        else
+          echo "(nvidia-smi not available)"
+        fi
+        echo ""
+      fi
+    done
+    echo '```'
+    echo ""
+
+    echo "[VFIO Driver]"
+    echo '```'
+    if is_module_loaded vfio_pci; then
+      local vfio_version=$(modinfo vfio_pci 2>/dev/null | grep "^version:" | awk '{print $2}')
+      if [[ -n "$vfio_version" ]]; then
+        echo "Kernel module version: $vfio_version"
+      else
+        echo "Version: Built-in (kernel $(uname -r))"
+      fi
+    else
+      echo "Not loaded"
+    fi
+    echo '```'
+    echo ""
+
+    echo "[DRM Devices]"
+    echo '```'
+    if [[ -d /sys/class/drm ]]; then
+      ls -la /sys/class/drm/ 2>/dev/null | grep "card[0-9]" | head -10
+      echo ""
+      for card_link in /sys/class/drm/card[0-9]*; do
+        [[ -d "$card_link" ]] || continue
+        [[ "$card_link" =~ card[0-9]+-. ]] && continue
+        local card_name=$(basename "$card_link")
+        local pci_path=$(readlink -f "$card_link/device" 2>/dev/null)
+        local pci_addr="${pci_path:+$(basename "$pci_path")}"
+        local driver=$(basename "$(readlink -f "$card_link/device/driver" 2>/dev/null)" 2>/dev/null)
+        echo "$card_name → PCI: ${pci_addr:-unknown}, Driver: ${driver:-none}"
+      done
+    else
+      echo "No DRM devices found"
+    fi
+    echo '```'
+    echo ""
+
+    echo "[GPU PASSTHROUGH CONFIGURATION]"
+    echo ""
+
+    if [[ -f "$GPU_PASSTHROUGH_CONF" ]]; then
+      echo "[GPU Configuration: $GPU_PASSTHROUGH_CONF]"
+      echo '```'
+      cat "$GPU_PASSTHROUGH_CONF"
+      echo '```'
+      echo ""
+
+      # Config validation debug - shows exactly which step fails
+      echo "[Config Validation Status]"
+      echo '```'
+      local val_file_exists=false val_owner_ok=false val_perms_ok=false
+      local val_format_ok=false val_security_ok=false val_pci_ok=false
+      local val_gpu_pci_set=false val_load_ok=false
+      local file_owner file_perms
+
+      # Step 1: File exists
+      if [[ -f "$GPU_PASSTHROUGH_CONF" ]]; then
+        val_file_exists=true
+        echo "✓ File exists"
+      else
+        echo "✗ File does not exist"
+      fi
+
+      # Step 2: Owner is root
+      if [[ "$val_file_exists" == "true" ]]; then
+        file_owner=$(stat -c "%U" "$GPU_PASSTHROUGH_CONF" 2>/dev/null)
+        if [[ "$file_owner" == "root" ]]; then
+          val_owner_ok=true
+          echo "✓ Owner is root"
+        else
+          echo "✗ Owner is '$file_owner' (expected: root)"
+        fi
+      fi
+
+      # Step 3: Permissions
+      if [[ "$val_file_exists" == "true" ]]; then
+        file_perms=$(stat -c "%a" "$GPU_PASSTHROUGH_CONF" 2>/dev/null)
+        if [[ "$file_perms" == "644" || "$file_perms" == "600" ]]; then
+          val_perms_ok=true
+          echo "✓ Permissions $file_perms"
+        else
+          echo "✗ Permissions $file_perms (expected: 644 or 600)"
+        fi
+      fi
+
+      # Step 4: Line format validation
+      if [[ "$val_file_exists" == "true" ]]; then
+        local bad_lines
+        bad_lines=$(grep -vE '^\s*(#|$)' "$GPU_PASSTHROUGH_CONF" | grep -vE '^[A-Z_]+="[^"]*"$' | head -3)
+        if [[ -z "$bad_lines" ]]; then
+          val_format_ok=true
+          echo "✓ Line format valid"
+        else
+          echo "✗ Invalid line format:"
+          echo "$bad_lines" | sed 's/^/    /'
+        fi
+      fi
+
+      # Step 5: Security check (no malicious content)
+      # Must match load_gpu_config() validation exactly
+      if [[ "$val_file_exists" == "true" ]]; then
+        local bad_line=""
+        # Check for command injection patterns (anywhere in file)
+        bad_line=$(grep -E '`|\$\(|\$\{|;|\||&|<|>|\bexec\b|\beval\b|\bsource\b' "$GPU_PASSTHROUGH_CONF" 2>/dev/null | head -1)
+        if [[ -n "$bad_line" ]]; then
+          echo "✗ Dangerous pattern found:"
+          echo "    $bad_line"
+        else
+          # Check for `. script` source shorthand (only at line start)
+          bad_line=$(grep -E '^\s*\.\s+' "$GPU_PASSTHROUGH_CONF" 2>/dev/null | head -1)
+          if [[ -n "$bad_line" ]]; then
+            echo "✗ Source shorthand found:"
+            echo "    $bad_line"
+          else
+            val_security_ok=true
+            echo "✓ No suspicious content"
+          fi
+        fi
+      fi
+
+      # Step 6: GPU_PCI_ADDR present and valid
+      if [[ "$val_file_exists" == "true" && "$val_format_ok" == "true" && "$val_security_ok" == "true" ]]; then
+        local conf_gpu_pci
+        conf_gpu_pci=$(grep "^GPU_PCI_ADDR=" "$GPU_PASSTHROUGH_CONF" 2>/dev/null | cut -d'"' -f2)
+        if [[ -n "$conf_gpu_pci" ]]; then
+          val_gpu_pci_set=true
+          echo "✓ GPU_PCI_ADDR set: $conf_gpu_pci"
+          # Validate format
+          if [[ "$conf_gpu_pci" =~ ^([0-9a-fA-F]{4}:)?[0-9a-fA-F]{2}:[0-9a-fA-F]{2}\.[0-7]$ ]]; then
+            val_pci_ok=true
+            echo "✓ PCI address format valid"
+          else
+            echo "✗ PCI address format invalid"
+          fi
+        else
+          echo "✗ GPU_PCI_ADDR is empty or missing"
+        fi
+      fi
+
+      # Step 7: Full load test
+      echo ""
+      if load_gpu_config 2>/dev/null; then
+        val_load_ok=true
+        echo "✓ load_gpu_config() SUCCESS"
+        echo "  Loaded: GPU_PCI_ADDR=$GPU_PCI_ADDR"
+        [[ -n "${GPU_VENDOR_ID:-}" ]] && echo "  Loaded: GPU_VENDOR_ID=$GPU_VENDOR_ID"
+        [[ -n "${IGPU_PCI:-}" ]] && echo "  Loaded: IGPU_PCI=$IGPU_PCI"
+        [[ -n "${DGPU_PCI:-}" ]] && echo "  Loaded: DGPU_PCI=$DGPU_PCI"
+        [[ -n "${IS_MUXLESS_LAPTOP:-}" ]] && echo "  Loaded: IS_MUXLESS_LAPTOP=$IS_MUXLESS_LAPTOP"
+      else
+        echo "✗ load_gpu_config() FAILED"
+        echo "  This is why 'mode vm' reports 'not configured'"
+      fi
+      echo '```'
+      echo ""
+    else
+      echo "GPU passthrough not configured (run: omarchy-gpu-passthrough setup)"
+      echo ""
+    fi
+
+    # State Marker Debug - shows runtime mode status
+    echo "[State Marker Status]"
+    echo '```'
+    local state_marker="/var/run/omarchy-vm-gpu-mode"
+    local lock_file="/run/user/${UID:-$(id -u)}/omarchy-gpu-mode.lock"
+
+    echo "Mode marker: $state_marker"
+    if [[ -f "$state_marker" ]]; then
+      local marker_content marker_age_sec age_str
+      marker_content=$(<"$state_marker")
+      marker_age_sec=$(( $(date +%s) - $(stat -c %Y "$state_marker" 2>/dev/null || echo 0) ))
+
+      # Format age
+      if [[ "$marker_age_sec" -lt 60 ]]; then
+        age_str="${marker_age_sec}s ago"
+      elif [[ "$marker_age_sec" -lt 3600 ]]; then
+        age_str="$((marker_age_sec / 60))m ago"
+      else
+        age_str="$((marker_age_sec / 3600))h ago"
+      fi
+
+      # Validate and display
+      if [[ "$marker_content" =~ ^(none|vm|host)$ ]]; then
+        echo "  Value: $marker_content ($age_str) ✓"
+      else
+        echo "  Value: $marker_content ($age_str) ⚠️  Invalid!"
+      fi
+    else
+      echo "  Not present (created by 'mode vm/host')"
+    fi
+
+    # Lock status - only show if locked (unusual)
+    if [[ -f "$lock_file" ]] && ! flock -n "$lock_file" true 2>/dev/null; then
+      echo "Lock: ⚠️  Currently held (operation in progress)"
+    fi
+    echo '```'
+    echo ""
+
+    local bootloader=$(detect_bootloader)
+    echo "[Bootloader Configuration: $bootloader]"
+    echo '```'
+    case "$bootloader" in
+      limine)
+        if [[ -f "$LIMINE_DEFAULT" ]]; then
+          grep "^KERNEL_CMDLINE" "$LIMINE_DEFAULT" || echo "No KERNEL_CMDLINE entries found"
+        else
+          echo "$LIMINE_DEFAULT not found"
+        fi
+        ;;
+      grub)
+        if [[ -f "$GRUB_DEFAULT" ]]; then
+          grep "^GRUB_CMDLINE_LINUX" "$GRUB_DEFAULT" || echo "No GRUB_CMDLINE entries found"
+        else
+          echo "$GRUB_DEFAULT not found"
+        fi
+        ;;
+      systemd-boot)
+        local found_entries=false
+        for entry in /boot/loader/entries/*.conf; do
+          [[ -f "$entry" ]] || continue
+          found_entries=true
+          echo "--- $(basename "$entry") ---"
+          grep -E "^options" "$entry" || echo "No options line"
+        done
+        [[ "$found_entries" == "false" ]] && echo "No entry files found in /boot/loader/entries/"
+        ;;
+      refind)
+        if [[ -f /boot/refind_linux.conf ]]; then
+          cat /boot/refind_linux.conf
+        else
+          echo "refind_linux.conf not found"
+        fi
+        ;;
+      *)
+        echo "Unknown bootloader - check /proc/cmdline manually"
+        ;;
+    esac
+    echo '```'
+    echo ""
+
+    if [[ -f "$VFIO_CONF" ]]; then
+      echo "[VFIO Configuration: $VFIO_CONF]"
+      echo '```'
+      cat "$VFIO_CONF"
+      echo '```'
+      echo ""
+    else
+      echo "VFIO configuration not found"
+      echo ""
+    fi
+
+    if [[ -f "$BLACKLIST_CONF" ]]; then
+      echo "[Driver Blacklist: $BLACKLIST_CONF]"
+      echo '```'
+      cat "$BLACKLIST_CONF"
+      echo '```'
+      echo ""
+    else
+      echo "No driver blacklist configured"
+      echo ""
+    fi
+
+    if [[ -f "$KVM_CONF" ]]; then
+      echo "[KVM Options: $KVM_CONF]"
+      echo '```'
+      cat "$KVM_CONF"
+      echo '```'
+      echo ""
+    else
+      echo "No KVM options configured"
+      echo ""
+    fi
+
+    if [[ -f /etc/mkinitcpio.conf ]]; then
+      echo "[Initramfs Configuration: /etc/mkinitcpio.conf]"
+      echo "(MODULES and HOOKS lines only)"
+      echo '```'
+      grep -E "^MODULES=|^HOOKS=" /etc/mkinitcpio.conf || echo "No MODULES/HOOKS found"
+      echo '```'
+      echo ""
+      # Check if modconf hook is present (required for softdep to work)
+      local hooks_line
+      hooks_line=$(grep "^HOOKS=" /etc/mkinitcpio.conf 2>/dev/null | head -1)
+      if [[ -n "$hooks_line" ]] && [[ ! "$hooks_line" =~ modconf ]]; then
+        echo "⚠️  WARNING: modconf hook missing from HOOKS!"
+        echo "   softdep in /etc/modprobe.d/ will NOT work without modconf"
+        echo ""
+      fi
+    else
+      echo "mkinitcpio not found"
+      echo ""
+    fi
+
+    echo "[USB CONTROLLER DIAGNOSTICS]"
+    echo ""
+
+    # Check udev rule for USB controller override
+    local usb_udev_rule="/etc/udev/rules.d/99-vfio-usb-override.rules"
+    echo "[USB Controller udev Rule: $usb_udev_rule]"
+    if [[ -f "$usb_udev_rule" ]]; then
+      echo '```'
+      cat "$usb_udev_rule"
+      echo '```'
+    else
+      echo "Not configured (may cause xhci_hcd rebind issues)"
+    fi
+    echo ""
+
+    echo "[xhci_hcd Module Status]"
+    echo '```'
+    if grep -q "^xhci_hcd" /proc/modules 2>/dev/null; then
+      echo "xhci_hcd: Loaded as MODULE"
+      lsmod | grep xhci | head -5
+    elif grep -q "xhci_hcd" /lib/modules/$(uname -r)/modules.builtin 2>/dev/null; then
+      echo "xhci_hcd: BUILT-IN to kernel (softdep won't work!)"
+    else
+      echo "xhci_hcd: Status unknown"
+    fi
+    echo '```'
+    echo ""
+
+    echo "[softdep Configuration]"
+    echo '```'
+    local has_xhci_softdep=false
+    local has_nvidia_softdep=false
+    local is_nvidia_gpu=false
+
+    # Check if any GPU is NVIDIA
+    for vendor in "${GPU_VENDOR_ID[@]}"; do
+      [[ "$vendor" == "10de" ]] && is_nvidia_gpu=true && break
+    done
+
+    if [[ -f "$VFIO_CONF" ]]; then
+      grep -q "softdep xhci" "$VFIO_CONF" && has_xhci_softdep=true
+      grep -q "softdep nvidia pre: vfio-pci" "$VFIO_CONF" && has_nvidia_softdep=true
+      grep "softdep" "$VFIO_CONF" 2>/dev/null || echo "(no softdep entries)"
+    else
+      echo "(vfio.conf not found)"
+    fi
+
+    echo ""
+    echo "USB (xhci_pci): $( [[ "$has_xhci_softdep" == "true" ]] && echo "✓ Configured" || echo "✗ Not configured" )"
+    if [[ "$is_nvidia_gpu" == "true" ]]; then
+      echo "NVIDIA modules: $( [[ "$has_nvidia_softdep" == "true" ]] && echo "✓ Configured" || echo "✗ MISSING - nvidia may load before vfio-pci!" )"
+    fi
+    echo '```'
+    echo ""
+
+    echo "[USB Controllers in GPU IOMMU Groups]"
+    echo '```'
+    local found_usb=false
+    for i in "${!GPU_PCI_ADDR[@]}"; do
+      local pci="${GPU_PCI_ADDR[$i]}"
+      local pci_full
+      pci_full=$(normalize_pci_addr "$pci") || continue
+
+      local iommu_group_path=$(readlink -f "/sys/bus/pci/devices/${pci_full}/iommu_group" 2>/dev/null)
+      if [[ -d "$iommu_group_path/devices" ]]; then
+        for dev_path in "$iommu_group_path/devices"/*; do
+          if [[ -d "$dev_path" ]]; then
+            local dev_addr=$(basename "$dev_path")
+            local dev_class=$(get_pci_class "${dev_addr#0000:}")
+            if [[ "$dev_class" == "0c03" ]]; then
+              found_usb=true
+              local dev_addr_short="${dev_addr#0000:}"
+              echo "GPU: ${GPU_NAME[$i]} (${GPU_PCI_ADDR[$i]})"
+              echo "USB Controller: $dev_addr_short"
+              lspci -nnk -s "$dev_addr_short" 2>/dev/null | sed 's/^/  /'
+              local override_file="/sys/bus/pci/devices/${dev_addr}/driver_override"
+              if [[ -r "$override_file" ]]; then
+                local override_value=""
+                override_value=$(<"$override_file") 2>/dev/null
+                if [[ -n "$override_value" ]]; then
+                  echo "  driver_override: $override_value"
+                else
+                  echo "  driver_override: (empty)"
+                fi
+              fi
+              echo ""
+            fi
+          fi
+        done
+      fi
+    done
+    if [[ "$found_usb" == "false" ]]; then
+      echo "No USB controllers found in GPU IOMMU groups"
+    fi
+    echo '```'
+    echo ""
+
+    echo "[vfio-pci ids= Configuration]"
+    echo '```'
+    if [[ -f "$VFIO_CONF" ]] && grep -q "^options vfio-pci ids=" "$VFIO_CONF"; then
+      grep "^options vfio-pci ids=" "$VFIO_CONF"
+      echo "Status: ✓ USB controller IDs configured for early binding"
+    else
+      echo "Status: ✗ No ids= line (USB controllers may not bind to vfio-pci at boot)"
+    fi
+    echo '```'
+    echo ""
+
+    if [[ -f /etc/environment ]]; then
+      echo "[System Environment (/etc/environment)]"
+      echo "(GPU-related variables only)"
+      echo '```'
+      grep -E "AQ_DRM_DEVICES|WLR_DRM_DEVICES|CUDA" /etc/environment 2>/dev/null || echo "No GPU-related variables found"
+      echo '```'
+      echo ""
+    fi
+
+    echo "[PERSISTENT VFIO STATUS]"
+    echo '```'
+    if [[ -f "$GPU_PASSTHROUGH_CONF" ]] && load_gpu_config 2>/dev/null; then
+      if is_persistent_vfio_enabled "$GPU_PCI_ADDR" "$GPU_VENDOR_ID" "$GPU_DEVICE_ID" 2>/dev/null; then
+        echo "Persistent VFIO: ✓ Enabled"
+        echo "  GPU stays bound to vfio-pci across reboots"
+        local vfio_service="/etc/systemd/system/vfio-late-bind-gpu.service"
+        [[ -f "$vfio_service" ]] && echo "  Service: $vfio_service"
+      else
+        echo "Persistent VFIO: ✗ Disabled (standard mode)"
+        echo "  GPU unbound on each boot, requires 'mode vm' before VM"
+      fi
+    else
+      echo "Persistent VFIO: N/A (not configured)"
+    fi
+    echo '```'
+    echo ""
+
+    echo "[GPU HEALTH CHECK]"
+    echo '```'
+    if [[ -f "$GPU_PASSTHROUGH_CONF" ]] && load_gpu_config 2>/dev/null; then
+      local pci_full
+      pci_full=$(normalize_pci_addr "$GPU_PCI_ADDR") || pci_full="0000:${GPU_PCI_ADDR}"
+      local iotlb_error
+      iotlb_error=$(journalctl -k -b --no-pager 2>/dev/null | grep -i "IOTLB_INV_TIMEOUT" | grep -i "$GPU_PCI_ADDR\|$pci_full" | tail -1)
+      if [[ -n "$iotlb_error" ]]; then
+        echo "IOTLB Status: ⚠️  IOTLB_INV_TIMEOUT detected"
+        echo "  This indicates GPU reset failure. Cold boot required:"
+        echo "  1. sudo poweroff"
+        echo "  2. Unplug power for 30 seconds"
+        echo "  3. Power on"
+      else
+        echo "IOTLB Status: ✓ No errors detected"
+      fi
+      # Check if GPU has AMD reset bug
+      if gpu_has_reset_bug "$GPU_DEVICE_ID" 2>/dev/null; then
+        echo "AMD Reset Bug: ⚠️  This GPU (${GPU_DEVICE_ID}) has known reset issues"
+        echo "  Consider: omarchy-gpu-passthrough mode persistent enable"
+      fi
+    else
+      echo "GPU Health: N/A (not configured)"
+    fi
+    echo '```'
+    echo ""
+
+    echo "[CPU TOPOLOGY]"
+    echo '```'
+    local threads_per_core cores_per_socket sockets
+    threads_per_core=$(lscpu 2>/dev/null | grep "Thread(s) per core:" | awk '{print $NF}')
+    cores_per_socket=$(lscpu 2>/dev/null | grep "Core(s) per socket:" | awk '{print $NF}')
+    sockets=$(lscpu 2>/dev/null | grep "Socket(s):" | awk '{print $NF}')
+    local total_cores=$((cores_per_socket * sockets))
+    local total_threads=$((total_cores * threads_per_core))
+    echo "Sockets: ${sockets:-?}"
+    echo "Cores per socket: ${cores_per_socket:-?}"
+    echo "Threads per core: ${threads_per_core:-?} (SMT: $( [[ "${threads_per_core:-1}" -ge 2 ]] && echo "enabled" || echo "disabled" ))"
+    echo "Total: $total_cores cores, $total_threads threads"
+    echo '```'
+    echo ""
+
+    echo "[SUDO/PERMISSIONS CHECK]"
+    echo '```'
+    echo "Current user: $(whoami) (UID: $EUID)"
+    # Check groups
+    local user_groups=$(groups 2>/dev/null)
+    echo "Groups: $user_groups"
+    # Check for important groups (use word boundaries to avoid false positives)
+    local missing_groups=""
+    [[ ! " $user_groups " =~ " kvm " ]] && missing_groups+="kvm "
+    [[ ! " $user_groups " =~ " libvirt " ]] && missing_groups+="libvirt "
+    [[ ! " $user_groups " =~ " input " ]] && missing_groups+="input "
+    if [[ -n "$missing_groups" ]]; then
+      echo "⚠️  Missing groups: $missing_groups"
+      echo "   Run: sudo usermod -aG kvm,libvirt,input $(whoami)"
+    else
+      echo "✓ User in required groups (kvm, libvirt, input)"
+    fi
+    # Check sudo access
+    if [[ "$EUID" -eq 0 ]]; then
+      echo "✓ Running as root"
+    elif sudo -n true 2>/dev/null; then
+      echo "✓ Passwordless sudo available"
+    else
+      echo "ℹ️  Sudo requires password (normal)"
+    fi
+    # Check /dev/kvm access
+    if [[ -c /dev/kvm ]]; then
+      if [[ -r /dev/kvm ]] && [[ -w /dev/kvm ]]; then
+        echo "✓ /dev/kvm accessible"
+      else
+        echo "⚠️  /dev/kvm not accessible - check kvm group membership"
+      fi
+    else
+      echo "⚠️  /dev/kvm not found - KVM not available"
+    fi
+    # Check /dev/vfio access
+    if [[ -d /dev/vfio ]]; then
+      local vfio_accessible=true
+      for vfio_dev in /dev/vfio/*; do
+        [[ -e "$vfio_dev" ]] || continue
+        if ! [[ -r "$vfio_dev" ]] || ! [[ -w "$vfio_dev" ]]; then
+          vfio_accessible=false
+          break
+        fi
+      done
+      if [[ "$vfio_accessible" == "true" ]]; then
+        echo "✓ /dev/vfio/* accessible"
+      else
+        echo "⚠️  /dev/vfio/* not accessible - may need udev rules"
+      fi
+    fi
+    echo '```'
+    echo ""
+
+    # UWSM Configuration (MUX-less laptops)
+    local uwsm_env="$HOME/.config/uwsm/env"
+    local uwsm_env_hyprland="$HOME/.config/uwsm/env-hyprland"
+    if [[ -f "$uwsm_env" ]] || [[ -f "$uwsm_env_hyprland" ]]; then
+      echo "[UWSM CONFIGURATION]"
+      echo "(MUX-less laptop EGL/DRM isolation)"
+      if [[ -f "$uwsm_env" ]]; then
+        echo "[UWSM env: $uwsm_env]"
+        echo '```'
+        cat "$uwsm_env"
+        echo '```'
+      fi
+      if [[ -f "$uwsm_env_hyprland" ]]; then
+        echo "[UWSM env-hyprland: $uwsm_env_hyprland]"
+        echo '```'
+        cat "$uwsm_env_hyprland"
+        echo '```'
+      fi
+      echo ""
+    fi
+
+    # Looking Glass Status
+    echo "[LOOKING GLASS STATUS]"
+    echo '```'
+
+    # KVMFR module
+    local kvmfr_status="✗ Not loaded"
+    if lsmod | grep -q "^kvmfr"; then
+      local kvmfr_version
+      kvmfr_version=$(modinfo kvmfr 2>/dev/null | grep "^version:" | awk '{print $2}')
+      kvmfr_status="✓ Loaded${kvmfr_version:+ (v$kvmfr_version)}"
+    fi
+    echo "KVMFR Module:  $kvmfr_status"
+
+    # /dev/kvmfr0
+    local kvmfr_dev_status="Not present (created on VM start)"
+    if [[ -c /dev/kvmfr0 ]]; then
+      local kvmfr_perms
+      kvmfr_perms=$(stat -c "%a" /dev/kvmfr0 2>/dev/null)
+      if [[ -r /dev/kvmfr0 ]] && [[ -w /dev/kvmfr0 ]]; then
+        kvmfr_dev_status="✓ Accessible (mode $kvmfr_perms)"
+      else
+        kvmfr_dev_status="⚠️  Not accessible (mode $kvmfr_perms)"
+      fi
+    fi
+    echo "/dev/kvmfr0:   $kvmfr_dev_status"
+
+    # IVSHMEM size from config
+    local ivshmem_configured="64M (default)"
+    if [[ -f "$GPU_PASSTHROUGH_CONF" ]]; then
+      local conf_size
+      conf_size=$(grep "^IVSHMEM_SIZE=" "$GPU_PASSTHROUGH_CONF" 2>/dev/null | cut -d'"' -f2)
+      [[ -n "$conf_size" ]] && ivshmem_configured="$conf_size"
+    fi
+    echo "IVSHMEM Size:  $ivshmem_configured"
+
+    # Looking Glass client
+    local lg_client_status="✗ Not installed"
+    if command -v looking-glass-client &>/dev/null; then
+      local lg_version
+      lg_version=$(looking-glass-client --version 2>&1 | head -1 | grep -oE 'B[0-9]+-?[a-z0-9]*' || echo "installed")
+      lg_client_status="✓ $lg_version"
+    fi
+    echo "Client:        $lg_client_status"
+
+    # SPICE in docker image
+    if command -v docker &>/dev/null; then
+      local spice_status="✗ Not found"
+      if docker images --format '{{.Repository}}:{{.Tag}}' 2>/dev/null | grep -q "dockurr/windows:spice"; then
+        spice_status="✓ dockurr/windows:spice"
+      elif docker images --format '{{.Repository}}:{{.Tag}}' 2>/dev/null | grep -q "dockurr/windows"; then
+        spice_status="⚠️  dockurr/windows (may lack SPICE)"
+      fi
+      echo "Docker Image:  $spice_status"
+    fi
+    echo '```'
+    echo ""
+
+    echo "[PROCESSES USING GPU]"
+    echo ""
+
+    echo "[DRI Device Handles (all GPUs)]"
+    echo '```'
+    local dri_output
+    dri_output=$(fuser -v /dev/dri/* 2>&1 | grep -v "^$" | head -30) || dri_output=""
+    if [[ -n "$dri_output" ]]; then
+      echo "$dri_output"
+    else
+      echo "No processes using /dev/dri/*"
+    fi
+    echo '```'
+    echo ""
+
+    # Per-GPU process breakdown
+    echo "[Per-GPU Process Breakdown]"
+    echo '```'
+    for card_path in /sys/class/drm/card[0-9]*; do
+      [[ -d "$card_path" ]] || continue
+      [[ "$(basename "$card_path")" =~ - ]] && continue  # Skip connectors
+
+      local card_name=$(basename "$card_path")
+      local pci_path=$(readlink -f "$card_path/device" 2>/dev/null)
+      local pci_addr="${pci_path##*/}"
+      pci_addr="${pci_addr#0000:}"
+      local driver=$(basename "$(readlink -f "$card_path/device/driver" 2>/dev/null)" 2>/dev/null)
+      local gpu_name=$(lspci -s "$pci_addr" 2>/dev/null | cut -d: -f3 | head -c40)
+
+      echo "--- $card_name: $gpu_name ($driver) ---"
+
+      # Render nodes are /dev/dri/renderD128, renderD129, etc.
+      local render_node="/dev/dri/renderD$((128 + ${card_name#card}))"
+
+      local card_procs=""
+      if [[ -e "/dev/dri/$card_name" ]]; then
+        card_procs=$(fuser "/dev/dri/$card_name" 2>/dev/null | xargs)
+      fi
+      local render_procs=""
+      if [[ -e "$render_node" ]]; then
+        render_procs=$(fuser "$render_node" 2>/dev/null | xargs)
+      fi
+
+      if [[ -n "$card_procs" || -n "$render_procs" ]]; then
+        local all_pids=$(echo "$card_procs $render_procs" | tr ' ' '\n' | sort -u | xargs)
+        for pid in $all_pids; do
+          local cmdline=$(cat "/proc/$pid/comm" 2>/dev/null || echo "unknown")
+          echo "  PID $pid: $cmdline"
+        done
+      else
+        echo "  (no processes)"
+      fi
+      echo ""
+    done
+    echo '```'
+    echo ""
+
+    echo "[NVIDIA GPU Processes]"
+    echo '```'
+    if command -v nvidia-smi &>/dev/null; then
+      local nvidia_output
+      nvidia_output=$(nvidia-smi --query-compute-apps=pid,name,used_memory --format=csv 2>&1) || nvidia_output=""
+      if [[ "$nvi dia_output" =~ Failed\ to\ initialize\ NVML ]]; then
+        echo "nvidia-smi unavailable (GPU likely bound to vfio-pci)"
+      elif [[ -z "$nvidia_output" ]] || [[ "$nvidia_output" =~ No\ running ]]; then
+        echo "No active NVIDIA compute processes"
+      else
+        echo "$nvidia_output"
+      fi
+    else
+      echo "nvidia-smi not available (no NVIDIA GPU or driver not loaded)"
+    fi
+    echo '```'
+    echo ""
+
+    echo "[NVIDIA Device Handles]"
+    echo '```'
+    if ls /dev/nvidia* &>/dev/null; then
+      fuser -v /dev/nvidia* 2>&1 | grep -v "USER\|kernel" | head -20 || echo "No processes using NVIDIA devices"
+    else
+      echo "No NVIDIA devices found"
+    fi
+    echo '```'
+    echo ""
+
+    echo "[RECENT GPU PASSTHROUGH LOGS]"
+    echo ""
+
+    if [[ -f "$LOG_FILE" ]]; then
+      echo "[Last 1000 lines of $LOG_FILE]"
+      echo '```'
+      tail -1000 "$LOG_FILE"
+      echo '```'
+      echo ""
+    else
+      echo "No logs found at $LOG_FILE"
+      echo ""
+    fi
+
+    echo "[KERNEL MESSAGES - CURRENT BOOT]"
+    echo ""
+
+    echo "[IOMMU Messages]"
+    echo '```'
+    journalctl -k -b --no-pager 2>/dev/null | grep -i iommu | head -50 || echo "No IOMMU messages"
+    echo '```'
+    echo ""
+
+    echo "[VFIO Messages]"
+    echo '```'
+    journalctl -k -b --no-pager 2>/dev/null | grep -i vfio | head -50 || echo "No VFIO messages"
+    echo '```'
+    echo ""
+
+    echo "[Boot VGA Device]"
+    echo '```'
+    journalctl -k -b --no-pager 2>/dev/null | grep -i "boot vga" || echo "No boot VGA messages"
+    echo '```'
+    echo ""
+
+    echo "[PCI Passthrough Messages]"
+    echo '```'
+    journalctl -k -b --no-pager 2>/dev/null | grep -iE "pci.*passthrough|vfio-pci" | head -50 || echo "No passthrough messages"
+    echo '```'
+    echo ""
+
+    echo "[xhci/USB Controller Messages]"
+    echo '```'
+    journalctl -k -b --no-pager 2>/dev/null | grep -iE "xhci|usb.*controller" | head -50 || echo "No xhci messages"
+    echo '```'
+    echo ""
+
+    if journalctl -k -b -1 --no-pager 2>/dev/null | head -1 | grep -q .; then
+      echo "[KERNEL MESSAGES - PREVIOUS BOOT]"
+      echo ""
+
+      echo "[IOMMU Messages (prev boot)]"
+      echo '```'
+      journalctl -k -b -1 --no-pager 2>/dev/null | grep -i iommu | head -30 || echo "No IOMMU messages"
+      echo '```'
+      echo ""
+
+      echo "[VFIO Messages (prev boot)]"
+      echo '```'
+      journalctl -k -b -1 --no-pager 2>/dev/null | grep -i vfio | head -30 || echo "No VFIO messages"
+      echo '```'
+      echo ""
+    fi
+
+    echo "[TROUBLESHOOTING HINTS]"
+    echo ""
+
+    # Check IOMMU status once
+    local iommu_cmdline=false iommu_firmware=false
+    grep -qE "intel_iommu|amd_iommu" /proc/cmdline 2>/dev/null && iommu_cmdline=true
+    journalctl -k -b --no-pager 2>/dev/null | grep -q "Intel-IOMMU force enabled" && iommu_firmware=true
+
+    if [[ "$iommu_firmware" == "true" ]]; then
+      echo "  ℹ️  IOMMU enabled by firmware (intel_iommu=on may not be needed)"
+    fi
+
+    if ! grep -q "iommu=pt" /proc/cmdline 2>/dev/null; then
+      echo "  ⚠️  iommu=pt not set - recommended for better performance"
+    fi
+
+    # Only warn about bootloader/config if IOMMU not active
+    if [[ "$iommu_cmdline" == "false" && "$iommu_firmware" == "false" ]]; then
+      local bootloader=$(detect_bootloader)
+      if ! is_bootloader_supported "$bootloader"; then
+        echo "  ⚠️  Bootloader '$(get_bootloader_display_name "$bootloader")' requires manual kernel parameter configuration"
+      fi
+      [[ -f "$GPU_PASSTHROUGH_CONF" ]] && \
+        echo "  ⚠️  Setup may be incomplete - config saved but IOMMU not active"
+    fi
+
+    # Laptop detection
+    detect_hybrid_graphics_laptop
+    if [[ "$IS_MUXLESS_LAPTOP" == "true" ]]; then
+      echo "  ℹ️  Laptop detected (MUX-less hybrid graphics)"
+      echo "  ℹ️  Internal display on iGPU - safe for dGPU passthrough"
+    fi
+    echo ""
+
+    echo "[END OF DIAGNOSTICS REPORT]"
+    echo ""
+    echo "Report saved to: $output_file"
+    echo "Generated: $(date)"
+
+  } >"$output_file" 2>&1
+
+  cat "$output_file"
+  echo ""
+  msg_success "Report saved: $output_file"
+}
+
+cmd_detect() {
+  msg_section "GPU Detection"
+
+  detect_gpus
+
+  echo "Detected $GPU_COUNT GPU(s):"
+  echo ""
+
+  for i in "${!GPU_PCI_ADDR[@]}"; do
+    local pci="${GPU_PCI_ADDR[$i]}"
+    local name="${GPU_NAME[$i]}"
+    local vendor_id="${GPU_VENDOR_ID[$i]}"
+    local device_id="${GPU_DEVICE_ID[$i]}"
+    local driver="${GPU_DRIVER[$i]}"
+    local type="${GPU_TYPE[$i]}"
+    local audio_id="${GPU_AUDIO_ID[$i]}"
+
+    echo "GPU $((i + 1)): $name"
+    echo "  PCI Address:   $pci"
+    echo "  Vendor:Device: ${vendor_id}:${device_id}"
+    echo "  Type:          $type"
+    echo "  Driver:        $driver"
+    if [[ -n "$audio_id" ]]; then
+      echo "  Audio Device:  ${audio_id}"
+    fi
+    echo ""
+  done
+
+  echo "IOMMU Status:"
+  local iommu_cmdline=false
+  local iommu_firmware=false
+
+  if grep -qE "(intel_iommu|amd_iommu)=on" /proc/cmdline 2>/dev/null; then
+    iommu_cmdline=true
+  fi
+
+  if journalctl -k -b 2>/dev/null | grep -q "Intel-IOMMU force enabled"; then
+    iommu_firmware=true
+  fi
+
+  if check_iommu_support; then
+    msg_success "IOMMU: Enabled"
+    if [[ "$iommu_firmware" == "true" ]]; then
+      echo "  Source: Firmware-enabled (Tiger Lake or similar)"
+    elif [[ "$iommu_cmdline" == "true" ]]; then
+      echo "  Source: Kernel cmdline"
+    fi
+  else
+    msg_warning "IOMMU: Not detected"
+    echo "  Possible causes:"
+    echo "    1. IOMMU not enabled in BIOS (AMD-Vi or Intel VT-d)"
+    echo "    2. Kernel parameters not set → run: omarchy-gpu-passthrough setup"
+    echo "    3. Reboot needed after setup"
+  fi
+
+  echo ""
+  echo "Bootloader: $(get_bootloader_display_name)"
+}
+
+cmd_status() {
+  local config_gpu_pci=""
+  if load_gpu_config 2>/dev/null; then
+    config_gpu_pci="$GPU_PCI_ADDR"
+  fi
+
+  detect_gpus
+
+  # Check if GPU passthrough is configured
+  if [[ -z "$config_gpu_pci" ]]; then
+    echo ""
+    msg_warning "GPU passthrough not configured"
+    echo ""
+    echo "Next steps:"
+    echo "   1. omarchy-gpu-passthrough setup"
+    echo "   2. Reboot"
+    echo "   3. omarchy-gpu-passthrough info verify"
+    echo ""
+    return
+  fi
+
+  # Get passthrough GPU mode
+  local current_driver="$(get_pci_driver "$config_gpu_pci")"
+  local mode="$(detect_gpu_mode_from_driver "${current_driver:-}")"
+
+  echo ""
+  echo "GPU Status:"
+  for i in "${!GPU_PCI_ADDR[@]}"; do
+    local pci="${GPU_PCI_ADDR[$i]}"
+    local name="${GPU_NAME[$i]}"
+    local driver="${GPU_DRIVER[$i]}"
+    local type="${GPU_TYPE[$i]}"
+
+    # Shorten GPU name for display
+    local short_name="$name"
+    short_name="${short_name//NVIDIA Corporation /}"
+    short_name="${short_name//Advanced Micro Devices, Inc. /}"
+    short_name="${short_name//\[AMD\/ATI\] /}"
+
+    # Build status line
+    local status_line="  [$((i + 1))] $short_name ($pci)"
+
+    # Normalize PCI addresses for comparison
+    local pci_normalized config_pci_normalized
+    pci_normalized=$(normalize_pci_addr "$pci") || continue
+    config_pci_normalized=$(normalize_pci_addr "$config_gpu_pci") || continue
+
+    # Add driver and mode info
+    if [[ "$pci_normalized" == "$config_pci_normalized" ]]; then
+      # This is the passthrough GPU - show mode
+      status_line+=" → ${driver:-none} (mode: ${mode})"
+      if [[ "$mode" == "vm" ]]; then
+        status_line+=" ✓"
+      fi
+    else
+      # Other GPU - show driver and role
+      status_line+=" → ${driver:-none}"
+      if [[ "$type" == "integrated" ]]; then
+        status_line+=" (host display)"
+      fi
+    fi
+
+    echo "$status_line"
+  done
+
+  # IOMMU status (if active)
+  if [[ -d /dev/vfio ]]; then
+    local iommu_groups=$(find /dev/vfio/ -maxdepth 1 -type c -name '[0-9]*' 2>/dev/null | wc -l)
+    if [[ "$iommu_groups" -gt 0 ]]; then
+      echo ""
+      echo "IOMMU: $iommu_groups group(s) active"
+    fi
+  fi
+
+  # Show persistent VFIO mode if enabled
+  if is_persistent_vfio_enabled "$config_gpu_pci" "$GPU_VENDOR_ID" "$GPU_DEVICE_ID" 2>/dev/null; then
+    echo "Persistent VFIO: enabled (GPU stays bound to vfio-pci across reboots)"
+  fi
+  echo ""
+}
+
+# Query commands (for scripting)
+
+cmd_driver() {
+  if ! load_gpu_config; then
+    echo "not-configured"
+    exit 1
+  fi
+
+  local current_driver=$(get_pci_driver "$GPU_PCI_ADDR")
+
+  if [[ -z "$current_driver" ]]; then
+    echo "none"
+  else
+    echo "$current_driver"
+  fi
+}
+
+cmd_is_bound() {
+  if ! load_gpu_config; then
+    exit 2
+  fi
+
+  local current_driver=$(get_pci_driver "$GPU_PCI_ADDR")
+
+  if [[ "$current_driver" == "vfio-pci" ]]; then
+    exit 0
+  else
+    exit 1
+  fi
+}
+
+cmd_is_configured() {
+  if [[ ! -f "$GPU_PASSTHROUGH_CONF" ]]; then
+    exit 1
+  fi
+
+  if ! grep -qE "amd_iommu=on|intel_iommu=on" /proc/cmdline; then
+    exit 1
+  fi
+
+  if [[ ! -f "$VFIO_CONF" ]]; then
+    exit 1
+  fi
+
+  exit 0
+}
+
+# Check if configured GPU has AMD reset bug (requires special handling for unbind)
+# These GPUs cannot rebind to native driver after vfio-pci use without reboot
+# Exit 0 if has reset bug, 1 if not, 2 if not configured
+cmd_needs_reset() {
+  if ! load_gpu_config; then
+    exit 2
+  fi
+
+  # Check vendor (must be AMD - only AMD GPUs have this bug)
+  if [[ "$GPU_VENDOR_ID" != "1002" ]]; then
+    exit 1
+  fi
+
+  if gpu_has_reset_bug "$GPU_PCI_ADDR"; then
+    exit 0
+  else
+    exit 1
+  fi
+}
+
+# Check if GPU has IOTLB_INV_TIMEOUT error in current boot (requires cold boot to fix)
+# Exit 0 if has error (unhealthy), 1 if OK, 2 if not configured
+cmd_gpu_health() {
+  if ! load_gpu_config; then
+    exit 2
+  fi
+
+  local pci_addr="$GPU_PCI_ADDR"
+  local pci_full
+  pci_full=$(normalize_pci_addr "$pci_addr") || pci_full="0000:${pci_addr}"
+
+  # Check kernel log for IOTLB_INV_TIMEOUT on this device (current boot only)
+  local iotlb_error
+  iotlb_error=$(journalctl -k -b --no-pager 2>/dev/null | grep -i "IOTLB_INV_TIMEOUT" | grep -i "$pci_addr\|$pci_full" | tail -1)
+
+  if [[ -n "$iotlb_error" ]]; then
+    # GPU is unhealthy - IOTLB timeout detected
+    exit 0
+  else
+    # GPU is healthy
+    exit 1
+  fi
+}
+
+# Check GPU health and print status
+cmd_check_health() {
+  local quiet="${1:-false}"
+
+  if ! load_gpu_config 2>/dev/null; then
+    [[ "$quiet" != "true" ]] && echo "not-configured"
+    return 2
+  fi
+
+  local pci_addr="$GPU_PCI_ADDR"
+  local pci_full
+  pci_full=$(normalize_pci_addr "$pci_addr") || pci_full="0000:${pci_addr}"
+
+  # Check kernel log for IOTLB_INV_TIMEOUT on this device (current boot only)
+  local iotlb_error
+  iotlb_error=$(journalctl -k -b --no-pager 2>/dev/null | grep -i "IOTLB_INV_TIMEOUT" | grep -i "$pci_addr\|$pci_full" | tail -1)
+
+  # Shorten GPU name for display
+  local short_name="$GPU_NAME"
+  short_name="${short_name//Advanced Micro Devices, Inc. /}"
+  short_name="${short_name//\[AMD\/ATI\] /}"
+  short_name="${short_name//NVIDIA Corporation /}"
+
+  if [[ -n "$iotlb_error" ]]; then
+    if [[ "$quiet" != "true" ]]; then
+      echo ""
+      echo "GPU Health Check: FAILED"
+      echo "────────────────────────"
+      echo ""
+      echo "Status: IOTLB_INV_TIMEOUT detected"
+      echo "GPU:    $short_name ($pci_addr)"
+      echo ""
+      echo "The GPU cannot be used for VM passthrough in this state."
+      echo "This happens when AMD GPUs with 'reset bug' are reset too many times."
+      echo ""
+      echo "Kernel error:"
+      echo "  $iotlb_error"
+      echo ""
+      echo "Solution: Cold boot"
+      echo ""
+      echo "  1. sudo poweroff"
+      echo "  2. Unplug power for 30 seconds"
+      echo "  3. Power on"
+      echo ""
+    fi
+    return 1  # Failure - IOTLB error found
+  else
+    if [[ "$quiet" != "true" ]]; then
+      echo ""
+      echo "GPU Health Check: OK"
+      echo "────────────────────"
+      echo ""
+      echo "GPU: $short_name ($pci_addr)"
+      echo "No IOTLB errors detected."
+      echo ""
+    fi
+    return 0  # Success - GPU is healthy
+  fi
+}
+
+# Check if persistent VFIO mode is enabled
+# Exit codes: 0 = enabled, 1 = disabled, 2 = not-configured
+cmd_is_persistent() {
+  if ! load_gpu_config 2>/dev/null; then
+    exit 2
+  fi
+
+  if is_persistent_vfio_enabled "$GPU_PCI_ADDR" "$GPU_VENDOR_ID" "$GPU_DEVICE_ID"; then
+    exit 0
+  else
+    exit 1
+  fi
+}
+
+cmd_mode() {
+  if ! load_gpu_config; then
+    echo "not-configured"
+    exit 1
+  fi
+
+  local current_driver="$(get_pci_driver "$GPU_PCI_ADDR")"
+  local mode="$(detect_gpu_mode_from_driver "$current_driver")"
+  echo "$mode"
+
+  if [[ "$mode" == "unknown" ]]; then
+    exit 1
+  else
+    exit 0
+  fi
+}
+
+cmd_get_docker_config() {
+  if ! load_gpu_config; then
+    msg_error "GPU passthrough not configured"
+    exit 1
+  fi
+
+  local iommu_group="${GPU_IOMMU_GROUP:-}"
+  if [[ -z "$iommu_group" ]] || [[ "$iommu_group" == "unknown" ]]; then
+    iommu_group=$(get_iommu_group "$GPU_PCI_ADDR")
+  fi
+
+  local iommu_devices="${GPU_IOMMU_DEVICES:-}"
+  if [[ -z "$iommu_devices" ]]; then
+    iommu_devices=$(get_iommu_group_devices "$GPU_PCI_ADDR")
+  fi
+
+  # Format: GPU_PCI_ADDR IOMMU_GROUP DEVICE1 DEVICE2 DEVICE3 ...
+  # First device is always the main GPU address
+  echo "$GPU_PCI_ADDR $iommu_group $iommu_devices"
+}
+
+cmd_hardware_report() {
+  check_dependencies
+
+  local has_sudo=false
+  # Request sudo for complete hardware info (motherboard, BIOS)
+  if [[ "$EUID" -eq 0 ]]; then
+    has_sudo=true
+  elif sudo -n true 2>/dev/null; then
+    has_sudo=true
+  else
+    msg_info "Full report requires sudo (for motherboard/BIOS info)"
+    if sudo true; then
+      has_sudo=true
+    else
+      msg_warning "Continuing without sudo - some data will be incomplete"
+    fi
+  fi
+
+  detect_gpus
+
+  echo ""
+  echo "=== Hardware Configuration Report ==="
+
+  # SYSTEM
+  echo ""
+  echo "SYSTEM"
+
+  local base_os="Linux"
+  if [[ -f /etc/os-release ]]; then
+    base_os="$(grep "^PRETTY_NAME=" /etc/os-release | cut -d= -f2 | tr -d '"')"
+  fi
+
+  local omarchy_ver=""
+  if [[ -n "${OMARCHY_PATH:-}" ]] && [[ -r "${OMARCHY_PATH}/version" ]]; then
+    omarchy_ver=$(head -1 "${OMARCHY_PATH}/version" 2>/dev/null)
+    omarchy_ver="${omarchy_ver//[[:space:]]/}"
+  elif command -v omarchy-version &>/dev/null; then
+    omarchy_ver=$(omarchy-version 2>/dev/null | head -1 | tr -d '[:space:]')
+  fi
+
+  if [[ -n "$omarchy_ver" ]]; then
+    echo "  OS: Omarchy $omarchy_ver ($base_os)"
+  else
+    echo "  OS: $base_os"
+  fi
+
+  local kernel="$(uname -r 2>/dev/null || echo "Unknown")"
+  echo "  Kernel: $kernel"
+
+  echo "  Bootloader: $(get_bootloader_display_name)"
+
+  local omarchy_branch=""
+  local omarchy_commit=""
+  if [[ -n "${OMARCHY_PATH:-}" ]] && [[ -d "${OMARCHY_PATH}/.git" ]]; then
+    omarchy_branch=$(git -C "${OMARCHY_PATH}" rev-parse --abbrev-ref HEAD 2>/dev/null | tr -d '[:space:]')
+    omarchy_commit=$(git -C "${OMARCHY_PATH}" rev-parse --short HEAD 2>/dev/null | tr -d '[:space:]')
+  elif command -v omarchy-version-branch &>/dev/null; then
+    omarchy_branch=$(omarchy-version-branch 2>/dev/null | head -1 | tr -d '[:space:]')
+  fi
+  [[ -n "$omarchy_branch" ]] && echo "  Branch: $omarchy_branch"
+  [[ -n "$omarchy_commit" ]] && echo "  Commit: $omarchy_commit"
+
+  # HARDWARE
+  echo ""
+  echo "HARDWARE"
+
+  # CPU info
+  local cpu_model="Unknown"
+  local cpu_physical=""
+  local cpu_threads=""
+  local cpu_vendor="$(get_cpu_vendor)"
+
+  if command -v lscpu &>/dev/null; then
+    cpu_model="$(lscpu | grep "Model name:" | head -1 | cut -d: -f2 | xargs)"
+    cpu_physical="$(lscpu | grep "^Core(s) per socket:" | awk '{print $4}')"
+    local sockets="$(lscpu | grep "^Socket(s):" | awk '{print $2}')"
+    [[ -n "$cpu_physical" && -n "$sockets" ]] && cpu_physical=$((cpu_physical * sockets))
+    cpu_threads="$(lscpu | grep "^CPU(s):" | awk '{print $2}')"
+  elif [[ -f /proc/cpuinfo ]]; then
+    cpu_model="$(grep "model name" /proc/cpuinfo | head -1 | cut -d: -f2 | xargs)"
+    cpu_threads="$(grep -c "^processor" /proc/cpuinfo)"
+  fi
+
+  # Clean up CPU model
+  cpu_model="${cpu_model//(R)/}"
+  cpu_model="${cpu_model//(TM)/}"
+  cpu_model="${cpu_model//CPU /}"
+  cpu_model="$(echo "$cpu_model" | xargs)"
+
+  local cpu_cores_info=""
+  if [[ -n "$cpu_physical" && -n "$cpu_threads" ]]; then
+    cpu_cores_info=" (${cpu_physical}C/${cpu_threads}T)"
+  elif [[ -n "$cpu_threads" ]]; then
+    cpu_cores_info=" (${cpu_threads}T)"
+  fi
+
+  echo "  CPU: ${cpu_model}${cpu_cores_info}"
+
+  # Virtualization capabilities
+  local virt_info=""
+  if check_cpu_iommu_capability 2>/dev/null; then
+    if [[ "$cpu_vendor" == "intel" ]]; then
+      virt_info="VT-x ✓"
+      if check_iommu_support 2>/dev/null; then
+        virt_info="$virt_info  VT-d ✓"
+      fi
+    elif [[ "$cpu_vendor" == "amd" ]]; then
+      virt_info="AMD-V ✓"
+      if check_iommu_support 2>/dev/null; then
+        virt_info="$virt_info  AMD-Vi ✓"
+      fi
+    fi
+  fi
+  [[ -n "$virt_info" ]] && echo "       $virt_info"
+
+  # Extended virtualization
+  local ext_virt=""
+  if [[ -f /proc/cpuinfo ]]; then
+    local cpu_flags=$(grep -m1 "^flags" /proc/cpuinfo | cut -d: -f2)
+    [[ "$cpu_flags" == *" ept "* ]] && ext_virt="EPT"
+    [[ "$cpu_flags" == *" vpid "* ]] && ext_virt="${ext_virt:+$ext_virt  }VPID"
+  fi
+  if command -v lscpu &>/dev/null; then
+    local phys_bits=$(lscpu | grep "Address sizes:" | grep -oP '\d+(?= bits physical)')
+    [[ -n "$phys_bits" ]] && ext_virt="${ext_virt:+$ext_virt  }${phys_bits}-bit phys"
+  fi
+  [[ -n "$ext_virt" ]] && echo "       $ext_virt"
+
+  # NUMA topology
+  local numa_nodes=""
+  if command -v lscpu &>/dev/null; then
+    numa_nodes=$(lscpu | grep "^NUMA node(s):" | awk '{print $3}')
+  fi
+  [[ -n "$numa_nodes" && "$numa_nodes" != "1" ]] && echo "       NUMA: ${numa_nodes} nodes"
+
+  # RAM info
+  local ram_total="Unknown"
+  local ram_free="Unknown"
+  if [[ -f /proc/meminfo ]]; then
+    local ram_total_kb=$(grep "^MemTotal:" /proc/meminfo | awk '{print $2}')
+    local ram_avail_kb=$(grep "^MemAvailable:" /proc/meminfo | awk '{print $2}')
+    if [[ -n "$ram_total_kb" ]]; then
+      ram_total="$((ram_total_kb / 1024 / 1024)) GB"
+    fi
+    if [[ -n "$ram_avail_kb" ]]; then
+      ram_free="$((ram_avail_kb / 1024 / 1024)) GB"
+    fi
+  fi
+  echo "  RAM: $ram_total ($ram_free free)"
+
+  # Motherboard info
+  local mobo_vendor=""
+  local mobo_model=""
+  local bios_version=""
+
+  if [[ "$has_sudo" == "true" ]] && command -v dmidecode &>/dev/null; then
+    mobo_vendor="$(sudo dmidecode -t baseboard 2>/dev/null | grep "Manufacturer:" | cut -d: -f2 | xargs)"
+    mobo_model="$(sudo dmidecode -t baseboard 2>/dev/null | grep "Product Name:" | cut -d: -f2 | xargs)"
+    bios_version="$(sudo dmidecode -t bios 2>/dev/null | grep "Version:" | cut -d: -f2 | xargs)"
+  fi
+
+  if [[ -n "$mobo_vendor" || -n "$mobo_model" ]]; then
+    local mobo_line="  Motherboard: "
+    [[ -n "$mobo_vendor" ]] && mobo_line+="$mobo_vendor "
+    [[ -n "$mobo_model" ]] && mobo_line+="$mobo_model"
+    [[ -n "$bios_version" ]] && mobo_line+=" (BIOS $bios_version)"
+    echo "$mobo_line"
+  fi
+
+  # GPUs
+  echo ""
+  echo "GPUs"
+
+  for i in "${!GPU_PCI_ADDR[@]}"; do
+    local pci="${GPU_PCI_ADDR[$i]}"
+    local name="${GPU_NAME[$i]}"
+    local driver="${GPU_DRIVER[$i]}"
+    local type="${GPU_TYPE[$i]}"
+    local vendor_id="${GPU_VENDOR_ID[$i]}"
+    local device_id="${GPU_DEVICE_ID[$i]}"
+
+    # Get vRAM and BAR size
+    local vram_info="N/A"
+    local bar_info="N/A"
+
+    if [[ "$type" == "integrated" ]]; then
+      vram_info="Shared"
+      bar_info="Shared"
+    else
+      local vram_mb=$(get_gpu_vram_mb "$pci" "$vendor_id" "$driver")
+      local bar_mb=$(get_gpu_bar_size_mb "$pci")
+
+      vram_info=$(format_memory_size "$vram_mb")
+      bar_info=$(format_memory_size "$bar_mb")
+
+      [[ -z "$vram_info" ]] && vram_info="N/A"
+      [[ -z "$bar_info" ]] && bar_info="N/A"
+    fi
+
+    # Get IOMMU group
+    local iommu_group=$(get_iommu_group "$pci")
+    [[ "$iommu_group" == "unknown" ]] && iommu_group=""
+
+    echo "  $((i + 1)). $name [${vendor_id}:${device_id}]"
+    echo "     PCI: $pci | Driver: ${driver:-none} | vRAM: $vram_info | BAR: $bar_info"
+
+    # Show runtime stats for AMD GPUs
+    if [[ "$vendor_id" == "1002" && "$driver" == "amdgpu" ]]; then
+      local stats_output
+      if stats_output=$(get_amd_gpu_stats "$pci" 2>/dev/null); then
+        eval "$stats_output"
+        local runtime_info=""
+        [[ "$temp_c" -gt 0 ]] && runtime_info+="Temp: ${temp_c}°C"
+        [[ "$power_w" -gt 0 ]] && runtime_info+="${runtime_info:+ | }Power: ${power_w}W"
+        [[ "$fan_rpm" -gt 0 ]] && runtime_info+="${runtime_info:+ | }Fan: ${fan_rpm} RPM"
+        [[ -n "$runtime_info" ]] && echo "     $runtime_info"
+        [[ -n "$vbios" ]] && echo "     VBIOS: $vbios"
+      fi
+    fi
+
+    # Show runtime stats for NVIDIA GPUs
+    if [[ "$vendor_id" == "10de" && "$driver" == "nvidia" ]]; then
+      local stats_output
+      if stats_output=$(get_nvidia_gpu_stats "$pci" 2>/dev/null); then
+        eval "$stats_output"
+        local runtime_info=""
+        [[ "$temp_c" -gt 0 ]] && runtime_info+="Temp: ${temp_c}°C"
+        [[ "$power_w" -gt 0 ]] && runtime_info+="${runtime_info:+ | }Power: ${power_w}W"
+        [[ -n "$runtime_info" ]] && echo "     $runtime_info"
+        [[ -n "$vbios" ]] && echo "     VBIOS: $vbios"
+      fi
+    fi
+
+    # Show IOMMU group devices for dedicated GPUs
+    if [[ -n "$iommu_group" && "$type" == "dedicated" ]]; then
+      local iommu_group_path="/sys/kernel/iommu_groups/${iommu_group}/devices"
+      if [[ -d "$iommu_group_path" ]]; then
+        local group_devices=()
+        for dev_path in "$iommu_group_path"/*; do
+          if [[ -d "$dev_path" ]]; then
+            local dev_full=$(basename "$dev_path")
+            group_devices+=("${dev_full#0000:}")
+          fi
+        done
+        echo "     IOMMU Group $iommu_group: ${group_devices[*]}"
+      fi
+    fi
+    echo ""
+  done
+
+  # DISPLAY
+  echo "DISPLAY"
+
+  local primary_gpu="Unknown"
+  if command -v glxinfo &>/dev/null; then
+    local glx_output="$(glxinfo 2>/dev/null)"
+    if [[ -n "$glx_output" ]]; then
+      primary_gpu="$(echo "$glx_output" | grep "OpenGL renderer" | cut -d: -f2 | xargs)"
+    fi
+  fi
+
+  if [[ -n "${WAYLAND_DISPLAY:-}" ]]; then
+    local compositor=""
+    if pgrep -x Hyprland &>/dev/null; then
+      compositor="Hyprland"
+    elif pgrep -x sway &>/dev/null; then
+      compositor="Sway"
+    fi
+    if [[ -n "$compositor" ]]; then
+      echo "  Session: Wayland ($compositor)"
+    else
+      echo "  Session: Wayland"
+    fi
+  elif [[ -n "${DISPLAY:-}" ]]; then
+    echo "  Session: X11"
+  else
+    echo "  Session: None (TTY/SSH)"
+  fi
+
+  echo "  Primary GPU: $primary_gpu"
+
+  echo "  Monitors:"
+  for i in "${!GPU_PCI_ADDR[@]}"; do
+    local pci="${GPU_PCI_ADDR[$i]}"
+    local name="${GPU_NAME[$i]}"
+    local driver="${GPU_DRIVER[$i]}"
+
+    local gpu_drm_card=$(get_drm_card_for_pci "$pci")
+
+    if [[ -n "$gpu_drm_card" ]]; then
+      local connectors_path="/sys/class/drm"
+      local connected_count=0
+      local connected_ports=()
+
+      for status_file in "$connectors_path"/${gpu_drm_card}-*/status; do
+        [[ -f "$status_file" ]] || continue
+        if grep -q "^connected$" "$status_file" 2>/dev/null; then
+          local connector_name=$(basename "$(dirname "$status_file")")
+          local port_type=$(echo "$connector_name" | sed "s/^${gpu_drm_card}-//" | sed 's/[0-9-]*$//')
+          connected_ports+=("$port_type")
+          ((connected_count++))
+        fi
+      done
+
+      if [[ "$connected_count" -gt 0 ]]; then
+        local port_list=$(IFS=,; echo "${connected_ports[*]}")
+        echo "    ${name}: ${connected_count} (${port_list})"
+      else
+        echo "    ${name}: 0"
+      fi
+    else
+      if [[ "$driver" == "vfio-pci" ]]; then
+        echo "    ${name}: N/A (vfio-pci)"
+      else
+        echo "    ${name}: Unknown"
+      fi
+    fi
+  done
+  echo ""
+
+  # PASSTHROUGH STATUS
+  echo "PASSTHROUGH STATUS"
+
+  local issues=()
+
+  # GPU count check
+  if [[ "$GPU_COUNT" -lt 2 ]]; then
+    issues+=("Only ${GPU_COUNT} GPU detected (passthrough requires 2: iGPU for host + dGPU for VM)")
+  fi
+
+  # IOMMU status
+  if check_iommu_support 2>/dev/null; then
+    local cmdline=""
+    [[ -r /proc/cmdline ]] && cmdline=$(<"/proc/cmdline")
+    if [[ "$cmdline" =~ iommu=pt ]]; then
+      echo "  IOMMU: Active (passthrough mode)"
+    else
+      echo "  IOMMU: Active"
+    fi
+  else
+    echo "  IOMMU: Not detected"
+    issues+=("IOMMU not enabled in BIOS or kernel")
+  fi
+
+  # Current mode
+  if load_gpu_config 2>/dev/null; then
+    local current_driver="$(get_pci_driver "$GPU_PCI_ADDR")"
+    local current_mode="$(detect_gpu_mode_from_driver "$current_driver")"
+    echo "  Current Mode: ${current_mode:-unknown}"
+    echo ""
+
+    # Passthrough GPU info
+    echo "  Passthrough GPU:"
+    echo "    $GPU_NAME → ${current_driver:-none}"
+
+    # Get audio device in same IOMMU group
+    local gpu_iommu_group=$(get_iommu_group "$GPU_PCI_ADDR")
+    if [[ -n "$gpu_iommu_group" && "$gpu_iommu_group" != "unknown" ]]; then
+      local iommu_group_path="/sys/kernel/iommu_groups/${gpu_iommu_group}/devices"
+      for dev_path in "$iommu_group_path"/*; do
+        [[ -d "$dev_path" ]] || continue
+        local dev_addr_full=$(basename "$dev_path")
+        local dev_addr="${dev_addr_full#0000:}"
+        [[ "$dev_addr" == "$GPU_PCI_ADDR" ]] && continue
+
+        local dev_desc
+        dev_desc=$(lspci -s "$dev_addr" 2>/dev/null) || dev_desc=""
+        dev_desc="${dev_desc#*: }"; dev_desc="${dev_desc#*: }"  # Remove PCI addr and class
+        local dev_driver=$(get_pci_driver "$dev_addr")
+
+        if [[ "${dev_desc,,}" =~ audio ]]; then
+          echo "    ${dev_desc%% *} Audio → ${dev_driver:-none}"
+        fi
+      done
+    fi
+
+    echo ""
+    echo "  IOMMU Group $gpu_iommu_group:"
+
+    if [[ -n "$gpu_iommu_group" && -d "/sys/kernel/iommu_groups/${gpu_iommu_group}/devices" ]]; then
+      for dev_path in "/sys/kernel/iommu_groups/${gpu_iommu_group}/devices"/*; do
+        [[ -d "$dev_path" ]] || continue
+        local dev_addr_full=$(basename "$dev_path")
+        local dev_addr="${dev_addr_full#0000:}"
+        local dev_class_code=$(get_pci_class "$dev_addr")
+        local dev_driver=$(get_pci_driver "$dev_addr")
+
+        local dev_type="Device"
+        case "$dev_class_code" in
+          03*) dev_type="GPU" ;;
+          04*) dev_type="Audio" ;;
+          0c03) dev_type="USB" ;;
+          06*) dev_type="Bridge" ;;
+        esac
+
+        echo "    $dev_addr $dev_type → ${dev_driver:-none}"
+
+        if [[ "$dev_type" == "USB" && "$dev_driver" != "vfio-pci" && "$current_mode" == "vm" ]]; then
+          issues+=("USB controller $dev_addr not bound to vfio-pci")
+        fi
+      done
+    fi
+
+    echo ""
+
+    # VFIO modules
+    if is_module_loaded vfio_pci; then
+      echo "  VFIO Modules: loaded"
+    else
+      echo "  VFIO Modules: not loaded"
+      [[ "$current_mode" == "vm" ]] && issues+=("VFIO modules not loaded")
+    fi
+
+    # VM Ready
+    if [[ "$current_mode" == "vm" ]]; then
+      echo "  VM Ready: Yes"
+    else
+      echo "  VM Ready: No (run 'omarchy-gpu-passthrough mode vm')"
+    fi
+  else
+    echo "  Current Mode: not configured"
+    echo ""
+    echo "  Run: omarchy-gpu-passthrough setup"
+    issues+=("GPU passthrough not configured")
+  fi
+
+  if [[ ${#issues[@]} -gt 0 ]]; then
+    echo ""
+    echo "  Issues:"
+    for issue in "${issues[@]}"; do
+      echo "    ⚠ $issue"
+    done
+  fi
+
+  # DRIVERS
+  echo ""
+  echo "DRIVERS"
+
+  local loaded_modules
+  loaded_modules=$(lsmod 2>/dev/null) || loaded_modules=""
+  local has_driver_info=false
+
+  if [[ "$loaded_modules" =~ ^nvidia\  ]] || [[ "$loaded_modules" =~ $'\n'nvidia\  ]]; then
+    has_driver_info=true
+    local nvidia_version=""
+    if [[ -r /proc/driver/nvidia/version ]]; then
+      local nv_ver_line
+      nv_ver_line=$(<"/proc/driver/nvidia/version")
+      [[ "$nv_ver_line" =~ Kernel\ Module[[:space:]]+([0-9.]+) ]] && nvidia_version="${BASH_REMATCH[1]}"
+    fi
+    if [[ -z "$nvidia_version" ]] && command -v nvidia-smi &>/dev/null; then
+      nvidia_version=$(nvidia-smi --query-gpu=driver_version --format=csv,noheader 2>/dev/null | head -1)
+    fi
+    echo "  NVIDIA: ${nvidia_version:-loaded}"
+  fi
+
+  if [[ "$loaded_modules" =~ ^amdgpu\  ]] || [[ "$loaded_modules" =~ $'\n'amdgpu\  ]]; then
+    has_driver_info=true
+    local mesa_version=""
+    if command -v glxinfo &>/dev/null; then
+      local glx_ver
+      glx_ver=$(glxinfo 2>/dev/null | grep "OpenGL version") || glx_ver=""
+      [[ "$glx_ver" =~ Mesa\ ([0-9.]+) ]] && mesa_version="${BASH_REMATCH[1]}"
+    fi
+    echo "  AMD/Mesa: ${mesa_version:-loaded}"
+  fi
+
+  if [[ "$loaded_modules" =~ ^i915\  ]] || [[ "$loaded_modules" =~ $'\n'i915\  ]]; then
+    has_driver_info=true
+    echo "  Intel i915: loaded"
+  fi
+
+  if [[ "$loaded_modules" =~ ^vfio_pci\  ]] || [[ "$loaded_modules" =~ $'\n'vfio_pci\  ]]; then
+    has_driver_info=true
+    echo "  VFIO: kernel $(uname -r)"
+  fi
+
+  [[ "$has_driver_info" == false ]] && echo "  No GPU drivers loaded"
+
+  echo ""
+  echo "Generated: $(date '+%Y-%m-%d %H:%M:%S')"
+  echo ""
+}
+
+cmd_stats() {
+  detect_gpus
+
+  echo ""
+  echo "GPU Runtime Stats"
+  echo "─────────────────"
+
+  for i in "${!GPU_PCI_ADDR[@]}"; do
+    local pci="${GPU_PCI_ADDR[$i]}"
+    local name="${GPU_NAME[$i]}"
+    local vendor_id="${GPU_VENDOR_ID[$i]}"
+    local driver="${GPU_DRIVER[$i]}"
+
+    # Shorten name
+    local short_name="${name//Advanced Micro Devices, Inc. /}"
+    short_name="${short_name//\[AMD\/ATI\] /}"
+    short_name="${short_name//NVIDIA Corporation /}"
+
+    echo ""
+    echo "[$((i+1))] $short_name ($pci)"
+    echo "    Driver: ${driver:-none}"
+
+    # AMD GPU stats
+    if [[ "$vendor_id" == "1002" && "$driver" == "amdgpu" ]]; then
+      local stats_output
+      if stats_output=$(get_amd_gpu_stats "$pci" 2>/dev/null); then
+        eval "$stats_output"
+        [[ "$vram_total_mb" -gt 0 ]] && echo "    VRAM: ${vram_used_mb}MB / ${vram_total_mb}MB ($((vram_used_mb * 100 / vram_total_mb))%)"
+        [[ "$temp_c" -gt 0 ]] && echo "    Temp: ${temp_c}°C"
+        [[ "$power_w" -gt 0 ]] && echo "    Power: ${power_w}W"
+        [[ "$fan_rpm" -gt 0 ]] && echo "    Fan: ${fan_rpm} RPM"
+        [[ -n "$gpu_clock_mhz" ]] && echo "    GPU Clock: ${gpu_clock_mhz} MHz"
+        [[ -n "$mem_clock_mhz" ]] && echo "    Mem Clock: ${mem_clock_mhz} MHz"
+        [[ -n "$vbios" ]] && echo "    VBIOS: $vbios"
+      else
+        echo "    (stats not available)"
+      fi
+    # Intel GPU stats (i915 for legacy, xe for Arc)
+    elif [[ "$vendor_id" == "8086" && ( "$driver" == "i915" || "$driver" == "xe" ) ]]; then
+      local stats_output
+      if stats_output=$(get_intel_gpu_stats "$pci" 2>/dev/null); then
+        eval "$stats_output"
+        if [[ "$gpu_freq_mhz" -gt 0 ]]; then
+          if [[ "$gpu_freq_max_mhz" -gt 0 ]]; then
+            echo "    GPU Clock: ${gpu_freq_mhz} MHz (max: ${gpu_freq_max_mhz} MHz)"
+          else
+            echo "    GPU Clock: ${gpu_freq_mhz} MHz"
+          fi
+        fi
+        [[ "$temp_c" -gt 0 ]] && echo "    Temp: ${temp_c}°C"
+        [[ "$power_w" -gt 0 ]] && echo "    Power: ${power_w}W"
+        echo "    Memory: Shared (system RAM)"
+      else
+        echo "    (stats not available)"
+      fi
+    # NVIDIA GPU stats
+    elif [[ "$vendor_id" == "10de" && "$driver" == "nvidia" ]]; then
+      local stats_output
+      if stats_output=$(get_nvidia_gpu_stats "$pci" 2>/dev/null); then
+        eval "$stats_output"
+        [[ "$vram_total_mb" -gt 0 ]] && echo "    VRAM: ${vram_used_mb}MB / ${vram_total_mb}MB ($((vram_used_mb * 100 / vram_total_mb))%)"
+        [[ "$temp_c" -gt 0 ]] && echo "    Temp: ${temp_c}°C"
+        [[ "$power_w" -gt 0 ]] && echo "    Power: ${power_w}W"
+        [[ "$gpu_clock_mhz" -gt 0 ]] && echo "    GPU Clock: ${gpu_clock_mhz} MHz"
+        [[ "$mem_clock_mhz" -gt 0 ]] && echo "    Mem Clock: ${mem_clock_mhz} MHz"
+        [[ -n "$vbios" ]] && echo "    VBIOS: $vbios"
+      else
+        echo "    (nvidia-smi not available)"
+      fi
+    elif [[ "$driver" == "vfio-pci" ]]; then
+      echo "    (bound to vfio-pci for VM passthrough)"
+    elif [[ -z "$driver" || "$driver" == "none" ]]; then
+      echo "    (no driver loaded)"
+    fi
+  done
+
+  echo ""
+}
+
+show_info_help() {
+  cat <<EOF
+GPU Passthrough Information & Diagnostics
+
+COMMANDS:
+  status       Quick GPU status and binding state (any time)
+  stats        GPU runtime stats: VRAM, temp, power, clocks
+  detect       Hardware check: GPUs, IOMMU, suitability (before setup)
+  verify       Full system verification (after setup & reboot)
+  report       Shareable hardware config
+  diagnose     Full diagnostic dump (detailed, saves to /tmp)
+  health       Check GPU health (IOTLB errors)
+
+SCRIPTING (exit codes):
+  mode           Print GPU mode: none/vm/host/not-configured (0=valid, 1=error)
+  driver         Print current GPU driver (0=success, 1=not-configured)
+  is-bound       Silent check if vfio-pci bound (0=bound, 1=not, 2=not-configured)
+  is-configured  Silent check if configured (0=yes, 1=no)
+  is-persistent  Silent check if persistent VFIO enabled (0=yes, 1=no, 2=not-configured)
+  needs-reset    Silent check if GPU has AMD reset bug (0=yes, 1=no, 2=not-configured)
+  gpu-health     Silent check for IOTLB errors (0=unhealthy, 1=ok, 2=not-configured)
+EOF
+}
+
+# Main Dispatcher
+
+case "${1:-}" in
+verify)
+  shift
+  verify_setup "$@"
+  ;;
+diagnose)
+  shift
+  cmd_diagnose "$@"
+  ;;
+report)
+  cmd_hardware_report
+  ;;
+status)
+  cmd_status
+  ;;
+stats)
+  cmd_stats
+  ;;
+detect)
+  cmd_detect
+  ;;
+driver)
+  cmd_driver
+  ;;
+mode)
+  cmd_mode
+  ;;
+is-bound)
+  cmd_is_bound
+  ;;
+is-configured)
+  cmd_is_configured
+  ;;
+is-persistent)
+  cmd_is_persistent
+  ;;
+needs-reset)
+  cmd_needs_reset
+  ;;
+gpu-health)
+  cmd_gpu_health
+  ;;
+health)
+  cmd_check_health "$@"
+  ;;
+get-docker-config)
+  cmd_get_docker_config
+  ;;
+-h | --help | help)
+  show_info_help
+  ;;
+"")
+  show_info_help
+  exit 1
+  ;;
+*)
+  echo "Unknown command: $1"
+  show_info_help
+  exit 1
+  ;;
+esac
diff --git a/bin/omarchy-gpu-passthrough-setup b/bin/omarchy-gpu-passthrough-setup
new file mode 100755
index 0000000000..c86bf6a29b
--- /dev/null
+++ b/bin/omarchy-gpu-passthrough-setup
@@ -0,0 +1,2169 @@
+#!/bin/bash
+#
+# omarchy-gpu-passthrough-setup - Setup wizard for GPU passthrough
+#
+
+set -uo pipefail
+
+# Load shared utilities
+SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
+if ! source "$SCRIPT_DIR/omarchy-gpu-passthrough-utils"; then
+  echo "ERROR: Cannot load omarchy-gpu-passthrough-utils" >&2
+  echo "Please ensure omarchy-gpu-passthrough-utils exists in: $SCRIPT_DIR" >&2
+  exit 1
+fi
+
+# Backup Functions
+
+create_backup_snapshot() {
+  local backup_dir="/var/backups/omarchy-gpu-passthrough"
+  local snapshot_dir="$backup_dir/setup-$(date +%Y%m%d-%H%M%S)"
+
+  msg_info "Creating backup snapshot..."
+
+  sudo mkdir -p "$snapshot_dir" 2>/dev/null || {
+    msg_error "Failed to create backup directory"
+    return 1
+  }
+
+  local files_backed_up=()
+
+  if [[ -f "$LIMINE_DEFAULT" ]]; then
+    sudo cp -a "$LIMINE_DEFAULT" "$snapshot_dir/limine" 2>/dev/null && files_backed_up+=("limine")
+  fi
+
+  if [[ -f "$GRUB_DEFAULT" ]]; then
+    sudo cp -a "$GRUB_DEFAULT" "$snapshot_dir/grub" 2>/dev/null && files_backed_up+=("grub")
+  fi
+
+  if [[ -f "$MKINITCPIO_CONF" ]]; then
+    sudo cp -a "$MKINITCPIO_CONF" "$snapshot_dir/mkinitcpio.conf" 2>/dev/null && files_backed_up+=("mkinitcpio.conf")
+  fi
+
+  if [[ -f "/etc/environment" ]]; then
+    sudo cp -a "/etc/environment" "$snapshot_dir/environment" 2>/dev/null && files_backed_up+=("environment")
+  fi
+
+  local real_user="${SUDO_USER:-$USER}"
+  local user_home=$(getent passwd "$real_user" | cut -d: -f6)
+
+  if [[ -z "$user_home" ]]; then
+    msg_warning "Cannot determine home directory for user $real_user"
+    log_warn "Skipping Hyprland config backup - user home not found"
+  elif [[ -f "$user_home/.config/hypr/hyprland.conf" ]]; then
+    sudo cp -a "$user_home/.config/hypr/hyprland.conf" "$snapshot_dir/hyprland.conf" 2>/dev/null && files_backed_up+=("hyprland.conf")
+  fi
+
+  if [[ "${#files_backed_up[@]}" -eq 0 ]]; then
+    msg_error "No files were backed up"
+    log_error "Backup failed: no configuration files found to backup"
+    return 1
+  fi
+
+  sudo tee "$snapshot_dir/BACKUP-INFO.txt" >/dev/null <<EOF
+GPU Passthrough Setup - Backup Snapshot
+Created: $(date)
+User: $real_user
+
+Files backed up:
+$(for file in "${files_backed_up[@]}"; do echo "  ✓  $file"; done)
+
+To restore this backup:
+  1. Copy files from this directory back to their original locations
+  2. Rebuild initramfs and bootloader config:
+     - Limine: sudo limine-mkinitcpio
+     - GRUB:   sudo mkinitcpio -P && sudo update-grub
+  3. Reboot
+
+Original locations:
+  limine           → /etc/default/limine
+  grub             → /etc/default/grub
+  mkinitcpio.conf  → /etc/mkinitcpio.conf
+  environment      → /etc/environment
+  hyprland.conf    → ~/.config/hypr/hyprland.conf
+EOF
+
+  msg_success "Backup created: $snapshot_dir (${#files_backed_up[@]} files)"
+  log_info "Backup snapshot created: $snapshot_dir (${#files_backed_up[@]} files)"
+
+  return 0
+}
+
+# Configuration Functions
+
+configure_kernel_parameters() {
+  local cpu_vendor=$(get_cpu_vendor)
+  local iommu_param=""
+
+  case "$cpu_vendor" in
+  amd) iommu_param="amd_iommu=on" ;;
+  intel) iommu_param="intel_iommu=on" ;;
+  *) iommu_param="amd_iommu=on" ;;
+  esac
+
+  local bootloader=$(detect_bootloader)
+
+  case "$bootloader" in
+  limine)
+    log_info "Bootloader: Limine (automatic configuration)"
+    configure_omarchy_limine "$iommu_param"
+    return $?
+    ;;
+  grub)
+    log_info "Bootloader: GRUB (automatic configuration)"
+    configure_grub_bootloader "$iommu_param"
+    return $?
+    ;;
+  esac
+
+  log_info "Bootloader: $bootloader (manual configuration)"
+
+  # Check if IOMMU is already enabled
+  if check_iommu_enabled_cmdline; then
+    msg_success "IOMMU already enabled"
+    return 0
+  fi
+
+  # Unsupported bootloader requires manual configuration
+  msg_section "IOMMU Configuration Required"
+
+  echo "Bootloader: $bootloader (manual config needed)"
+  echo ""
+  echo "Add to kernel cmdline:  ${iommu_param} iommu=pt"
+
+  case "$bootloader" in
+  systemd-boot)
+    echo ""
+    echo "Edit /boot/loader/entries/*.conf → options line"
+    echo "Then: reboot"
+    ;;
+  refind)
+    echo ""
+    echo "Edit /boot/refind_linux.conf → add to options"
+    echo "Then: reboot"
+    ;;
+  esac
+
+  echo ""
+
+  local choice=$(gum choose \
+    "Exit - I'll configure and reboot first" \
+    "Continue - IOMMU is already configured" \
+    "Cancel")
+
+  case "$choice" in
+  *"Exit"*)
+    msg_info "After configuring and rebooting: omarchy-gpu-passthrough setup"
+    log_info "User chose to configure bootloader manually"
+    exit 0
+    ;;
+  *"Continue"*)
+    if ! check_iommu_enabled_cmdline; then
+      msg_warning "IOMMU not detected in kernel cmdline"
+      if ! gum confirm "Continue anyway?"; then
+        exit 1
+      fi
+    fi
+    return 0
+    ;;
+  *"Cancel"*)
+    log_info "User cancelled setup"
+    exit 0
+    ;;
+  *)
+    # Empty = Ctrl+C or gum failure
+    exit 1
+    ;;
+  esac
+}
+
+# Remove dangerous kernel parameters from bootloader config
+# These can cause issues with GPU passthrough:
+#   pci=noats - disables ATS, can break IOMMU
+#   video=efifb:off - disables EFI framebuffer, can break display on AMD
+#   iommu.strict=1 - forces strict mode, can cause performance issues
+remove_dangerous_params() {
+  local config_file="$1"
+  local dangerous_params=("pci=noats" "video=efifb:off" "iommu.strict=1")
+
+  for param in "${dangerous_params[@]}"; do
+    if grep -qF "$param" "$config_file"; then
+      log_info "Removing dangerous parameter: $param"
+      local param_escaped="${param//./\\.}"
+      # Handle param at start/middle/end of line
+      sudo sed -i -E "s/(^|[[:space:]])${param_escaped}([[:space:]]|$)/\\1\\2/g" "$config_file"
+      sudo sed -i -E 's/[[:space:]]+/ /g' "$config_file"
+      msg_warning "Removed dangerous kernel parameter: $param"
+    fi
+  done
+}
+
+configure_omarchy_limine() {
+  local iommu_param="$1"
+
+  log_info "Configuring Limine kernel parameters (IOMMU: $iommu_param)"
+
+  if grep -q 'vfio-pci\.ids=' "$LIMINE_DEFAULT"; then
+    sudo sed -i -E 's/[[:space:]]*vfio-pci\.ids=[0-9a-f:,]+//g' "$LIMINE_DEFAULT"
+    sudo sed -i -E 's/[[:space:]]+/ /g' "$LIMINE_DEFAULT"
+    log_info "Removed legacy vfio-pci.ids from Limine config"
+  fi
+
+  remove_dangerous_params "$LIMINE_DEFAULT"
+
+  local all_cmdlines
+  all_cmdlines=$(grep '^KERNEL_CMDLINE\[default\]' "$LIMINE_DEFAULT" 2>/dev/null) || all_cmdlines=""
+
+  if [[ "$all_cmdlines" =~ (amd_iommu|intel_iommu)=off ]]; then
+    echo ""
+    msg_error "Conflicting IOMMU parameter detected (iommu=off)"
+    msg_info "Found IOMMU explicitly disabled in kernel parameters"
+    msg_warning "Please edit $LIMINE_DEFAULT and remove iommu=off parameter"
+    echo ""
+    log_error "Setup aborted: Conflicting IOMMU parameter (iommu=off) found in Limine config"
+    return 1
+  fi
+
+  local params_to_add=""
+
+  if ! [[ "$all_cmdlines" =~ (amd_iommu|intel_iommu)=on ]]; then
+    params_to_add="$params_to_add $iommu_param"
+    log_info "Adding IOMMU parameter: $iommu_param"
+  else
+    log_info "IOMMU parameter already present"
+  fi
+
+  if ! [[ "$all_cmdlines" =~ iommu=pt ]]; then
+    params_to_add="$params_to_add iommu=pt"
+    log_info "Adding iommu=pt parameter"
+  else
+    log_info "iommu=pt already present"
+  fi
+
+  # pci=realloc only for NVIDIA + ReBAR (can cause issues on some systems without it)
+  if [[ -n "${GPU_VENDOR_ID:-}" ]] && [[ "${GPU_VENDOR_ID}" == "10de" || "${GPU_VENDOR_ID[0]:-}" == "10de" ]]; then
+    if ! [[ "$all_cmdlines" =~ pci=realloc ]]; then
+      local gpu_pci="${GPU_PCI_ADDR:-}"
+      [[ -z "$gpu_pci" ]] && gpu_pci="${GPU_PCI_ADDR[0]:-}"
+      if [[ -n "$gpu_pci" ]] && check_resizable_bar "$gpu_pci" 2>/dev/null; then
+        params_to_add="$params_to_add pci=realloc"
+        log_info "Adding pci=realloc (NVIDIA ReBAR detected)"
+      fi
+    fi
+  fi
+
+  if [[ -n "$params_to_add" ]]; then
+    if echo "KERNEL_CMDLINE[default]+=\" $params_to_add\"" | sudo tee -a "$LIMINE_DEFAULT" >/dev/null; then
+      msg_success "Kernel parameters:$params_to_add"
+      log_info "Limine config updated:$params_to_add"
+    else
+      msg_error "Failed to update Limine config"
+      log_error "Failed to write to $LIMINE_DEFAULT"
+      return 1
+    fi
+  else
+    msg_info "Kernel parameters already set"
+    log_info "Limine kernel parameters already configured"
+  fi
+
+  return 0
+}
+
+configure_grub_bootloader() {
+  local iommu_param="$1"
+
+  log_info "Configuring GRUB kernel parameters (IOMMU: $iommu_param)"
+
+  # Validate GRUB config BEFORE creating backup
+  if ! grep -q '^GRUB_CMDLINE_LINUX_DEFAULT=' "$GRUB_DEFAULT"; then
+    msg_error "GRUB_CMDLINE_LINUX_DEFAULT not found in $GRUB_DEFAULT"
+    msg_info "Please add: GRUB_CMDLINE_LINUX_DEFAULT=\"\" to your GRUB config"
+    log_error "GRUB config missing GRUB_CMDLINE_LINUX_DEFAULT line"
+    return 1
+  fi
+
+  if ! sudo cp "$GRUB_DEFAULT" "${GRUB_DEFAULT}.backup.$(date +%Y%m%d-%H%M%S)"; then
+    msg_error "Failed to create GRUB backup"
+    log_error "Failed to backup $GRUB_DEFAULT"
+    return 1
+  fi
+  log_info "GRUB config backed up"
+
+  remove_dangerous_params "$GRUB_DEFAULT"
+
+  local grub_line current_cmdline=""
+  grub_line=$(grep '^GRUB_CMDLINE_LINUX_DEFAULT=' "$GRUB_DEFAULT" 2>/dev/null) || grub_line=""
+  [[ "$grub_line" =~ ^GRUB_CMDLINE_LINUX_DEFAULT=\"([^\"]*)\" ]] && current_cmdline="${BASH_REMATCH[1]}"
+
+  if [[ "$current_cmdline" =~ (amd_iommu|intel_iommu)=off ]]; then
+    echo ""
+    msg_error "Conflicting IOMMU parameter detected (iommu=off)"
+    msg_info "Found IOMMU explicitly disabled in kernel parameters"
+    msg_warning "Please edit $GRUB_DEFAULT and remove iommu=off parameter"
+    echo ""
+    log_error "Setup aborted: Conflicting IOMMU parameter (iommu=off) found in GRUB config"
+    return 1
+  fi
+
+  local params_to_add=""
+
+  if ! [[ "$current_cmdline" =~ (amd_iommu|intel_iommu)=on ]]; then
+    params_to_add="$params_to_add $iommu_param"
+    log_info "Adding IOMMU parameter: $iommu_param"
+  else
+    log_info "IOMMU parameter already present"
+  fi
+
+  if ! [[ "$current_cmdline" =~ iommu=pt ]]; then
+    params_to_add="$params_to_add iommu=pt"
+    log_info "Adding iommu=pt parameter"
+  else
+    log_info "iommu=pt already present"
+  fi
+
+  if [[ -n "${GPU_VENDOR_ID:-}" ]] && [[ "${GPU_VENDOR_ID}" == "10de" || "${GPU_VENDOR_ID[0]:-}" == "10de" ]]; then
+    if ! [[ "$current_cmdline" =~ pci=realloc ]]; then
+      local gpu_pci="${GPU_PCI_ADDR:-}"
+      [[ -z "$gpu_pci" ]] && gpu_pci="${GPU_PCI_ADDR[0]:-}"
+      if [[ -n "$gpu_pci" ]] && check_resizable_bar "$gpu_pci" 2>/dev/null; then
+        params_to_add="$params_to_add pci=realloc"
+        log_info "Adding pci=realloc (NVIDIA ReBAR detected)"
+      fi
+    fi
+  fi
+
+  if [[ -n "$params_to_add" ]]; then
+    params_to_add="${params_to_add# }"
+    local new_cmdline="$current_cmdline $params_to_add"
+    # Escape sed special chars in replacement: & (backreference) and \ (escape)
+    local new_cmdline_escaped="${new_cmdline//\\/\\\\}"
+    new_cmdline_escaped="${new_cmdline_escaped//&/\\&}"
+    if sudo sed -i "s|^GRUB_CMDLINE_LINUX_DEFAULT=.*|GRUB_CMDLINE_LINUX_DEFAULT=\"$new_cmdline_escaped\"|" "$GRUB_DEFAULT"; then
+      msg_success "Kernel parameters: $params_to_add"
+      log_info "GRUB config updated: $params_to_add"
+    else
+      msg_error "Failed to update GRUB config"
+      log_error "Failed to write to $GRUB_DEFAULT"
+      return 1
+    fi
+  else
+    msg_info "Kernel parameters already set"
+    log_info "GRUB kernel parameters already configured"
+  fi
+
+  local regen_cmd=$(get_grub_regenerate_cmd)
+  if [[ -n "$regen_cmd" ]]; then
+    msg_info "Regenerating GRUB config..."
+    if sudo $regen_cmd >/dev/null 2>&1; then
+      msg_success "GRUB config regenerated"
+    else
+      msg_warning "GRUB regeneration failed - run manually: $regen_cmd"
+    fi
+  else
+    msg_warning "Could not determine GRUB regenerate command"
+    msg_info "Run manually: grub-mkconfig -o /boot/grub/grub.cfg"
+  fi
+
+  return 0
+}
+
+configure_vfio_modules() {
+  local gpu_pci="$1"
+  local vendor_id="$2"
+  local device_id="$3"
+
+  # Validate gpu_pci parameter (required, system boundary)
+  if [[ -z "$gpu_pci" ]]; then
+    log_error "configure_vfio_modules: gpu_pci parameter is empty"
+    msg_error "GPU PCI address is missing"
+    return 1
+  fi
+  if ! validate_pci_address "$gpu_pci"; then
+    log_error "configure_vfio_modules: Invalid gpu_pci: $gpu_pci"
+    msg_error "Invalid GPU PCI address: $gpu_pci"
+    return 1
+  fi
+
+  local usb_ids=$(get_usb_controller_ids_in_iommu_group "$gpu_pci")
+
+  # Fallback: detect USB controllers by GPU vendor + USB class when IOMMU not active
+  if [[ -z "$usb_ids" ]] && [[ -n "$vendor_id" ]]; then
+    local gpu_vendor="$vendor_id"
+    gpu_vendor=$(echo "$gpu_vendor" | tr '[:upper:]' '[:lower:]')
+
+    if [[ "$gpu_vendor" == "10de" ]]; then
+      # NVIDIA USB controllers: find all 10de devices with class 0c03 (USB controller)
+      usb_ids=$(lspci -nn | grep -i "\[0c03\]" | grep -i "\[10de:" | grep -oP '\[10de:[0-9a-fA-F]{4}\]' | tr -d '[]' | tr '\n' ',' | sed 's/,$//')
+      if [[ -n "$usb_ids" ]]; then
+        log_warn "IOMMU not active - detected NVIDIA USB controllers by vendor ID: $usb_ids"
+        msg_warning "IOMMU not yet active (first boot) - using vendor-based USB detection"
+      fi
+    fi
+  fi
+
+  if [[ -n "$usb_ids" ]]; then
+    log_info "USB controllers in IOMMU group need early binding: $usb_ids"
+    msg_info "USB controller detected in IOMMU group - enabling early binding"
+  fi
+
+  # Determine if GPU needs vfio-pci.ids (early binding at boot)
+  # Required when we can't blacklist the driver:
+  # - MUX-less laptops: dGPU driver (nvidia/amdgpu) can't be blacklisted
+  # - AMD desktops: amdgpu used by both iGPU and dGPU, can't blacklist
+  local gpu_device_ids=""
+  local use_vfio_ids=false
+
+  if [[ "$IS_MUXLESS_LAPTOP" == "true" ]]; then
+    # MUX-less laptops: check for Hybrid Mode
+    if [[ "${HYBRID_MUXLESS_MODE:-false}" == "true" ]]; then
+      log_info "Hybrid Mode: GPU will use runtime binding"
+      msg_info "VFIO: Runtime binding (driver stays active)"
+    else
+      use_vfio_ids=true
+    fi
+  elif [[ "$vendor_id" == "1002" ]]; then
+    # AMD dGPU on desktop: can't blacklist amdgpu (iGPU uses it too)
+    use_vfio_ids=true
+    log_info "AMD desktop: using vfio-pci.ids (can't blacklist amdgpu)"
+  fi
+
+  if [[ "$use_vfio_ids" == "true" ]]; then
+    # Validate that vendor_id and device_id were passed (system boundary input)
+    if [[ -z "$vendor_id" ]] || [[ -z "$device_id" ]]; then
+      log_error "configure_vfio_modules: vfio-pci.ids requires vendor_id and device_id parameters"
+      msg_error "vfio-pci.ids configuration requires GPU vendor and device IDs"
+      return 1
+    fi
+
+    # Validate ID format - must be 4 hex digits (prevents malformed kernel parameters)
+    if ! [[ "$vendor_id" =~ ^[0-9a-fA-F]{4}$ ]]; then
+      log_error "configure_vfio_modules: Invalid vendor ID format: $vendor_id (expected 4 hex digits)"
+      msg_error "Invalid GPU vendor ID: $vendor_id (expected 4 hex digits)"
+      return 1
+    fi
+    if ! [[ "$device_id" =~ ^[0-9a-fA-F]{4}$ ]]; then
+      log_error "configure_vfio_modules: Invalid device ID format: $device_id (expected 4 hex digits)"
+      msg_error "Invalid GPU device ID: $device_id (expected 4 hex digits)"
+      return 1
+    fi
+
+    gpu_device_ids="${vendor_id}:${device_id}"
+
+    # Also bind audio device if present (same IOMMU group, needed for clean passthrough)
+    local audio_id=$(get_gpu_audio_device "$gpu_pci")
+    if [[ -n "$audio_id" ]]; then
+      gpu_device_ids="${gpu_device_ids},${audio_id}"
+      log_info "Early binding: dGPU + audio to vfio-pci at boot (${vendor_id}:${device_id}, ${audio_id})"
+    else
+      log_info "Early binding: dGPU to vfio-pci at boot (${vendor_id}:${device_id})"
+    fi
+  fi
+
+  # Combine GPU device IDs and USB controller IDs
+  local all_ids=""
+  [[ -n "$gpu_device_ids" ]] && all_ids="$gpu_device_ids"
+  [[ -n "$usb_ids" ]] && all_ids="${all_ids:+${all_ids},}${usb_ids}"
+
+  {
+    echo "# VFIO GPU Passthrough - Generated $(date +%Y-%m-%d)"
+    [[ -n "$all_ids" ]] && echo "options vfio-pci ids=$all_ids"
+    echo "options vfio-pci disable_vga=1"
+    echo "options vfio-pci disable_idle_d3=1"
+    # Ensure vfio-pci loads before xhci_pci to prevent USB controller rebind
+    [[ -n "$usb_ids" ]] && echo "softdep xhci_pci pre: vfio-pci"
+    # Ensure vfio-pci loads before nvidia modules (MUX-less laptops)
+    if [[ "$vendor_id" == "10de" ]]; then
+      echo "softdep nvidia pre: vfio-pci"
+      echo "softdep nvidia_modeset pre: vfio-pci"
+      echo "softdep nvidia_uvm pre: vfio-pci"
+      echo "softdep nvidia_drm pre: vfio-pci"
+    fi
+  } | sudo tee "$VFIO_CONF" >/dev/null
+
+  # Create udev rule for persistent driver_override (prevents xhci_hcd rebind)
+  # Using RUN+= instead of ATTR{} because ATTR doesn't trigger bind
+  if [[ -n "$usb_ids" ]]; then
+    local udev_rules_file="/etc/udev/rules.d/99-vfio-usb-override.rules"
+    {
+      echo "# Prevent xhci_hcd from rebinding USB controllers in GPU IOMMU group"
+      echo "# Generated $(date +%Y-%m-%d) by omarchy-gpu-passthrough"
+      local id
+      for id in $(echo "$usb_ids" | tr ',' ' '); do
+        local vendor="${id%%:*}"
+        local device="${id##*:}"
+        echo "ACTION==\"add\", SUBSYSTEM==\"pci\", ATTR{vendor}==\"0x$vendor\", ATTR{device}==\"0x$device\", RUN+=\"/bin/sh -c 'echo vfio-pci > /sys/bus/pci/devices/%k/driver_override'\""
+      done
+    } | sudo tee "$udev_rules_file" >/dev/null
+    sudo udevadm control --reload-rules
+    log_info "USB controller udev rule created: $udev_rules_file"
+  fi
+
+  msg_success "VFIO config: $VFIO_CONF"
+  return 0
+}
+
+configure_kvm_options() {
+  local cpu_vendor
+  cpu_vendor=$(get_cpu_vendor)
+
+  if [[ -f "$KVM_CONF" ]] && grep -q "ignore_msrs=1" "$KVM_CONF" 2>/dev/null; then
+    msg_info "KVM options already configured"
+    return 0
+  fi
+
+  local kvm_content="# KVM options for Windows VM - Generated $(date +%Y-%m-%d)
+options kvm ignore_msrs=1
+options kvm report_ignored_msrs=0"
+
+  case "$cpu_vendor" in
+    amd) kvm_content+=$'\n'"options kvm_amd nested=1" ;;
+    intel) kvm_content+=$'\n'"options kvm_intel nested=1" ;;
+  esac
+
+  if ! echo "$kvm_content" | sudo tee "$KVM_CONF" >/dev/null; then
+    msg_error "Failed to write $KVM_CONF"
+    return 1
+  fi
+
+  msg_success "KVM options: $KVM_CONF"
+  return 0
+}
+
+configure_gpu_blacklist() {
+  local vendor_id="$1"
+
+  local gpu_vendor=""
+  case "$vendor_id" in
+  10de) gpu_vendor="nvidia" ;;
+  1002) gpu_vendor="amdgpu" ;;
+  8086) gpu_vendor="i915" ;;
+  *)
+    msg_warning "Unknown GPU vendor: $vendor_id"
+    return 1
+    ;;
+  esac
+
+  if [[ "$gpu_vendor" == "nvidia" ]]; then
+    sudo tee "$BLACKLIST_CONF" >/dev/null <<EOF
+# GPU Passthrough - Prevent NVIDIA auto-load at boot
+# Display handled by iGPU, NVIDIA used only for VM passthrough
+install nvidia /bin/false
+EOF
+    msg_success "NVIDIA blacklist: $BLACKLIST_CONF"
+  else
+    if [[ -f "$BLACKLIST_CONF" ]]; then
+      sudo rm -f "$BLACKLIST_CONF"
+    fi
+  fi
+
+  return 0
+}
+
+configure_pci_binding_permissions() {
+  local udev_rules_file="/etc/udev/rules.d/90-vfio-pci-permissions.rules"
+
+  sudo tee "$udev_rules_file" >/dev/null <<'EOF'
+# Allow kvm group to bind/unbind PCI devices for GPU passthrough
+# This allows passwordless GPU mode switching (omarchy-gpu-passthrough mode vm/host/none)
+
+# Allow kvm group to rescan PCI bus
+SUBSYSTEM=="pci", KERNEL=="pci*", \
+  RUN+="/bin/sh -c 'chmod 0660 /sys/bus/pci/rescan 2>/dev/null; chgrp kvm /sys/bus/pci/rescan 2>/dev/null'"
+
+# When vfio-pci module is loaded, make control files writable by kvm group
+KERNEL=="vfio-pci", SUBSYSTEM=="module", \
+  RUN+="/bin/sh -c 'chmod 0660 /sys/bus/pci/drivers/vfio-pci/{bind,unbind,new_id,remove_id} 2>/dev/null; chgrp kvm /sys/bus/pci/drivers/vfio-pci/{bind,unbind,new_id,remove_id} 2>/dev/null'"
+
+# Allow kvm group to bind/unbind from native GPU drivers (nvidia, amdgpu, i915)
+KERNEL=="nvidia", SUBSYSTEM=="module", \
+  RUN+="/bin/sh -c 'chmod 0660 /sys/bus/pci/drivers/nvidia/{bind,unbind,new_id,remove_id} 2>/dev/null; chgrp kvm /sys/bus/pci/drivers/nvidia/{bind,unbind,new_id,remove_id} 2>/dev/null'"
+
+KERNEL=="amdgpu", SUBSYSTEM=="module", \
+  RUN+="/bin/sh -c 'chmod 0660 /sys/bus/pci/drivers/amdgpu/{bind,unbind,new_id,remove_id} 2>/dev/null; chgrp kvm /sys/bus/pci/drivers/amdgpu/{bind,unbind,new_id,remove_id} 2>/dev/null'"
+
+KERNEL=="i915", SUBSYSTEM=="module", \
+  RUN+="/bin/sh -c 'chmod 0660 /sys/bus/pci/drivers/i915/{bind,unbind,new_id,remove_id} 2>/dev/null; chgrp kvm /sys/bus/pci/drivers/i915/{bind,unbind,new_id,remove_id} 2>/dev/null'"
+
+# For each PCI device bound to any driver, allow kvm group to unbind it
+SUBSYSTEM=="pci", ACTION=="bind", \
+  RUN+="/bin/sh -c 'chmod 0660 /sys/bus/pci/devices/$kernel/driver/unbind 2>/dev/null; chgrp kvm /sys/bus/pci/devices/$kernel/driver/unbind 2>/dev/null'"
+
+# Allow kvm group to probe drivers
+SUBSYSTEM=="pci", ACTION=="add", \
+  RUN+="/bin/sh -c 'chmod 0660 /sys/bus/pci/drivers_probe 2>/dev/null; chgrp kvm /sys/bus/pci/drivers_probe 2>/dev/null'"
+EOF
+
+  # Reload udev rules
+  sudo udevadm control --reload-rules
+  sudo udevadm trigger --subsystem-match=pci
+
+  # Apply permissions immediately (don't wait for reboot/module reload)
+  sudo chmod 0660 /sys/bus/pci/rescan 2>/dev/null || true
+  sudo chgrp kvm /sys/bus/pci/rescan 2>/dev/null || true
+  sudo chmod 0660 /sys/bus/pci/drivers_probe 2>/dev/null || true
+  sudo chgrp kvm /sys/bus/pci/drivers_probe 2>/dev/null || true
+
+  # If vfio-pci is already loaded, apply permissions now
+  if is_module_loaded vfio_pci; then
+    sudo chmod 0660 /sys/bus/pci/drivers/vfio-pci/{bind,unbind,new_id,remove_id} 2>/dev/null || true
+    sudo chgrp kvm /sys/bus/pci/drivers/vfio-pci/{bind,unbind,new_id,remove_id} 2>/dev/null || true
+  fi
+
+  # If native GPU drivers are loaded, apply permissions now
+  if is_module_loaded nvidia; then
+    sudo chmod 0660 /sys/bus/pci/drivers/nvidia/{bind,unbind,new_id,remove_id} 2>/dev/null || true
+    sudo chgrp kvm /sys/bus/pci/drivers/nvidia/{bind,unbind,new_id,remove_id} 2>/dev/null || true
+  fi
+
+  if is_module_loaded amdgpu; then
+    sudo chmod 0660 /sys/bus/pci/drivers/amdgpu/{bind,unbind,new_id,remove_id} 2>/dev/null || true
+    sudo chgrp kvm /sys/bus/pci/drivers/amdgpu/{bind,unbind,new_id,remove_id} 2>/dev/null || true
+  fi
+
+  if is_module_loaded i915; then
+    sudo chmod 0660 /sys/bus/pci/drivers/i915/{bind,unbind,new_id,remove_id} 2>/dev/null || true
+    sudo chgrp kvm /sys/bus/pci/drivers/i915/{bind,unbind,new_id,remove_id} 2>/dev/null || true
+  fi
+
+  msg_success "PCI permissions: kvm group can bind/unbind devices"
+  return 0
+}
+
+configure_gpu_state_tmpfiles() {
+  local tmpfiles_gpu_state_file="/etc/tmpfiles.d/omarchy-gpu-passthrough.conf"
+
+  sudo tee "$tmpfiles_gpu_state_file" >/dev/null <<'EOF'
+# Omarchy GPU Passthrough - State marker file
+# Tracks current GPU mode (none/vm/host)
+# Auto-recreated on boot (tmpfs cleanup)
+f /var/run/omarchy-vm-gpu-mode 0664 root kvm - none
+EOF
+
+  # Apply immediately (don't wait for reboot)
+  if ! sudo systemd-tmpfiles --create "$tmpfiles_gpu_state_file" 2>/dev/null; then
+    msg_warning "Failed to apply tmpfiles now (will work after reboot)"
+  fi
+
+  msg_success "GPU state marker tmpfiles configured"
+
+  return 0
+}
+
+configure_sudoers_gpu_passthrough() {
+  local sudoers_file="/etc/sudoers.d/omarchy-gpu-passthrough"
+  local real_user="${SUDO_USER:-$USER}"
+
+  if [[ -z "$real_user" ]] || [[ "$real_user" =~ [^a-zA-Z0-9_-] ]]; then
+    msg_error "Invalid username: $real_user"
+    return 1
+  fi
+
+  local sudoers_content="# Omarchy GPU Passthrough - Passwordless Operations
+# Generated by omarchy-gpu-passthrough setup
+
+# GPU process detection
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/fuser -v /dev/nvidia*
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/fuser -v /dev/dri/*
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/fuser -v /dev/dri/card*
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/fuser -v /dev/vfio/*
+
+# GPU module operations
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/modprobe vfio-pci
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/modprobe -r nvidia*
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/modprobe -r amdgpu
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/modprobe -r i915
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/modprobe -i nvidia
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/modprobe -i nvidia_uvm
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/modprobe -i nvidia_drm
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/modprobe -i nvidia_drm modeset=1
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/modprobe amdgpu
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/modprobe i915
+
+# PCI sysfs operations (driver bind/unbind)
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/tee /sys/bus/pci/drivers/vfio-pci/new_id
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/tee /sys/bus/pci/drivers/vfio-pci/bind
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/tee /sys/bus/pci/drivers/vfio-pci/unbind
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/tee /sys/bus/pci/drivers/vfio-pci/remove_id
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/tee /sys/bus/pci/drivers/nvidia/bind
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/tee /sys/bus/pci/drivers/amdgpu/bind
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/tee /sys/bus/pci/drivers/i915/bind
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/tee /sys/bus/pci/drivers/xhci_hcd/bind
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/tee /sys/bus/pci/rescan
+
+# PCI device operations (for dynamic PCI device paths)
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/tee /sys/bus/pci/devices/*/driver/unbind
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/tee /sys/bus/pci/devices/*/driver_override
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/tee /sys/bus/pci/devices/*/reset
+
+# Audio device unbinding (required for complete IOMMU group)
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/tee /sys/bus/pci/drivers/snd_hda_intel/bind
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/tee /sys/bus/pci/drivers/snd_hda_intel/unbind
+
+# State marker file (GPU mode tracking)
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/tee /var/run/omarchy-vm-gpu-mode
+$real_user ALL=(ALL) NOPASSWD: /usr/bin/rm -f /var/run/omarchy-vm-gpu-mode
+"
+
+  # Create temporary file with error handling
+  local temp_file
+  temp_file=$(mktemp) || {
+    msg_error "Failed to create temporary file"
+    return 1
+  }
+
+  # Write content with error handling
+  if ! echo "$sudoers_content" > "$temp_file"; then
+    msg_error "Failed to write to temporary file"
+    rm -f "$temp_file"
+    return 1
+  fi
+
+  # Validate sudoers syntax
+  if ! sudo visudo -c -f "$temp_file" 2>&1 | grep -q "parsed OK"; then
+    msg_error "Sudoers syntax validation failed!"
+    rm -f "$temp_file"
+    return 1
+  fi
+
+  # Install sudoers file
+  if ! sudo install -m 440 -o root -g root "$temp_file" "$sudoers_file"; then
+    msg_error "Failed to install sudoers file"
+    rm -f "$temp_file"
+    return 1
+  fi
+
+  # Cleanup
+  rm -f "$temp_file"
+
+  return 0
+}
+
+unconfigure_sudoers_gpu_passthrough() {
+  local sudoers_file="/etc/sudoers.d/omarchy-gpu-passthrough"
+
+  if sudo test -f "$sudoers_file"; then
+    sudo rm -f "$sudoers_file"
+    msg_success "GPU passthrough sudoers removed"
+  fi
+
+  return 0
+}
+
+unconfigure_gpu_state_tmpfiles() {
+  local tmpfiles_file="/etc/tmpfiles.d/omarchy-gpu-passthrough.conf"
+
+  if sudo test -f "$tmpfiles_file"; then
+    sudo rm -f "$tmpfiles_file"
+    msg_success "GPU state marker tmpfiles removed"
+  fi
+
+  return 0
+}
+
+remove_vfio_from_mkinitcpio() {
+  sudo sed -i -E '/^MODULES=/s/\bvfio_pci\b//g; /^MODULES=/s/\bvfio-pci\b//g; /^MODULES=/s/\bvfio\b//g; /^MODULES=/s/\bvfio_iommu_type1\b//g' "$MKINITCPIO_CONF"
+}
+
+cleanup_mkinitcpio_modules_whitespace() {
+  sudo sed -i -E '/^MODULES=/s/[[:space:]]{2,}/ /g' "$MKINITCPIO_CONF"
+  sudo sed -i -E '/^MODULES=/s/\([[:space:]]+/(/g' "$MKINITCPIO_CONF"
+  sudo sed -i -E '/^MODULES=/s/[[:space:]]+\)/)/g' "$MKINITCPIO_CONF"
+}
+
+configure_vfio_modules_mkinitcpio() {
+  if [[ ! -f "$MKINITCPIO_CONF" ]]; then
+    msg_warning "$MKINITCPIO_CONF not found"
+    return 1
+  fi
+
+  # Verify modconf hook is present (required for /etc/modprobe.d/* in initramfs)
+  local current_hooks
+  current_hooks=$(grep "^HOOKS=" "$MKINITCPIO_CONF" 2>/dev/null | head -1) || current_hooks=""
+  if [[ -n "$current_hooks" ]] && [[ ! "$current_hooks" =~ modconf ]]; then
+    msg_warning "modconf hook missing from HOOKS - softdep may not work"
+    log_warn "modconf not in HOOKS: $current_hooks"
+  fi
+
+  local current_modules
+  current_modules=$(grep "^MODULES=" "$MKINITCPIO_CONF" 2>/dev/null | head -1) || current_modules=""
+
+  if [[ "$current_modules" =~ nvidia ]]; then
+    msg_info "Removing NVIDIA modules from initramfs..."
+    sudo sed -i -E '/^MODULES=/s/\bnvidia\b//g' "$MKINITCPIO_CONF"
+    sudo sed -i -E '/^MODULES=/s/\bnvidia_modeset\b//g' "$MKINITCPIO_CONF"
+    sudo sed -i -E '/^MODULES=/s/\bnvidia_uvm\b//g' "$MKINITCPIO_CONF"
+    sudo sed -i -E '/^MODULES=/s/\bnvidia_drm\b//g' "$MKINITCPIO_CONF"
+    msg_success "  NVIDIA modules removed"
+  fi
+
+  local host_driver=""
+  if [[ -n "${IGPU_PCI:-}" ]]; then
+    local igpu_vendor
+    igpu_vendor=$(lspci -n -s "$IGPU_PCI" 2>/dev/null | awk '{print $3}' | cut -d: -f1)
+    case "$igpu_vendor" in
+      8086) host_driver="i915" ;;
+      1002) host_driver="amdgpu" ;;
+    esac
+  fi
+
+  current_modules=$(grep "^MODULES=" "$MKINITCPIO_CONF" 2>/dev/null | head -1) || current_modules=""
+
+  local vfio_modules="vfio_pci vfio vfio_iommu_type1"
+
+  if [[ "$current_modules" =~ vfio_pci|vfio-pci ]]; then
+    if [[ -z "$host_driver" ]]; then
+      msg_info "VFIO modules already in initramfs"
+      return 0
+    elif [[ "$current_modules" =~ $host_driver.*vfio_pci ]]; then
+      msg_info "VFIO modules already in initramfs (order OK)"
+      return 0
+    else
+      msg_warning "Fixing module order ($host_driver must load before vfio)"
+      remove_vfio_from_mkinitcpio
+      current_modules=$(grep "^MODULES=" "$MKINITCPIO_CONF" 2>/dev/null | head -1) || current_modules=""
+    fi
+  fi
+
+  if [[ "$current_modules" =~ ^MODULES=\([[:space:]]*\)$ ]]; then
+    if [[ -n "$host_driver" ]]; then
+      sudo sed -i "s/^MODULES=([[:space:]]*)$/MODULES=($host_driver $vfio_modules)/" "$MKINITCPIO_CONF"
+    else
+      sudo sed -i "s/^MODULES=([[:space:]]*)$/MODULES=($vfio_modules)/" "$MKINITCPIO_CONF"
+    fi
+  elif [[ -n "$host_driver" ]] && [[ "$current_modules" =~ $host_driver ]]; then
+    sudo sed -i "/^MODULES=/s/\b$host_driver\b/$host_driver $vfio_modules/" "$MKINITCPIO_CONF"
+  elif [[ -n "$host_driver" ]]; then
+    sudo sed -i "s/^MODULES=([[:space:]]*/MODULES=($host_driver $vfio_modules /" "$MKINITCPIO_CONF"
+  else
+    sudo sed -i "s/^MODULES=([[:space:]]*/MODULES=($vfio_modules /" "$MKINITCPIO_CONF"
+  fi
+
+  cleanup_mkinitcpio_modules_whitespace
+
+  if [[ -n "$host_driver" ]]; then
+    msg_success "VFIO modules added (order: $host_driver → vfio)"
+  else
+    msg_success "VFIO modules added to initramfs"
+  fi
+  return 0
+}
+
+configure_system_environment() {
+  local igpu_pci="$1"
+
+  if ! validate_pci_address "$igpu_pci"; then
+    msg_error "Invalid PCI address: $igpu_pci"
+    return 1
+  fi
+
+  local env_file="/etc/environment"
+
+  # Clean any old GPU-related env vars from /etc/environment
+  # We don't need to set AQ_DRM_DEVICES - when dGPU is blacklisted,
+  # compositors will automatically select the only available GPU (iGPU)
+  if [[ -f "$env_file" ]]; then
+    sudo sed -i '/^WLR_DRM_DEVICES=/d' "$env_file"
+    sudo sed -i '/^AQ_DRM_DEVICES=/d' "$env_file"
+    sudo sed -i '/# GPU Passthrough Configuration/d' "$env_file"
+    sudo sed -i '/# GPU Passthrough - Force Hyprland to iGPU/d' "$env_file"
+  fi
+
+  msg_success "System env: cleaned GPU settings (auto-detect enabled)"
+
+  return 0
+}
+
+configure_hyprland_igpu() {
+  local igpu_pci="$1"
+
+  if ! validate_pci_address "$igpu_pci"; then
+    msg_error "Invalid PCI address: $igpu_pci"
+    return 1
+  fi
+
+  local real_user="${SUDO_USER:-$USER}"
+  if ! id "$real_user" &>/dev/null; then
+    msg_error "User $real_user not found"
+    return 1
+  fi
+
+  local user_home=$(getent passwd "$real_user" | cut -d: -f6)
+  if [[ -z "$user_home" ]]; then
+    msg_error "Could not determine home directory"
+    return 1
+  fi
+
+  local hypr_conf="$user_home/.config/hypr/hyprland.conf"
+  if [[ ! -f "$hypr_conf" ]]; then
+    msg_warning "Hyprland config not found - skipping Hyprland configuration"
+    log_info "Hyprland config not found at $hypr_conf - user may not use Hyprland"
+    return 0
+  fi
+
+  # Clean any old GPU-related env vars from Hyprland config
+  if [[ -w "$hypr_conf" ]]; then
+    sed -i '/^env = WLR_DRM_DEVICES,/d' "$hypr_conf"
+    sed -i '/^env = AQ_DRM_DEVICES,/d' "$hypr_conf"
+    sed -i '/^env = DRI_PRIME,/d' "$hypr_conf"
+    sed -i '/^env = __GLX_VENDOR_LIBRARY_NAME,/d' "$hypr_conf"
+    sed -i '/^env = LIBVA_DRIVER_NAME,/d' "$hypr_conf"
+    sed -i '/^env = NVD_BACKEND,/d' "$hypr_conf"
+    sed -i '/# GPU Passthrough Configuration/d' "$hypr_conf"
+    sed -i '/# GPU Passthrough - Force iGPU/d' "$hypr_conf"
+  else
+    sudo sed -i '/^env = WLR_DRM_DEVICES,/d' "$hypr_conf"
+    sudo sed -i '/^env = AQ_DRM_DEVICES,/d' "$hypr_conf"
+    sudo sed -i '/^env = DRI_PRIME,/d' "$hypr_conf"
+    sudo sed -i '/^env = __GLX_VENDOR_LIBRARY_NAME,/d' "$hypr_conf"
+    sudo sed -i '/^env = LIBVA_DRIVER_NAME,/d' "$hypr_conf"
+    sudo sed -i '/^env = NVD_BACKEND,/d' "$hypr_conf"
+    sudo sed -i '/# GPU Passthrough Configuration/d' "$hypr_conf"
+    sudo sed -i '/# GPU Passthrough - Force iGPU/d' "$hypr_conf"
+  fi
+
+  [[ -n "${SUDO_USER:-}" ]] && chown "$SUDO_USER:$(id -gn "$SUDO_USER")" "$hypr_conf" 2>/dev/null
+
+  # For MUX-less laptops: dGPU is NOT blacklisted (uses vfio-pci.ids)
+  # EGL probing will still open /dev/nvidia* handles unless we force Mesa
+  if [[ "$IS_MUXLESS_LAPTOP" == "true" ]]; then
+    configure_uwsm_env_muxless "$igpu_pci" "$user_home"
+    msg_success "Hyprland: GPU passthrough environment configured (MUX-less)"
+    return 0
+  fi
+
+  msg_success "Hyprland: cleaned GPU settings (auto-detect enabled)"
+  # Message depends on binding method - check if vfio-pci.ids is configured
+  if [[ -f "$VFIO_CONF" ]] && grep -q "^options vfio-pci ids=" "$VFIO_CONF" 2>/dev/null; then
+    msg_info "Hyprland will auto-select iGPU (dGPU bound to vfio-pci at boot)"
+  else
+    msg_info "Hyprland will auto-select iGPU (dGPU is blacklisted)"
+  fi
+
+  return 0
+}
+
+# Helper: Ensure UWSM env file exists and is writable
+_ensure_uwsm_file() {
+  local file_path="$1"
+  local user_home="$2"
+  local uwsm_dir="$user_home/.config/uwsm"
+  local config_dir="$user_home/.config"
+  USE_SUDO=""
+
+  # Determine if we need sudo (check parent dir writability)
+  if [[ -d "$uwsm_dir" ]]; then
+    [[ ! -w "$uwsm_dir" ]] && USE_SUDO="sudo"
+  elif [[ -d "$config_dir" ]]; then
+    [[ ! -w "$config_dir" ]] && USE_SUDO="sudo"
+  else
+    USE_SUDO="sudo"
+  fi
+
+  # Ensure directory exists
+  if [[ ! -d "$uwsm_dir" ]]; then
+    if ! $USE_SUDO mkdir -p "$uwsm_dir" 2>/dev/null; then
+      log_warn "Could not create UWSM config dir: $uwsm_dir"
+      return 1
+    fi
+    [[ -n "${SUDO_USER:-}" ]] && $USE_SUDO chown "$SUDO_USER:$(id -gn "$SUDO_USER")" "$uwsm_dir" 2>/dev/null
+  fi
+
+  # Create file if it doesn't exist
+  if [[ ! -f "$file_path" ]]; then
+    if ! $USE_SUDO touch "$file_path" 2>/dev/null; then
+      log_warn "Could not create UWSM file: $file_path"
+      return 1
+    fi
+    [[ -n "${SUDO_USER:-}" ]] && $USE_SUDO chown "$SUDO_USER:$(id -gn "$SUDO_USER")" "$file_path" 2>/dev/null
+  fi
+
+  # Update sudo requirement for file operations
+  if [[ -f "$file_path" && ! -w "$file_path" ]]; then
+    USE_SUDO="sudo"
+  fi
+
+  return 0
+}
+
+# Helper: Write content to UWSM file with proper section markers
+# Args: $1 = file path, $2 = content (without markers), $3 = section name (optional, default: "GPU Passthrough")
+_write_uwsm_section() {
+  local file_path="$1"
+  local content="$2"
+  local section_name="${3:-GPU Passthrough}"
+  local begin_marker="# BEGIN ${section_name} Configuration"
+  local end_marker="# END ${section_name} Configuration"
+
+  # Remove old section if exists
+  if grep -q "$begin_marker" "$file_path" 2>/dev/null; then
+    $USE_SUDO sed -i "/${begin_marker//\//\\/}/,/${end_marker//\//\\/}/d" "$file_path"
+  fi
+
+  # Add newline prefix if file is non-empty and doesn't end with newline
+  local prefix_newline=""
+  if [[ -s "$file_path" ]]; then
+    if [[ "$(tail -c1 "$file_path" 2>/dev/null | wc -l)" -eq 0 ]]; then
+      prefix_newline=$'\n'
+    fi
+  fi
+
+  local full_content="${prefix_newline}${begin_marker}
+${content}
+${end_marker}"
+
+  if [[ -n "$USE_SUDO" ]]; then
+    if ! echo "$full_content" | $USE_SUDO tee -a "$file_path" >/dev/null; then
+      log_warn "Failed to write to $file_path"
+      return 1
+    fi
+  else
+    if ! echo "$full_content" >> "$file_path"; then
+      log_warn "Failed to write to $file_path"
+      return 1
+    fi
+  fi
+
+  [[ -n "${SUDO_USER:-}" ]] && $USE_SUDO chown "$SUDO_USER:$(id -gn "$SUDO_USER")" "$file_path" 2>/dev/null
+  return 0
+}
+
+# Configure UWSM environment for AMD runtime binding (iGPU + dGPU same vendor)
+# Writes AQ_DRM_DEVICES to env-hyprland (Hyprland-specific variables)
+# Ref: https://wiki.hypr.land/Configuring/Environment-variables/
+configure_uwsm_env_amd_runtime() {
+  local igpu_pci="$1"
+  local user_home="$2"
+  local uwsm_env_hyprland="$user_home/.config/uwsm/env-hyprland"
+
+  # Use stable symlink created by udev rule (create_gpu_symlink_udev_rule)
+  # /dev/dri/igpu is stable across reboots, unlike card0/card1/card2
+  local drm_device="/dev/dri/igpu"
+
+  # Verify symlink exists (created by udev rule)
+  if [[ ! -L "$drm_device" ]] && [[ ! -e "$drm_device" ]]; then
+    log_warn "Stable symlink $drm_device not found - udev rule may not be applied yet"
+    msg_warning "GPU symlink not ready (will work after reboot)"
+  fi
+
+  log_info "Configuring UWSM env-hyprland for AMD runtime binding: iGPU=$igpu_pci → $drm_device"
+
+  # Configure env-hyprland for AQ_* variables (Hyprland-specific)
+  if ! _ensure_uwsm_file "$uwsm_env_hyprland" "$user_home"; then
+    msg_warning "Could not create UWSM env-hyprland file"
+    return 0
+  fi
+
+  local hyprland_content="# Use iGPU only - dGPU free for VM passthrough
+# Uses stable /dev/dri/igpu symlink (created by udev rule based on PCI slot)
+export AQ_DRM_DEVICES=\"${drm_device}\""
+
+  if ! _write_uwsm_section "$uwsm_env_hyprland" "$hyprland_content"; then
+    msg_warning "Could not write GPU passthrough configuration"
+    return 1
+  fi
+
+  msg_info "UWSM env-hyprland: Restrict Hyprland to $drm_device (iGPU)"
+  return 0
+}
+
+# Configure UWSM environment for MUX-less laptops (NVIDIA dGPU + AMD/Intel iGPU)
+# Writes to TWO files per UWSM documentation:
+#   - env: Mesa EGL forcing (prevents NVIDIA handles from opening)
+#   - env-hyprland: AQ_DRM_DEVICES (Hyprland-specific Aquamarine settings)
+# Ref: https://wiki.hypr.land/Configuring/Environment-variables/
+# Ref: https://github.com/Vladimir-csp/uwsm
+configure_uwsm_env_muxless() {
+  local igpu_pci="$1"
+  local user_home="$2"
+  local uwsm_env="$user_home/.config/uwsm/env"
+  local uwsm_env_hyprland="$user_home/.config/uwsm/env-hyprland"
+
+  # Use stable symlink created by udev rule (create_gpu_symlink_udev_rule)
+  # /dev/dri/igpu is stable across reboots, unlike card0/card1/card2
+  local drm_device="/dev/dri/igpu"
+
+  # Verify symlink exists (created by udev rule)
+  if [[ ! -L "$drm_device" ]] && [[ ! -e "$drm_device" ]]; then
+    log_warn "Stable symlink $drm_device not found - udev rule may not be applied yet"
+    msg_warning "GPU symlink not ready (will work after reboot)"
+  fi
+
+  log_info "Configuring UWSM for MUX-less: iGPU=$igpu_pci → $drm_device"
+
+  # Check if Mesa EGL vendor file exists
+  local mesa_egl="/usr/share/glvnd/egl_vendor.d/50_mesa.json"
+  if [[ ! -f "$mesa_egl" ]]; then
+    log_warn "Mesa EGL vendor file not found: $mesa_egl"
+    msg_warning "Mesa EGL not found - GPU isolation may not work"
+    return 0
+  fi
+
+  # Configure env (Mesa/toolkit variables - common to all compositors) ===
+  if ! _ensure_uwsm_file "$uwsm_env" "$user_home"; then
+    msg_warning "Could not create UWSM env file"
+    return 0
+  fi
+
+  local env_content="# Force Mesa EGL to prevent NVIDIA handles from being opened by Hyprland
+export __EGL_VENDOR_LIBRARY_FILENAMES=\"${mesa_egl}\"
+export __GLX_VENDOR_LIBRARY_NAME=\"mesa\"
+export __NV_PRIME_RENDER_OFFLOAD=0"
+
+  if ! _write_uwsm_section "$uwsm_env" "$env_content"; then
+    msg_warning "Could not write GPU passthrough configuration to env"
+    return 1
+  fi
+  log_info "UWSM env: Force Mesa EGL (prevents NVIDIA handle probing)"
+
+  # Configure env-hyprland (Hyprland-specific AQ_* variables) ===
+  if ! _ensure_uwsm_file "$uwsm_env_hyprland" "$user_home"; then
+    msg_warning "Could not create UWSM env-hyprland file"
+    return 0
+  fi
+
+  local hyprland_content="# Use iGPU only - dGPU free for VM passthrough
+# Uses stable /dev/dri/igpu symlink (created by udev rule based on PCI slot)
+export AQ_DRM_DEVICES=\"${drm_device}\""
+
+  if ! _write_uwsm_section "$uwsm_env_hyprland" "$hyprland_content"; then
+    msg_warning "Could not write GPU passthrough configuration to env-hyprland"
+    return 1
+  fi
+  log_info "UWSM env-hyprland: Restrict Hyprland to $drm_device (iGPU)"
+
+  msg_info "UWSM configured: Mesa EGL (env) + AQ_DRM_DEVICES (env-hyprland)"
+  return 0
+}
+
+# Unconfiguration Functions
+
+unconfigure_system_environment() {
+  local env_file="/etc/environment"
+
+  if [[ ! -f "$env_file" ]]; then
+    return 0
+  fi
+
+  if ! grep -q "^WLR_DRM_DEVICES=" "$env_file" &&
+    ! grep -q "^AQ_DRM_DEVICES=" "$env_file" &&
+    ! grep -q "# GPU Passthrough Configuration" "$env_file"; then
+    return 0
+  fi
+
+  sudo cp "$env_file" "${env_file}.backup.uninstall.$(date +%s)"
+  sudo sed -i '/^WLR_DRM_DEVICES=/d' "$env_file"
+  sudo sed -i '/^AQ_DRM_DEVICES=/d' "$env_file"
+  sudo sed -i '/# GPU Passthrough Configuration/d' "$env_file"
+
+  msg_success "System env vars removed"
+  return 0
+}
+
+unconfigure_hyprland_igpu() {
+  local real_user="${SUDO_USER:-$USER}"
+  if ! id "$real_user" &>/dev/null; then
+    return 0
+  fi
+
+  local user_home=$(getent passwd "$real_user" | cut -d: -f6)
+  if [[ -z "$user_home" ]]; then
+    return 0
+  fi
+
+  # Clean Hyprland config
+  local hypr_conf="$user_home/.config/hypr/hyprland.conf"
+  if [[ -f "$hypr_conf" ]]; then
+    if grep -qE "^env = (WLR_DRM_DEVICES|AQ_DRM_DEVICES|DRI_PRIME|LIBVA_DRIVER_NAME|__GLX_VENDOR_LIBRARY_NAME)," "$hypr_conf" ||
+       grep -q "# GPU Passthrough Configuration" "$hypr_conf"; then
+      cp -a "$hypr_conf" "${hypr_conf}.backup.uninstall.$(date +%s)"
+      sed -i '/^env = WLR_DRM_DEVICES,/d' "$hypr_conf"
+      sed -i '/^env = AQ_DRM_DEVICES,/d' "$hypr_conf"
+      sed -i '/^env = DRI_PRIME,/d' "$hypr_conf"
+      sed -i '/^env = LIBVA_DRIVER_NAME,/d' "$hypr_conf"
+      sed -i '/^env = __GLX_VENDOR_LIBRARY_NAME,/d' "$hypr_conf"
+      sed -i '/# GPU Passthrough Configuration/d' "$hypr_conf"
+      [[ -n "${SUDO_USER:-}" ]] && chown "$SUDO_USER:$(id -gn "$SUDO_USER")" "$hypr_conf" 2>/dev/null
+    fi
+  fi
+
+  # Clean UWSM env (MUX-less configuration)
+  unconfigure_uwsm_env_muxless "$user_home"
+
+  msg_success "Hyprland config cleaned"
+  return 0
+}
+
+# Helper: Remove GPU Passthrough section from a single UWSM file
+_unconfigure_uwsm_file() {
+  local file_path="$1"
+  local use_sudo=""
+
+  [[ ! -f "$file_path" ]] && return 0
+
+  if ! grep -q "# BEGIN GPU Passthrough" "$file_path" 2>/dev/null; then
+    return 0
+  fi
+
+  # Determine if we need sudo
+  [[ ! -w "$file_path" ]] && use_sudo="sudo"
+
+  # Backup before modification
+  if ! $use_sudo cp -a "$file_path" "${file_path}.backup.uninstall.$(date +%s)" 2>/dev/null; then
+    log_warn "Could not backup UWSM file: $file_path"
+  fi
+
+  if ! $use_sudo sed -i '/# BEGIN GPU Passthrough/,/# END GPU Passthrough/d' "$file_path" 2>/dev/null; then
+    log_warn "Could not remove GPU Passthrough section from $file_path"
+    return 0
+  fi
+
+  [[ -n "${SUDO_USER:-}" ]] && $use_sudo chown "$SUDO_USER:$(id -gn "$SUDO_USER")" "$file_path" 2>/dev/null
+
+  log_info "Removed GPU Passthrough section from $(basename "$file_path")"
+  return 0
+}
+
+# Remove GPU Passthrough configuration from all UWSM env files
+unconfigure_uwsm_env_muxless() {
+  local user_home="$1"
+
+  # Clean both env and env-hyprland files
+  _unconfigure_uwsm_file "$user_home/.config/uwsm/env"
+  _unconfigure_uwsm_file "$user_home/.config/uwsm/env-hyprland"
+
+  return 0
+}
+
+unconfigure_vfio_modules_mkinitcpio() {
+  if [[ ! -f "$MKINITCPIO_CONF" ]]; then
+    return 0
+  fi
+
+  local current_modules
+  current_modules=$(grep "^MODULES=" "$MKINITCPIO_CONF" 2>/dev/null | head -1) || current_modules=""
+  if ! [[ "$current_modules" =~ vfio_pci|vfio-pci ]]; then
+    return 0
+  fi
+
+  sudo cp "$MKINITCPIO_CONF" "${MKINITCPIO_CONF}.backup.uninstall.$(date +%s)"
+  remove_vfio_from_mkinitcpio
+  cleanup_mkinitcpio_modules_whitespace
+
+  msg_success "VFIO modules removed from initramfs"
+  return 0
+}
+
+unconfigure_gpu_blacklist() {
+  if [[ ! -f "$BLACKLIST_CONF" ]]; then
+    return 0
+  fi
+
+  sudo rm -f "$BLACKLIST_CONF"
+  msg_success "Blacklist removed"
+  return 0
+}
+
+unconfigure_kvm_options() {
+  if [[ ! -f "$KVM_CONF" ]]; then
+    return 0
+  fi
+
+  sudo rm -f "$KVM_CONF"
+  msg_success "KVM options removed"
+  return 0
+}
+
+unconfigure_vfio_modules() {
+  if [[ -f "$VFIO_CONF" ]]; then
+    sudo rm -f "$VFIO_CONF"
+    msg_success "VFIO config removed"
+  fi
+
+  # Remove USB controller udev rule if it exists
+  local udev_usb_override="/etc/udev/rules.d/99-vfio-usb-override.rules"
+  if [[ -f "$udev_usb_override" ]]; then
+    sudo rm -f "$udev_usb_override"
+    sudo udevadm control --reload-rules
+    msg_success "USB controller udev rule removed"
+  fi
+
+  return 0
+}
+
+unconfigure_pci_binding_permissions() {
+  local udev_rules_file="/etc/udev/rules.d/90-vfio-pci-permissions.rules"
+
+  if [[ -f "$udev_rules_file" ]]; then
+    msg_info "Removing PCI binding permissions..."
+    sudo rm -f "$udev_rules_file"
+    sudo udevadm control --reload-rules 2>/dev/null || true
+    sudo udevadm trigger --subsystem-match=pci 2>/dev/null || true
+    msg_success "  PCI binding permissions removed"
+  fi
+
+  return 0
+}
+
+unconfigure_kernel_parameters() {
+  local bootloader=$(detect_bootloader)
+
+  case "$bootloader" in
+  limine)
+    if [[ ! -f "$LIMINE_DEFAULT" ]]; then
+      return 1
+    fi
+
+    local all_cmdlines
+    all_cmdlines=$(grep '^KERNEL_CMDLINE\[default\]' "$LIMINE_DEFAULT" 2>/dev/null) || all_cmdlines=""
+    if ! [[ "$all_cmdlines" =~ (amd_iommu|intel_iommu)=on|iommu=pt ]]; then
+      return 0
+    fi
+
+    sudo cp "$LIMINE_DEFAULT" "${LIMINE_DEFAULT}.backup.uninstall.$(date +%s)"
+    sudo sed -i -E 's/[[:space:]]*(amd_iommu=on|intel_iommu=on)//g' "$LIMINE_DEFAULT"
+    sudo sed -i -E 's/[[:space:]]*iommu=pt//g' "$LIMINE_DEFAULT"
+    sudo sed -i -E 's/[[:space:]]*vfio-pci\.ids=[0-9a-f:,]+//g' "$LIMINE_DEFAULT"
+    sudo sed -i -E 's/[[:space:]]*pci=realloc//g' "$LIMINE_DEFAULT"
+    sudo sed -i -E 's/[[:space:]]+/ /g' "$LIMINE_DEFAULT"
+    sudo sed -i -E 's/[[:space:]]+"$/"/' "$LIMINE_DEFAULT"
+    ;;
+  grub)
+    if [[ ! -f "$GRUB_DEFAULT" ]]; then
+      return 1
+    fi
+
+    local grub_line current_cmdline=""
+    grub_line=$(grep '^GRUB_CMDLINE_LINUX_DEFAULT=' "$GRUB_DEFAULT" 2>/dev/null) || grub_line=""
+    [[ "$grub_line" =~ ^GRUB_CMDLINE_LINUX_DEFAULT=\"([^\"]*)\" ]] && current_cmdline="${BASH_REMATCH[1]}"
+    if ! [[ "$current_cmdline" =~ (amd_iommu|intel_iommu)=on|iommu=pt ]]; then
+      return 0
+    fi
+
+    sudo cp "$GRUB_DEFAULT" "${GRUB_DEFAULT}.backup.uninstall.$(date +%s)"
+    local new_cmdline="$current_cmdline"
+    new_cmdline=$(sed -E 's/(^|[[:space:]])(amd_iommu|intel_iommu)=on([[:space:]]|$)/\3/g; s/(^|[[:space:]])iommu=pt([[:space:]]|$)/\2/g; s/(^|[[:space:]])pci=realloc([[:space:]]|$)/\2/g; s/[[:space:]]+/ /g; s/^ //; s/ $//' <<< "$new_cmdline")
+    # Escape sed special chars in replacement: & (backreference) and \ (escape)
+    local new_cmdline_escaped="${new_cmdline//\\/\\\\}"
+    new_cmdline_escaped="${new_cmdline_escaped//&/\\&}"
+    sudo sed -i "s|^GRUB_CMDLINE_LINUX_DEFAULT=.*|GRUB_CMDLINE_LINUX_DEFAULT=\"$new_cmdline_escaped\"|" "$GRUB_DEFAULT"
+
+    local regen_cmd=$(get_grub_regenerate_cmd)
+    if [[ -n "$regen_cmd" ]]; then
+      sudo $regen_cmd >/dev/null 2>&1 || true
+    fi
+    ;;
+  *)
+    return 1
+    ;;
+  esac
+
+  msg_success "Kernel parameters removed"
+  return 0
+}
+
+check_passthrough_feasibility() {
+  local errors=0
+  local vendor=$(get_cpu_vendor)
+
+  if detect_virtualization; then
+    :
+  else
+    msg_error "Running inside a virtual machine detected!"
+    echo "   Detected: $VIRTUALIZATION_TYPE"
+    msg_warning "GPU passthrough requires bare metal (physical hardware)"
+    echo "   This tool is for physical Omarchy installations"
+    echo "   To use GPU in a VM, configure passthrough on the HOST system"
+    log_error "Setup aborted: Running inside a virtual machine ($VIRTUALIZATION_TYPE)"
+    exit 1
+  fi
+
+  if [[ "$GPU_COUNT" -lt 2 ]]; then
+    msg_error "Only 1 GPU detected (need 2: VM + host)"
+    errors=$((errors + 1))
+  fi
+
+  if ! check_cpu_iommu_capability; then
+    msg_error "CPU virtualization not detected"
+    case "$vendor" in
+    amd) msg_info "  Enable SVM/AMD-V in BIOS" ;;
+    intel) msg_info "  Enable VT-x in BIOS" ;;
+    *) msg_info "  Enable virtualization in BIOS" ;;
+    esac
+    errors=$((errors + 1))
+  fi
+
+  if ! check_iommu_support; then
+    msg_error "IOMMU not enabled"
+    case "$vendor" in
+    amd) msg_info "  Enable AMD-Vi in BIOS + add amd_iommu=on to kernel" ;;
+    intel) msg_info "  Enable VT-d in BIOS + add intel_iommu=on to kernel" ;;
+    *) msg_info "  Enable IOMMU in BIOS and kernel" ;;
+    esac
+    errors=$((errors + 1))
+  fi
+
+  return $errors
+}
+
+# GPU Selection
+
+select_gpu_for_passthrough() {
+  msg_section "GPU Selection"
+  echo "Available GPUs:"
+
+  local recommended_idx=-1
+  for i in "${!GPU_PCI_ADDR[@]}"; do
+    if [[ "${GPU_TYPE[$i]}" == "dedicated" ]]; then
+      recommended_idx=$i
+      break
+    fi
+  done
+
+  local configured_pci=""
+  if [[ -f "$GPU_PASSTHROUGH_CONF" ]]; then
+    configured_pci=$(grep -oPm1 '^GPU_PCI_ADDR="\K[^"]+' "$GPU_PASSTHROUGH_CONF" 2>/dev/null || true)
+  fi
+
+  for i in "${!GPU_PCI_ADDR[@]}"; do
+    local pci="${GPU_PCI_ADDR[$i]}"
+    local name="${GPU_NAME[$i]}"
+    local driver="${GPU_DRIVER[$i]}"
+    local type="${GPU_TYPE[$i]}"
+    local vendor_id="${GPU_VENDOR_ID[$i]}"
+    local device_id="${GPU_DEVICE_ID[$i]}"
+    local vram=$(get_gpu_memory "$pci" "$vendor_id")
+
+    local star=""
+    if [[ "$pci" == "$configured_pci" ]]; then
+      star=" [CURRENTLY CONFIGURED]"
+    elif [[ "$i" -eq "$recommended_idx" ]]; then
+      star=" ★ RECOMMENDED"
+    fi
+
+    echo "  $((i + 1)). ${name}${star}"
+    echo "     Memory: ${vram}"
+    echo "     PCI: $pci | IDs: ${vendor_id}:${device_id}"
+    echo "     Type: $type | Driver: $driver"
+
+    if [[ "$type" == "dedicated" ]]; then
+      echo "     💡 Best for VM passthrough"
+    else
+      echo "     Keep for Linux display"
+    fi
+    echo ""
+  done
+
+  local choices=()
+  for i in "${!GPU_PCI_ADDR[@]}"; do
+    local pci="${GPU_PCI_ADDR[$i]}"
+    local vram=$(get_gpu_memory "$pci" "${GPU_VENDOR_ID[$i]}")
+    local prefix=""
+    if [[ "$pci" == "$configured_pci" ]]; then
+      prefix="[CONFIGURED] "
+    elif [[ "$i" -eq "$recommended_idx" ]]; then
+      prefix="★ "
+    fi
+    choices+=("${prefix}${GPU_NAME[$i]} - ${vram} ($pci)")
+  done
+
+  echo "Select GPU to pass through to VM:"
+  local selection
+  selection=$(gum choose "${choices[@]}") || {
+    msg_warning "GPU selection cancelled"
+    return 1
+  }
+
+  if [[ -z "$selection" ]]; then
+    msg_warning "No GPU selected"
+    return 1
+  fi
+
+  for i in "${!GPU_PCI_ADDR[@]}"; do
+    local pci="${GPU_PCI_ADDR[$i]}"
+    local vram=$(get_gpu_memory "$pci" "${GPU_VENDOR_ID[$i]}")
+    if [[ "$selection" == "${GPU_NAME[$i]} - ${vram} ($pci)" ]] ||
+      [[ "$selection" == "★ ${GPU_NAME[$i]} - ${vram} ($pci)" ]] ||
+      [[ "$selection" == "[CONFIGURED] ${GPU_NAME[$i]} - ${vram} ($pci)" ]]; then
+      SELECTED_GPU_INDEX=$i
+      return 0
+    fi
+  done
+
+  msg_error "Failed to match GPU selection"
+  return 1
+}
+
+validate_gpu_selection() {
+  local idx="$SELECTED_GPU_INDEX"
+  local type="${GPU_TYPE[$idx]}"
+  local name="${GPU_NAME[$idx]}"
+  local pci="${GPU_PCI_ADDR[$idx]}"
+  local vram=$(get_gpu_memory "$pci" "${GPU_VENDOR_ID[$idx]}")
+
+  # MUX-less: Skip validation - already confirmed in MUX-less dialog, eDP always works
+  if [[ "$IS_MUXLESS_LAPTOP" == "true" ]]; then
+    log_info "MUX-less laptop: skipping standard validation (eDP always active)"
+    return 0
+  fi
+
+  msg_success "Selected for passthrough: ${name}"
+  echo "  PCI: $pci | Memory: $vram"
+
+  if [[ "$type" == "integrated" ]]; then
+    msg_warning "iGPU selected - NOT recommended!"
+    msg_warning "Linux will have no display after passthrough"
+    gum confirm "Continue anyway?" || return 1
+  fi
+
+  if [[ "$GPU_COUNT" -eq 1 ]]; then
+    msg_error "Only 1 GPU detected - passthrough requires 2"
+    return 1
+  fi
+
+  if [[ "$type" == "dedicated" ]]; then
+    gum confirm "Proceed?" || return 1
+  fi
+
+  msg_section "Monitor Setup"
+
+  local selected_gpu_pci="${GPU_PCI_ADDR[$idx]}"
+  local igpu_pci=""
+
+  for i in "${!GPU_PCI_ADDR[@]}"; do
+    if [[ "${GPU_TYPE[$i]}" == "integrated" ]]; then
+      igpu_pci="${GPU_PCI_ADDR[$i]}"
+      break
+    fi
+  done
+
+  local dgpu_monitor_count=$(count_connected_monitors_for_pci "$selected_gpu_pci")
+  local igpu_monitor_count=0
+  [[ -n "$igpu_pci" ]] && igpu_monitor_count=$(count_connected_monitors_for_pci "$igpu_pci")
+
+  if [[ "$igpu_monitor_count" -gt 0 ]]; then
+    msg_success "iGPU: $igpu_monitor_count monitor(s)"
+  else
+    msg_warning "iGPU: 0 monitors"
+  fi
+
+  if [[ "$dgpu_monitor_count" -gt 0 ]]; then
+    if [[ "$igpu_monitor_count" -gt 0 ]]; then
+      msg_info "Dedicated GPU: $dgpu_monitor_count monitor(s) (reserved for VM)"
+    else
+      msg_warning "Dedicated GPU: $dgpu_monitor_count monitor(s) (will go blank after reboot)"
+    fi
+  fi
+
+  if [[ "$igpu_monitor_count" -eq 0 ]] && [[ "$dgpu_monitor_count" -gt 0 ]]; then
+    msg_error "No monitors on iGPU - ALL monitors will go BLANK after reboot!"
+    msg_info "Connect at least one monitor to motherboard ports before rebooting"
+    log_warn "Critical: No iGPU monitors, $dgpu_monitor_count on dGPU"
+    gum confirm "I will connect monitor to motherboard BEFORE reboot" || {
+      msg_error "Setup aborted"
+      return 1
+    }
+  elif [[ "$igpu_monitor_count" -gt 0 ]]; then
+    msg_info "After reboot, use monitors connected to motherboard (iGPU)"
+    log_info "Monitor setup: $igpu_monitor_count iGPU, $dgpu_monitor_count dGPU"
+
+    gum confirm "Continue?" || {
+      msg_error "Setup aborted"
+      return 1
+    }
+  else
+    msg_warning "Cannot detect monitors - ensure at least one on motherboard ports"
+    log_warn "Cannot detect monitor connections"
+
+    gum confirm "Monitor connected to motherboard?" || {
+      msg_error "Setup aborted"
+      return 1
+    }
+  fi
+
+  log_info "User confirmed monitor setup"
+
+  return 0
+}
+
+# Banner & Intro Functions
+
+show_intro_banner() {
+  local cpu_vendor=$(get_cpu_vendor)
+  local bootloader=$(detect_bootloader)
+  local bootloader_path=$(get_bootloader_config_path "$bootloader")
+  local bootloader_safety
+
+  if is_bootloader_supported "$bootloader"; then
+    if [[ "$bootloader" == "limine" ]]; then
+      bootloader_safety="Limine snapshots available in boot menu (rollback option)"
+    else
+      bootloader_safety="$(get_bootloader_display_name "$bootloader") config backed up before changes"
+    fi
+  else
+    bootloader_safety="Manual configuration required (instructions provided)"
+  fi
+
+  msg_section "GPU Passthrough Setup Wizard"
+  msg_warning "Experimental - use with caution"
+  echo "WHAT WILL BE CHANGED:"
+  cat <<EOF
+  • Kernel boot parameters ($bootloader_path)
+  • GPU driver configuration (dedicated GPU reserved for VM)
+  • Initramfs modules + rebuild (/etc/mkinitcpio.conf)
+  • Hyprland configuration (~/.config/hypr/hyprland.conf)
+  • System REBOOT required
+EOF
+
+  echo ""
+  echo "AFTER REBOOT:"
+  cat <<EOF
+  • Dedicated GPU will be INACTIVE (reserved for VM, no native driver)
+  • Connect ALL monitors to MOTHERBOARD ports (iGPU only)
+  • Host display uses iGPU, dedicated GPU ready for VM
+  • VMs (omarchy-windows-vm) handle GPU automatically
+  • For host use (CUDA/gaming): omarchy-gpu-passthrough mode host
+EOF
+
+  echo ""
+  echo "SAFETY MEASURES:"
+  echo "  ✓  Automatic backups created before changes"
+  echo "  ✓  $bootloader_safety"
+  echo "  ✓  Undo anytime with: omarchy-gpu-passthrough setup --uninstall"
+
+  echo ""
+  echo "REQUIREMENTS:"
+  cat <<EOF
+  • 2+ GPUs (1 for VM passthrough, 1 for host display)
+  • BIOS: Primary Display = IGD or Auto (recommended)
+EOF
+
+  case "$cpu_vendor" in
+  amd)
+    cat <<EOF
+  • BIOS: SVM Mode = Enabled
+  • BIOS: IOMMU = Enabled (or AMD-Vi)
+EOF
+    ;;
+  intel)
+    cat <<EOF
+  • BIOS: Intel VT-x = Enabled
+  • BIOS: Intel VT-d = Enabled
+EOF
+    ;;
+  *)
+    cat <<EOF
+  • BIOS: Virtualization = Enabled
+  • BIOS: IOMMU = Enabled
+EOF
+    ;;
+  esac
+
+  echo ""
+  msg_info "Recommended: Create full system backup before proceeding (optional)"
+}
+
+# Main Commands
+
+cmd_setup() {
+  log_init
+  log_info "=== SETUP WIZARD START ==="
+  log_info "User: $USER"
+  log_info "System: $(uname -r)"
+
+  show_intro_banner
+
+  # Single confirmation - get user consent BEFORE any system changes
+  if ! gum confirm "I understand the risks and have checked BIOS settings. Continue?"; then
+    msg_warning "Setup cancelled. Run again when ready."
+    exit 0
+  fi
+
+  # Add to kvm group if needed (will be active after reboot)
+  if ! groups "$USER" | grep -q '\bkvm\b'; then
+    msg_info "Adding user to kvm group..."
+    if ! sudo usermod -aG kvm "$USER"; then
+      msg_error "Failed to add user to kvm group"
+      msg_info "  Run manually: sudo usermod -aG kvm \$USER"
+      exit 1
+    fi
+    msg_success "User added to kvm group (active after reboot)"
+    log_info "User $USER added to kvm group"
+  fi
+
+  # Add to video group if needed (required for DRI access)
+  if ! groups "$USER" | grep -q '\bvideo\b'; then
+    msg_info "Adding user to video group..."
+    if ! sudo usermod -aG video "$USER"; then
+      msg_error "Failed to add user to video group"
+      msg_info "  Run manually: sudo usermod -aG video \$USER"
+      exit 1
+    fi
+    msg_success "User added to video group (active after reboot)"
+    log_info "User $USER added to video group"
+  fi
+
+  # Ensure sudo access early (refresh timestamp to avoid multiple prompts)
+  if ! sudo -v; then
+    msg_error "sudo access required for setup"
+    exit 1
+  fi
+
+  # Check and install dependencies
+  check_dependencies
+
+  # Check if already configured
+  if [[ -f "$GPU_PASSTHROUGH_CONF" ]]; then
+    msg_info "GPU passthrough is already configured"
+    # Load and show current config
+    if load_gpu_config; then
+      local current_mode="unknown"
+      if [[ -r "$STATE_MARKER_FILE" ]]; then
+        current_mode=$(<"$STATE_MARKER_FILE") 2>/dev/null || current_mode="unknown"
+      fi
+      msg_info "  GPU: $GPU_NAME ($GPU_PCI_ADDR)"
+      msg_info "  Mode: $current_mode"
+    fi
+    msg_info "This wizard will re-apply/update the configuration"
+  fi
+
+  detect_gpus
+
+  if [[ "$GPU_COUNT" -eq 0 ]]; then
+    msg_error "No GPUs detected!"
+    exit 1
+  fi
+
+  msg_success "Found $GPU_COUNT GPU(s)"
+
+  detect_hybrid_graphics_laptop
+
+  local driver_warnings=0
+  for i in "${!GPU_PCI_ADDR[@]}"; do
+    local vendor_id="${GPU_VENDOR_ID[$i]}"
+    local name="${GPU_NAME[$i]}"
+    local driver="${GPU_DRIVER[$i]}"
+
+    case "$vendor_id" in
+    10de)
+      if ! command -v nvidia-smi &>/dev/null; then
+        msg_warning "  NVIDIA GPU detected but nvidia-smi not found"
+        msg_info "    GPU: $name"
+        msg_info "    This is OK if you haven't installed NVIDIA drivers yet"
+        driver_warnings=$((driver_warnings + 1))
+      else
+        msg_success "  NVIDIA drivers detected (nvidia-smi available)"
+      fi
+      ;;
+    1002)
+      if [[ "$driver" == "amdgpu" ]]; then
+        msg_success "  AMD GPU using amdgpu driver"
+      elif [[ "$driver" == "none" ]]; then
+        msg_warning "  AMD GPU detected but no driver loaded"
+        msg_info "    GPU: $name"
+        msg_info "    This is OK if you haven't installed AMD drivers yet"
+        driver_warnings=$((driver_warnings + 1))
+      fi
+      ;;
+    esac
+  done
+
+  if [[ "$driver_warnings" -gt 0 ]]; then
+    msg_info "Note: GPU passthrough works even without drivers (will be blacklisted)"
+  fi
+
+  local feasibility_errors=0
+  check_passthrough_feasibility || feasibility_errors=$?
+
+  if [[ "$GPU_COUNT" -lt 2 ]]; then
+    msg_error "GPU passthrough requires at least 2 GPUs"
+    exit 1
+  fi
+
+  if [[ "$feasibility_errors" -gt 0 ]]; then
+    msg_warning "IOMMU not currently detected - you will need to:"
+    msg_info "  1. Complete this setup to configure kernel parameters"
+    msg_info "  2. Enable IOMMU in BIOS (AMD-Vi or Intel VT-d)"
+    msg_info "  3. Reboot"
+    msg_info "  4. Run 'omarchy-gpu-passthrough info verify' to confirm"
+    gum confirm "Continue with setup anyway?" || exit 0
+  else
+    msg_success "System is capable of GPU passthrough"
+  fi
+
+  # MUX-less laptop: auto-select dGPU, show info and confirm BEFORE regular GPU selection
+  if [[ "$IS_MUXLESS_LAPTOP" == "true" ]]; then
+    # Get GPU names and find dGPU index for auto-selection
+    local igpu_name="" dgpu_name="" dgpu_idx=-1
+    for i in "${!GPU_PCI_ADDR[@]}"; do
+      if [[ "${GPU_PCI_ADDR[$i]}" == "$IGPU_PCI" ]]; then
+        igpu_name="${GPU_NAME[$i]}"
+      fi
+      if [[ "${GPU_PCI_ADDR[$i]}" == "$DGPU_PCI" ]]; then
+        dgpu_name="${GPU_NAME[$i]}"
+        dgpu_idx=$i
+      fi
+    done
+
+    msg_section "Hybrid Graphics Laptop (MUX-less)"
+    echo "Detected configuration:"
+    echo "  iGPU: $igpu_name → Linux display"
+    echo "  dGPU: $dgpu_name → VM passthrough"
+
+    if [[ "$BIOS_DISPLAY_CONTROL_MISSING" == "true" ]]; then
+      HYBRID_MUXLESS_MODE=true
+      log_info "MUX-less laptop: no BIOS display control detected"
+      log_info "Mode: Hybrid (automatic)"
+      echo ""
+      echo "Mode: Hybrid (GPU bound to VM only when needed)"
+    else
+      HYBRID_MUXLESS_MODE=false
+      log_info "MUX-less laptop: BIOS display control available"
+      log_info "Mode: Standard (automatic) - GPU bound to vfio-pci at boot"
+      echo ""
+      echo "Mode: Standard (GPU reserved for VM at boot)"
+    fi
+
+    # Auto-select dGPU (no need to ask user - only valid option for MUX-less)
+    SELECTED_GPU_INDEX=$dgpu_idx
+    msg_success "Auto-selected: $dgpu_name"
+  else
+    # Standard passthrough: user selects GPU
+    if ! select_gpu_for_passthrough; then
+      msg_error "GPU selection failed"
+      exit 1
+    fi
+  fi
+
+  # Validate selection
+  if ! validate_gpu_selection; then
+    msg_error "Invalid GPU selection"
+    exit 1
+  fi
+
+  local idx=$SELECTED_GPU_INDEX
+  local name="${GPU_NAME[$idx]}"
+  local pci="${GPU_PCI_ADDR[$idx]}"
+  local vendor_id="${GPU_VENDOR_ID[$idx]}"
+  local device_id="${GPU_DEVICE_ID[$idx]}"
+  local audio_id="${GPU_AUDIO_ID[$idx]}"
+
+  log_info "User selected GPU for passthrough: $name ($pci)"
+  log_info "GPU for passthrough: $name ($pci) - ${vendor_id}:${device_id}"
+
+  log_info "GPU detection results ($GPU_COUNT GPUs):"
+  for i in "${!GPU_PCI_ADDR[@]}"; do
+    log_info "  [$i] ${GPU_NAME[$i]} (${GPU_PCI_ADDR[$i]}) vendor=${GPU_VENDOR_ID[$i]} type=${GPU_TYPE[$i]}"
+  done
+
+  for i in "${!GPU_PCI_ADDR[@]}"; do
+    if [[ "${GPU_TYPE[$i]}" == "integrated" ]]; then
+      log_info "Host GPU (iGPU): ${GPU_NAME[$i]} (${GPU_PCI_ADDR[$i]})"
+      break
+    fi
+  done
+
+  msg_section "Configuring GPU Passthrough"
+
+  local snapshot_desc="GPU Passthrough: $name"
+  omarchy-snapshot create "$snapshot_desc" >/dev/null 2>&1
+  local snapshot_exit_code=$?
+
+  if [[ "$snapshot_exit_code" -eq 0 ]]; then
+    msg_success "System snapshot created"
+    log_info "Snapshot: $snapshot_desc"
+  elif [[ "$snapshot_exit_code" -eq 127 ]]; then
+    log_info "Snapper not available - skipping system snapshot"
+  else
+    msg_warning "Snapshot failed (continuing)"
+    log_warn "omarchy-snapshot failed with exit code $snapshot_exit_code"
+  fi
+
+  msg_info "Configuring sudoers rules..."
+  configure_sudoers_gpu_passthrough
+
+  if ! create_backup_snapshot; then
+    msg_error "Failed to create backup - setup aborted"
+    exit 1
+  fi
+
+  if ! save_gpu_config "$idx"; then
+    msg_error "Failed to save GPU configuration"
+    msg_info "Check if sudo is working: sudo -v"
+    exit 1
+  fi
+
+  configure_kernel_parameters
+  if ! configure_vfio_modules "$pci" "$vendor_id" "$device_id"; then
+    log_error "configure_vfio_modules failed"
+    msg_error "Failed to configure VFIO"
+    exit 1
+  fi
+  configure_kvm_options
+  configure_pci_binding_permissions
+  configure_gpu_state_tmpfiles
+
+  # For traditional passthrough: blacklist the GPU driver
+  # For MUX-less (Reverse Optimus): skip blacklist, let vfio-pci.ids claim GPU at boot
+  if [[ "$IS_MUXLESS_LAPTOP" != "true" ]]; then
+    if ! configure_gpu_blacklist "$vendor_id"; then
+      log_error "configure_gpu_blacklist failed for $vendor_id"
+      msg_error "Failed to blacklist GPU driver"
+      exit 1
+    fi
+  else
+    if [[ "${HYBRID_MUXLESS_MODE:-false}" == "true" ]]; then
+      log_info "Hybrid Mode: GPU driver stays active"
+      msg_info "GPU driver: active (Hybrid Mode)"
+    else
+      log_info "Standard Mode: GPU bound to vfio-pci at boot"
+      msg_info "GPU binding: vfio-pci.ids (Standard Mode)"
+    fi
+  fi
+
+  configure_vfio_modules_mkinitcpio
+
+  # Configure iGPU for host display
+  # IGPU_PCI is set by detect_hybrid_graphics_laptop() via eDP detection
+  # For desktops without eDP, scan GPU_TYPE array
+  local igpu_pci="${IGPU_PCI:-}"
+
+  if [[ -z "$igpu_pci" ]]; then
+    # Desktop fallback: find GPU marked as integrated
+    for i in "${!GPU_PCI_ADDR[@]}"; do
+      if [[ "${GPU_TYPE[$i]}" == "integrated" ]]; then
+        igpu_pci="${GPU_PCI_ADDR[$i]}"
+        break
+      fi
+    done
+  fi
+
+  if [[ -n "$igpu_pci" ]]; then
+    configure_system_environment "$igpu_pci" || {
+      msg_error "Failed to configure system environment"
+      exit 1
+    }
+    configure_hyprland_igpu "$igpu_pci" || {
+      msg_error "Failed to configure Hyprland"
+      exit 1
+    }
+  else
+    msg_warning "No iGPU detected, skipping environment configuration"
+  fi
+
+  local bootloader=$(detect_bootloader)
+  msg_info "Rebuilding initramfs..."
+  log_info "Rebuilding initramfs via $bootloader"
+  if [[ "$bootloader" == "limine" ]]; then
+    if ! sudo limine-mkinitcpio; then
+      log_error "limine-mkinitcpio failed"
+      msg_error "Failed to rebuild initramfs"
+      exit 1
+    fi
+    log_info "limine-mkinitcpio completed successfully"
+  else
+    if ! sudo mkinitcpio -P; then
+      log_error "mkinitcpio -P failed"
+      msg_error "Failed to rebuild initramfs"
+      exit 1
+    fi
+    log_info "mkinitcpio -P completed successfully"
+  fi
+  msg_success "Initramfs rebuilt"
+
+  if [[ "$IS_MUXLESS_LAPTOP" == "true" ]]; then
+    log_info "MUX-less laptop detected (hybrid graphics)"
+    if [[ "$DGPU_HAS_EXTERNAL_MONITOR" == "true" ]]; then
+      log_warn "External monitor on dGPU - will go blank after reboot"
+    fi
+  fi
+
+  msg_section "Setup Complete!"
+
+  log_info "=== SETUP WIZARD COMPLETED SUCCESSFULLY ==="
+  log_info "GPU configured: $name ($pci) - ${vendor_id}:${device_id}"
+
+  msg_success "GPU: $name ($pci)"
+
+  if [[ "$IS_MUXLESS_LAPTOP" == "true" ]]; then
+    if [[ "${HYBRID_MUXLESS_MODE:-false}" == "true" ]]; then
+      echo "Mode: Hybrid (both GPUs active)"
+    else
+      echo "Mode: Standard (GPU configured at boot)"
+      if [[ "$DGPU_HAS_EXTERNAL_MONITOR" == "true" ]]; then
+        msg_warning "External monitor on GPU may go blank"
+      fi
+    fi
+  else
+    if [[ -f "$VFIO_CONF" ]] && grep -q "^options vfio-pci ids=" "$VFIO_CONF" 2>/dev/null; then
+      echo "Mode: Standard passthrough (dGPU bound to vfio-pci at boot)"
+    else
+      echo "Mode: Standard passthrough (dGPU blacklisted at boot)"
+    fi
+    msg_info "Tip: Set BIOS Primary Display = IGD"
+  fi
+
+  # Final verification - ensure config is valid before declaring success
+  msg_section "Final Verification"
+  if ! load_gpu_config; then
+    msg_error "Configuration verification FAILED"
+    msg_info "The config file may be corrupted or have wrong permissions"
+    msg_info "Debug: sudo cat $GPU_PASSTHROUGH_CONF"
+    msg_info "Debug: ls -la $GPU_PASSTHROUGH_CONF"
+    exit 1
+  fi
+  msg_success "Configuration verified successfully"
+
+  echo ""
+  echo "Next steps:"
+  echo "   1. Reboot system"
+  echo "   2. Verify: omarchy-gpu-passthrough info verify"
+  echo "   3. Install Windows VM: omarchy-windows-vm install"
+  echo ""
+  msg_info "BIOS tip: Set \"Primary Display = IGD\" to avoid black screen"
+  msg_warning "Reboot required to apply kernel parameters"
+  echo ""
+  echo "Recovery: Ctrl+Alt+F2 → omarchy-gpu-passthrough setup --uninstall → reboot"
+  echo ""
+
+  if gum confirm "Reboot now?"; then
+    sudo reboot
+  fi
+}
+
+cmd_uninstall() {
+  msg_section "GPU Passthrough Uninstall"
+
+  if ! sudo -v; then
+    msg_error "sudo access required for uninstall"
+    exit 1
+  fi
+
+  msg_warning "This will remove ALL GPU passthrough configuration!"
+  echo "What will be removed:"
+  echo "  • Kernel parameters (amd_iommu, iommu=pt)"
+  echo "  • VFIO modprobe configuration"
+  echo "  • GPU driver blacklist"
+  echo "  • PCI binding permissions (udev rules)"
+  echo "  • VFIO modules from initramfs"
+  echo "  • Hyprland iGPU configuration"
+  echo "  • KVM options (ignore_msrs, nested)"
+  echo "  • GPU passthrough config file"
+  msg_info "Your system will return to normal GPU configuration after reboot"
+
+  gum confirm "Continue with uninstall?" || exit 0
+
+  msg_section "Removing GPU Passthrough Configuration"
+
+  unconfigure_system_environment
+  unconfigure_hyprland_igpu
+  unconfigure_vfio_modules_mkinitcpio
+  unconfigure_gpu_blacklist
+  unconfigure_pci_binding_permissions
+  unconfigure_gpu_state_tmpfiles
+  unconfigure_vfio_modules
+
+  local bootloader=$(detect_bootloader)
+  if ! unconfigure_kernel_parameters; then
+    if ! is_bootloader_supported "$bootloader"; then
+      msg_warning "Kernel parameters NOT automatically removed"
+      echo "  Your bootloader ($(get_bootloader_display_name "$bootloader")) requires manual configuration."
+      echo "  Remove these parameters from $(get_bootloader_config_path "$bootloader"):"
+      echo "    • amd_iommu=on or intel_iommu=on"
+      echo "    • iommu=pt"
+      echo "    • pci=realloc (if present)"
+    fi
+  fi
+
+  unconfigure_kvm_options
+  unconfigure_sudoers_gpu_passthrough
+
+  if [[ -f "$GPU_PASSTHROUGH_CONF" ]]; then
+    sudo rm -f "$GPU_PASSTHROUGH_CONF"
+    msg_success "GPU configuration removed"
+  fi
+  msg_info "Rebuilding initramfs..."
+  log_info "Rebuilding initramfs via $bootloader"
+  if [[ "$bootloader" == "limine" ]]; then
+    if ! sudo limine-mkinitcpio; then
+      log_error "limine-mkinitcpio failed during uninstall"
+      msg_warning "Initramfs rebuild failed - run manually: sudo limine-mkinitcpio"
+    else
+      msg_success "Initramfs rebuilt"
+    fi
+  else
+    if ! sudo mkinitcpio -P; then
+      log_error "mkinitcpio -P failed during uninstall"
+      msg_warning "Initramfs rebuild failed - run manually: sudo mkinitcpio -P"
+    else
+      msg_success "Initramfs rebuilt"
+    fi
+  fi
+
+  msg_section "Uninstall Complete!"
+
+  msg_success "GPU passthrough configuration has been removed"
+  echo "Backups created (can be deleted manually if not needed):"
+  if [[ "$bootloader" == "limine" ]]; then
+    echo "  • /etc/default/limine.backup.uninstall.*"
+  elif [[ "$bootloader" == "grub" ]]; then
+    echo "  • /etc/default/grub.backup.uninstall.*"
+  fi
+  echo "  • /etc/mkinitcpio.conf.backup.uninstall.*"
+  echo "  • ~/.config/hypr/hyprland.conf.backup.uninstall.*"
+  echo ""
+  msg_warning "REBOOT REQUIRED"
+  echo "After reboot:"
+  echo "  • GPU available to Linux"
+  echo "  • GPU drivers (nvidia/amdgpu) load normally"
+  echo "  • GPU usable for gaming, rendering, etc."
+  echo ""
+  msg_info "To reboot now: sudo reboot"
+}
+
+# Help
+
+show_setup_help() {
+  cat <<EOF
+GPU Passthrough Setup Wizard
+
+Usage: omarchy-gpu-passthrough setup [OPTIONS]
+
+Options:
+  (default)     Run interactive setup wizard
+  --uninstall   Remove GPU passthrough configuration
+  -h, --help    Show this help
+
+Description:
+  Interactive wizard to configure GPU passthrough for virtual machines.
+  Configures VFIO, kernel parameters, bootloader, and system environment.
+
+Requirements:
+  • 2+ GPUs (1 for VM, 1 for host)
+  • CPU with IOMMU support (AMD-Vi or Intel VT-d)
+  • IOMMU enabled in BIOS
+
+Examples:
+  omarchy-gpu-passthrough setup              # Run setup wizard
+  omarchy-gpu-passthrough setup --uninstall  # Remove configuration
+
+Logs: $LOG_FILE
+EOF
+}
+
+case "${1:-}" in
+--uninstall)
+  shift
+  cmd_uninstall "$@"
+  ;;
+-h | --help | help)
+  show_setup_help
+  ;;
+"")
+  cmd_setup
+  ;;
+*)
+  echo "Unknown option: $1"
+  show_setup_help
+  exit 1
+  ;;
+esac
diff --git a/bin/omarchy-gpu-passthrough-utils b/bin/omarchy-gpu-passthrough-utils
new file mode 100755
index 0000000000..e76c0e7588
--- /dev/null
+++ b/bin/omarchy-gpu-passthrough-utils
@@ -0,0 +1,1799 @@
+#!/bin/bash
+#
+# omarchy-gpu-passthrough-utils - Shared utilities
+# This file is sourced by omarchy-gpu-passthrough-* binaries
+#
+
+# Prevent direct execution
+if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
+  echo "ERROR: This file should be sourced, not executed directly" >&2
+  echo "Usage: source omarchy-gpu-passthrough-utils" >&2
+  exit 1
+fi
+
+# Configuration paths
+LIMINE_DEFAULT="/etc/default/limine"
+GRUB_DEFAULT="/etc/default/grub"
+VFIO_CONF="/etc/modprobe.d/vfio.conf"
+BLACKLIST_CONF="/etc/modprobe.d/blacklist-gpu-passthrough.conf"
+KVM_CONF="/etc/modprobe.d/kvm.conf"
+MKINITCPIO_CONF="/etc/mkinitcpio.conf"
+GPU_PASSTHROUGH_CONF="/etc/omarchy-gpu-passthrough.conf"
+
+# Runtime state paths
+STATE_MARKER_FILE="/var/run/omarchy-vm-gpu-mode"
+
+# Late binding systemd service (for AMD reset bug GPUs)
+# This service runs AFTER amdgpu does POST, then rebinds to vfio-pci
+VFIO_SERVICE="/etc/systemd/system/omarchy-gpu-passthrough.service"
+
+# Logging configuration
+LOG_DIR="/var/log/omarchy-gpu-passthrough"
+LOG_FILE="$LOG_DIR/gpu-passthrough.log"
+LOG_MAX_SIZE=$((10 * 1024 * 1024)) # 10 MB
+
+# Colors for output
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+BLUE='\033[0;34m'
+NC='\033[0m' # No Color
+
+# Global arrays for GPU detection (populated by detect_gpus)
+declare -a GPU_PCI_ADDR
+declare -a GPU_VENDOR_ID
+declare -a GPU_DEVICE_ID
+declare -a GPU_NAME
+declare -a GPU_DRIVER
+declare -a GPU_TYPE
+declare -a GPU_AUDIO_ID
+declare -i GPU_COUNT=0
+
+# Intel iGPU: Legacy (UHD, HD Graphics, Iris) + Modern codenames
+INTEL_IGPU_REGEX='uhd|hd graphics|iris|intel.*graphics|meteor|lunar|arrow|panther'
+
+# AMD APU: Desktop + Mobile + Legacy codenames
+AMD_APU_REGEX='radeon [0-9]+m|vega.*igpu|phoenix|rembrandt|cezanne|renoir|lucienne|barcelo|strix|raphael|hawk|mendocino|krackan'
+
+# AMD GPU device IDs with "reset bug" - require full power cycle after vfio-pci use
+# These GPUs cannot rebind to native driver (amdgpu) without reboot after VM use.
+# Source: https://github.com/lowell80/vendor-reset (device-db.h)
+#
+# Breakdown (by GPU family):
+#   Polaris 10 (RX 470/480/570/580/590): 67c0-67cf, 67d0, 67df, 6fdf
+#   Polaris 11 (RX 460/560): 67e0-67ef, 67ff
+#   Polaris 12 (RX 540/550): 6980-699f
+#   Vega 10 (Vega 56/64/FE): 6860-686f, 687f
+#   Vega 20 (Radeon VII, MI50/60): 66a0-66af, 164c
+#   Navi 10 (RX 5600/5700): 7310-731f
+#   Navi 10 APU (Renoir/Cezanne/Barcelo): 15bf, 15e7, 1636, 1638
+#   Navi 12 (Pro 5600M): 7360, 7362
+#   Navi 14 (RX 5300/5500): 7340-734f
+#   Navi 23 (RX 6600/6600XT): 73ff
+#   Arcturus (MI100): 738c
+#   Fiji (Fury/Fury X/Nano): 7300, 7301
+#   Hawaii (R9 290/390): 67b0, 67b1
+#   Tonga (R9 380/285): 6920-6929
+AMD_RESET_BUG_DEVICE_IDS='67c0|67c1|67c2|67c4|67c7|67c8|67c9|67ca|67cc|67cf|67d0|67df|6fdf|67e0|67e1|67e3|67e7|67e8|67e9|67eb|67ef|67ff|6980|6981|6985|6986|6987|6995|6997|699f|6860|6861|6862|6863|6864|6867|6868|6869|686a|686b|686c|686d|686e|686f|687f|66a0|66a1|66a2|66a3|66a4|66a7|66af|164c|7310|7312|7318|7319|731a|731b|731e|731f|15bf|15e7|1636|1638|7360|7362|7340|7341|7347|734f|73ff|738c|7300|7301|67b0|67b1|6920|6921|6928|6929'
+
+normalize_pci_addr() {
+  local pci_addr="$1"
+  [[ -z "$pci_addr" ]] && return 1
+  [[ ! "$pci_addr" =~ ^[0-9a-fA-F]{4}: ]] && pci_addr="0000:${pci_addr}"
+  if [[ ! "$pci_addr" =~ ^[0-9a-fA-F]{4}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}\.[0-7]$ ]]; then
+    return 1
+  fi
+
+  echo "$pci_addr"
+}
+
+msg_error() {
+  echo "❌  Error: $*" >&2
+}
+
+msg_success() {
+  echo "✓  $*"
+}
+
+msg_info() {
+  echo "ℹ️  $*"
+}
+
+msg_warning() {
+  echo "⚠️  Warning: $*" >&2
+}
+
+msg_section() {
+  echo ""
+  echo "$*"
+  echo ""
+}
+
+show_warning_box() {
+  local message="$1"
+  local box_width=65
+  local content_width=$((box_width - 2))
+
+  [[ -z "$message" ]] && message="(No message provided)"
+
+  local border_line=""
+  for ((i = 0; i < box_width; i++)); do border_line+="-"; done
+
+  echo ""
+  echo -e "${RED}+${border_line}+${NC}"
+  echo -e "${RED}|$(printf '%*s' $(((box_width + 8) / 2)) "WARNING")$(printf '%*s' $(((box_width - 8) / 2)) "")|${NC}"
+  echo -e "${RED}+${border_line}+${NC}"
+
+  if command -v fold &>/dev/null; then
+    echo "$message" | fold -s -w "$content_width" | while IFS= read -r line; do
+      printf "${RED}|${NC} %-${content_width}s ${RED}|${NC}\n" "$line"
+    done
+  else
+    printf "${RED}|${NC} %-${content_width}s ${RED}|${NC}\n" "$message"
+  fi
+
+  echo -e "${RED}+${border_line}+${NC}"
+  echo ""
+}
+
+show_spinner() {
+  local duration="$1"
+  local message="${2:-Processing...}"
+  local spinner=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
+
+  if ! [[ "$duration" =~ ^[0-9]+$ ]] || [[ "$duration" -lt 1 ]]; then
+    duration=1
+  fi
+
+  local start_time=$(date +%s)
+  local end_time=$((start_time + duration))
+  local current_time=$start_time
+
+  echo -n "$message "
+
+  while [[ "$current_time" -lt "$end_time" ]]; do
+    for frame in "${spinner[@]}"; do
+      echo -ne "\r$message $frame"
+      sleep 0.1
+      current_time=$(date +%s)
+      [[ "$current_time" -ge "$end_time" ]] && break 2
+    done
+  done
+
+  echo -ne "\r$message ✓\n"
+}
+
+notify_silent() {
+  local title="$1"
+  local message="$2"
+  local urgency="${3:-normal}"
+
+  notify-send -u "$urgency" -- "$title" "$message" 2>/dev/null || true
+}
+
+detect_gpu_mode_from_driver() {
+  local driver="$1"
+  case "$driver" in
+  vfio-pci)
+    echo "vm"
+    ;;
+  nvidia | nvidia_drm | amdgpu | i915)
+    echo "host"
+    ;;
+  "")
+    echo "none"
+    ;;
+  *)
+    echo "unknown"
+    ;;
+  esac
+}
+
+log_init() {
+  if [[ ! -d "$LOG_DIR" ]]; then
+    sudo -n mkdir -p "$LOG_DIR" 2>/dev/null || {
+      LOG_DIR="$HOME/.local/share/omarchy-gpu-passthrough/logs"
+      LOG_FILE="$LOG_DIR/gpu-passthrough.log"
+      mkdir -p "$LOG_DIR" 2>/dev/null || return 1
+    }
+  fi
+
+  if [[ -f "$LOG_FILE" ]]; then
+    local log_size=$(stat -c%s "$LOG_FILE" 2>/dev/null || echo 0)
+    if [[ "$log_size" -gt "$LOG_MAX_SIZE" ]]; then
+      local timestamp=$(date +%Y%m%d_%H%M%S)
+      sudo -n mv "$LOG_FILE" "$LOG_FILE.$timestamp" 2>/dev/null ||
+        mv "$LOG_FILE" "$LOG_FILE.$timestamp" 2>/dev/null
+
+      find "$LOG_DIR" -maxdepth 1 -type f -name "gpu-passthrough.log.*" -printf '%T@ %p\n' 2>/dev/null |
+        sort -rn | tail -n +6 | cut -d' ' -f2- | xargs -r rm -f
+    fi
+  fi
+
+  return 0
+}
+
+log_message() {
+  local category="$1"
+  shift
+  local message="$*"
+  local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
+
+  if [[ ! -d "$LOG_DIR" ]]; then
+    log_init || return 1
+  fi
+
+  if [[ -w "$LOG_DIR" ]]; then
+    echo "[$timestamp] [$category] $message" >>"$LOG_FILE" 2>/dev/null
+  else
+    echo "[$timestamp] [$category] $message" | sudo -n tee -a "$LOG_FILE" >/dev/null 2>&1 || true
+  fi
+}
+
+log_info() {
+  log_message "INFO" "$@"
+}
+
+log_success() {
+  log_message "SUCCESS" "$@"
+}
+
+log_error() {
+  log_message "ERROR" "$@"
+}
+
+log_warn() {
+  log_message "WARN" "$@"
+}
+
+check_dependencies() {
+  local recommended_deps=("mesa-utils" "dmidecode")
+
+  # Check if Vulkan tools are missing (for diagnostics only)
+  if ! command -v vulkaninfo &>/dev/null; then
+    recommended_deps+=("vulkan-tools")
+  fi
+
+  # Check if AMD GPU is present - add radeontop for monitoring
+  if lspci 2>/dev/null | grep -qiE "VGA.*AMD|3D.*AMD|Display.*AMD"; then
+    if ! command -v radeontop &>/dev/null; then
+      recommended_deps+=("radeontop")
+    fi
+  fi
+
+  # Check if Intel GPU is present - add intel-gpu-tools for monitoring
+  if lspci 2>/dev/null | grep -qiE "VGA.*Intel|Display.*Intel"; then
+    if ! command -v intel_gpu_top &>/dev/null; then
+      recommended_deps+=("intel-gpu-tools")
+    fi
+  fi
+
+  local missing=()
+  for pkg in "${recommended_deps[@]}"; do
+    if ! pacman -Qi "$pkg" &>/dev/null; then
+      missing+=("$pkg")
+    fi
+  done
+
+  if [[ "${#missing[@]}" -gt 0 ]]; then
+    msg_info "Installing optional diagnostic tools: ${missing[*]}"
+
+    if sudo pacman -S --needed --noconfirm "${missing[@]}" >/dev/null 2>&1; then
+      msg_success "Diagnostic tools installed"
+    else
+      msg_warning "Optional tools not installed (diagnostics may be limited)"
+      msg_info "  Install manually if needed: sudo pacman -S ${missing[*]}"
+    fi
+  fi
+
+  return 0
+}
+
+get_grub_regenerate_cmd() {
+  if command -v update-grub &>/dev/null; then
+    echo "update-grub"
+  elif [[ -f /boot/grub2/grub.cfg ]]; then
+    echo "grub2-mkconfig -o /boot/grub2/grub.cfg"
+  elif [[ -f /boot/grub/grub.cfg ]]; then
+    echo "grub-mkconfig -o /boot/grub/grub.cfg"
+  else
+    echo ""
+  fi
+}
+
+get_cpu_vendor() {
+  local vendor=$(grep -m1 "vendor_id" /proc/cpuinfo | awk '{print $3}')
+  case "$vendor" in
+  AuthenticAMD)
+    echo "amd"
+    ;;
+  GenuineIntel)
+    echo "intel"
+    ;;
+  *)
+    echo "unknown"
+    ;;
+  esac
+}
+
+check_cpu_iommu_capability() {
+  local vendor=$(get_cpu_vendor)
+
+  case "$vendor" in
+  amd)
+    if grep -q "svm" /proc/cpuinfo; then
+      return 0
+    fi
+    ;;
+  intel)
+    if grep -q "vmx" /proc/cpuinfo; then
+      return 0
+    fi
+    ;;
+  esac
+
+  return 1
+}
+
+detect_virtualization() {
+  IS_VIRTUAL_MACHINE=false
+  VIRTUALIZATION_TYPE=""
+
+  if command -v systemd-detect-virt &>/dev/null; then
+    local virt_type
+    virt_type=$(systemd-detect-virt 2>/dev/null) || virt_type=""
+    if [[ -n "$virt_type" && "$virt_type" != "none" ]]; then
+      IS_VIRTUAL_MACHINE=true
+      VIRTUALIZATION_TYPE="$virt_type"
+      return 1
+    fi
+  fi
+
+  if [[ -r /sys/class/dmi/id/product_name ]]; then
+    local product
+    product=$(<"/sys/class/dmi/id/product_name") 2>/dev/null || product=""
+    if [[ "$product" =~ [Vv]irtual|[Vv][Mm]ware|[Qq][Ee][Mm][Uu]|[Kk][Vv][Mm]|[Xx]en|[Bb]ochs|[Pp]arallels ]]; then
+      IS_VIRTUAL_MACHINE=true
+      VIRTUALIZATION_TYPE="$product"
+      return 1
+    fi
+  fi
+
+  if [[ -r /proc/cpuinfo ]] && grep -q "^flags.*hypervisor" /proc/cpuinfo; then
+    IS_VIRTUAL_MACHINE=true
+    VIRTUALIZATION_TYPE="unknown hypervisor"
+    return 1
+  fi
+
+  if journalctl -k -b 2>/dev/null | grep -qiE "hypervisor detected|kvm|qemu|vmware|xen|virtualbox"; then
+    IS_VIRTUAL_MACHINE=true
+    VIRTUALIZATION_TYPE="detected via kernel log"
+    return 1
+  fi
+
+  return 0
+}
+
+check_iommu_support() {
+  if journalctl -k -b 2>/dev/null | grep -qi "IOMMU enabled\|AMD-Vi\|DMAR"; then
+    return 0
+  fi
+
+  if grep -qE "amd_iommu=on|intel_iommu=on" /proc/cmdline; then
+    return 0
+  fi
+
+  if [[ -d /sys/kernel/iommu_groups ]] && [[ -n "$(ls -A /sys/kernel/iommu_groups 2>/dev/null)" ]]; then
+    return 0
+  fi
+
+  return 1
+}
+
+save_gpu_config() {
+  local idx="$1"
+  local pci="${GPU_PCI_ADDR[$idx]}"
+  local vendor_id="${GPU_VENDOR_ID[$idx]}"
+  local device_id="${GPU_DEVICE_ID[$idx]}"
+  local name="${GPU_NAME[$idx]}"
+  local audio_id="${GPU_AUDIO_ID[$idx]}"
+  local driver="${GPU_DRIVER[$idx]}"
+
+  local native_driver="none"
+  case "$vendor_id" in
+  10de) native_driver="nvidia" ;;
+  1002) native_driver="amdgpu" ;;
+  8086) native_driver="i915" ;;
+  *)
+    if [[ -n "$driver" && "$driver" != "none" ]]; then
+      native_driver="$driver"
+    fi
+    ;;
+  esac
+
+  # Get IOMMU group info (supports multi-device groups on laptops and AMD Vega with separate audio group)
+  local iommu_group
+  iommu_group=$(get_gpu_passthrough_iommu_groups "$pci" "$vendor_id")
+  local iommu_devices
+  iommu_devices=$(get_gpu_passthrough_devices "$pci" "$vendor_id")
+
+  # Debug logging for IOMMU detection (helps diagnose laptop issues)
+  if [[ "$iommu_group" == "unknown" ]]; then
+    log_warn "IOMMU group detection failed for $pci"
+    log_warn "  This is expected before first reboot with IOMMU enabled"
+  fi
+  if [[ -z "$iommu_devices" ]]; then
+    log_warn "IOMMU devices detection returned empty for $pci"
+    log_warn "  USB controller binding will use fallback detection in configure_vfio_modules()"
+  fi
+  log_info "Saving config: IOMMU group=$iommu_group, devices=${iommu_devices:-NONE}"
+
+  # Legacy audio_pci for backwards compatibility
+  local audio_pci=""
+  if [[ -n "$audio_id" ]]; then
+    audio_pci="${pci%%.*}.1"
+  fi
+
+  # Detect external monitor on the SPECIFIC passthrough GPU (not all dGPUs)
+  local dgpu_has_external="false"
+  local drm_card_passthrough=$(get_drm_card_for_pci "$pci")
+
+  if [[ -n "$drm_card_passthrough" ]]; then
+    # DRM card exists - can detect connectors directly
+    for connector_type in HDMI DP VGA; do
+      for connector in /sys/class/drm/${drm_card_passthrough}-${connector_type}*/status; do
+        if [[ -f "$connector" ]] && grep -qx "connected" "$connector" 2>/dev/null; then
+          dgpu_has_external="true"
+          log_info "External monitor detected on passthrough GPU ($connector_type)"
+          break 2
+        fi
+      done
+    done
+  else
+    # No DRM card (driver blacklisted) - preserve existing value from config
+    if [[ -f "$GPU_PASSTHROUGH_CONF" ]]; then
+      local existing_value
+      existing_value=$(grep "^DGPU_HAS_EXTERNAL_MONITOR=" "$GPU_PASSTHROUGH_CONF" 2>/dev/null | cut -d'"' -f2)
+      if [[ "$existing_value" == "true" ]]; then
+        log_info "Preserving DGPU_HAS_EXTERNAL_MONITOR=true from existing config (driver blacklisted)"
+        dgpu_has_external="true"
+      fi
+    fi
+  fi
+
+  local hybrid_mode="false"
+  if [[ "${HYBRID_MUXLESS_MODE:-false}" == "true" ]]; then
+    hybrid_mode="true"
+  fi
+
+  if ! sudo tee "$GPU_PASSTHROUGH_CONF" >/dev/null <<EOF
+# GPU Passthrough Config - Generated $(date +%Y-%m-%d)
+GPU_PCI_ADDR="$pci"
+GPU_VENDOR_ID="$vendor_id"
+GPU_DEVICE_ID="$device_id"
+GPU_NAME="$name"
+GPU_DRIVER_ORIGINAL="$native_driver"
+GPU_AUDIO_PCI="$audio_pci"
+GPU_AUDIO_IDS="$audio_id"
+GPU_IOMMU_GROUP="$iommu_group"
+GPU_IOMMU_DEVICES="$iommu_devices"
+DGPU_HAS_EXTERNAL_MONITOR="$dgpu_has_external"
+HYBRID_MUXLESS_MODE="$hybrid_mode"
+IGPU_PCI="${IGPU_PCI:-}"
+DGPU_PCI="${DGPU_PCI:-$pci}"
+IS_MUXLESS_LAPTOP="${IS_MUXLESS_LAPTOP:-false}"
+EOF
+  then
+    log_error "Failed to write config file (sudo tee failed)"
+    return 1
+  fi
+
+  # Verify file was created with correct owner
+  if [[ ! -f "$GPU_PASSTHROUGH_CONF" ]]; then
+    log_error "Config file not created: $GPU_PASSTHROUGH_CONF"
+    return 1
+  fi
+
+  local file_owner
+  file_owner=$(stat -c "%U" "$GPU_PASSTHROUGH_CONF" 2>/dev/null)
+  if [[ "$file_owner" != "root" ]]; then
+    log_error "Config file has wrong owner: $file_owner (expected root)"
+    return 1
+  fi
+
+  # Verify config can be loaded (validates format and content)
+  if ! load_gpu_config; then
+    log_error "Config file created but validation failed"
+    return 1
+  fi
+
+  msg_success "Config saved: $GPU_PASSTHROUGH_CONF"
+  return 0
+}
+
+validate_pci_address() {
+  local pci="$1"
+  [[ "$pci" =~ ^([0-9a-fA-F]{4}:)?[0-9a-fA-F]{2}:[0-9a-fA-F]{2}\.[0-7]$ ]]
+}
+
+detect_gpus() {
+  local i=0
+
+  GPU_PCI_ADDR=()
+  GPU_VENDOR_ID=()
+  GPU_DEVICE_ID=()
+  GPU_NAME=()
+  GPU_DRIVER=()
+  GPU_TYPE=()
+  GPU_AUDIO_ID=()
+
+  while IFS= read -r line; do
+    if [[ -z "$line" ]]; then
+      continue
+    fi
+
+    local pci_addr="${line%% *}"
+    if [[ -z "$pci_addr" ]]; then
+      continue
+    fi
+
+    if ! validate_pci_address "$pci_addr"; then
+      continue
+    fi
+
+    # Filter non-GPU devices (class 03xx = display controllers)
+    local pci_class=$(get_pci_class "$pci_addr")
+    if [[ ! "$pci_class" =~ ^03 ]]; then
+      continue
+    fi
+
+    local vendor_id="" device_id=""
+    if [[ "$line" =~ \[([0-9a-f]{4}):([0-9a-f]{4})\][^[]*$ ]]; then
+      vendor_id="${BASH_REMATCH[1]}"
+      device_id="${BASH_REMATCH[2]}"
+    else
+      continue
+    fi
+
+    local name="${line#*]: }"
+    name="${name% \[[0-9a-f][0-9a-f][0-9a-f][0-9a-f]:[0-9a-f][0-9a-f][0-9a-f][0-9a-f]\]*}"
+    name="${name%"${name##*[![:space:]]}"}"
+
+    local driver=$(get_pci_driver "$pci_addr")
+    [[ -z "$driver" ]] && driver="none"
+
+    local gpu_type=$(classify_gpu "$name" "$vendor_id")
+
+    local audio_id=$(get_gpu_audio_device "$pci_addr")
+
+    GPU_PCI_ADDR+=("$pci_addr")
+    GPU_VENDOR_ID+=("$vendor_id")
+    GPU_DEVICE_ID+=("$device_id")
+    GPU_NAME+=("$name")
+    GPU_DRIVER+=("$driver")
+    GPU_TYPE+=("$gpu_type")
+    GPU_AUDIO_ID+=("$audio_id")
+
+    i=$((i + 1))
+  done < <(lspci -nn | grep -iE 'VGA compatible|3D controller|Display controller')
+
+  GPU_COUNT=$i
+
+  return 0
+}
+
+classify_gpu() {
+  local name="$1"
+  local vendor_id="$2"
+  local name_lower="${name,,}"
+
+  # Intel integrated GPUs
+  if [[ "$vendor_id" == "8086" ]]; then
+    if [[ "$name_lower" =~ $INTEL_IGPU_REGEX ]]; then
+      echo "integrated"
+      return
+    fi
+  fi
+
+  # AMD integrated GPUs
+  if [[ "$vendor_id" == "1002" ]]; then
+    if [[ "$name_lower" =~ $AMD_APU_REGEX ]]; then
+      echo "integrated"
+      return
+    fi
+  fi
+
+  echo "dedicated"
+}
+
+get_gpu_audio_device() {
+  local gpu_pci="$1"
+  local audio_pci="${gpu_pci%%.*}.1"
+
+  if lspci -s "$audio_pci" 2>/dev/null | grep -qi "audio"; then
+    local audio_id=$(get_pci_device_id "$audio_pci")
+    echo "$audio_id"
+  else
+    echo ""
+  fi
+}
+
+# GPU PCI class codes
+GPU_CLASS_VGA="0300"
+GPU_CLASS_3D="0302"
+GPU_CLASS_DISPLAY="0380"
+GPU_CLASS_AUDIO="0403"
+GPU_CLASS_USB="0c03"
+
+# Get Intel GPU stats from sysfs
+# Returns: shell variables for temp, freq, etc.
+get_intel_gpu_stats() {
+  local pci_addr="$1"
+  local drm_card
+  drm_card=$(get_drm_card_for_pci "$pci_addr") || return 1
+
+  local device_path="/sys/class/drm/${drm_card}/device"
+  [[ ! -d "$device_path" ]] && return 1
+
+  # Find hwmon path
+  local hwmon_path=""
+  for hwmon in "$device_path"/hwmon/hwmon*; do
+    [[ -d "$hwmon" ]] && hwmon_path="$hwmon" && break
+  done
+
+  # GPU frequency (current)
+  local gpu_freq=0
+  if [[ -r "$device_path/gt_cur_freq_mhz" ]]; then
+    gpu_freq=$(<"$device_path/gt_cur_freq_mhz")
+  elif [[ -r "$device_path/gt/gt0/rps_cur_freq_mhz" ]]; then
+    gpu_freq=$(<"$device_path/gt/gt0/rps_cur_freq_mhz")
+  fi
+
+  # GPU frequency limits
+  local gpu_freq_min=0 gpu_freq_max=0
+  [[ -r "$device_path/gt_min_freq_mhz" ]] && gpu_freq_min=$(<"$device_path/gt_min_freq_mhz")
+  [[ -r "$device_path/gt_max_freq_mhz" ]] && gpu_freq_max=$(<"$device_path/gt_max_freq_mhz")
+
+  # Temperature (milliCelsius) - Intel GPUs often report via hwmon
+  local temp=0
+  if [[ -n "$hwmon_path" && -r "$hwmon_path/temp1_input" ]]; then
+    temp=$(<"$hwmon_path/temp1_input")
+  fi
+
+  # Power (microWatts)
+  local power=0
+  if [[ -n "$hwmon_path" ]]; then
+    if [[ -r "$hwmon_path/power1_input" ]]; then
+      power=$(<"$hwmon_path/power1_input")
+    elif [[ -r "$hwmon_path/energy1_input" ]]; then
+      # Some Intel GPUs report energy counter, not power
+      power=0  # Would need delta calculation
+    fi
+  fi
+
+  # Output as shell variables
+  echo "gpu_freq_mhz=$gpu_freq"
+  echo "gpu_freq_min_mhz=$gpu_freq_min"
+  echo "gpu_freq_max_mhz=$gpu_freq_max"
+  echo "temp_c=$((temp / 1000))"
+  echo "power_w=$((power / 1000000))"
+}
+
+# Get NVIDIA GPU stats via nvidia-smi
+# Returns: shell variables for vram, temp, power, clocks, vbios
+get_nvidia_gpu_stats() {
+  local pci_addr="$1"
+
+  command -v nvidia-smi &>/dev/null || return 1
+
+  local pci_normalized
+  pci_normalized=$(normalize_pci_addr "$pci_addr") || return 1
+
+  local vram_used vram_total temp power gpu_clock mem_clock vbios
+
+  vram_used=$(nvidia-smi --query-gpu=memory.used --format=csv,noheader,nounits --id="$pci_normalized" 2>/dev/null | head -1)
+  vram_total=$(nvidia-smi --query-gpu=memory.total --format=csv,noheader,nounits --id="$pci_normalized" 2>/dev/null | head -1)
+  temp=$(nvidia-smi --query-gpu=temperature.gpu --format=csv,noheader,nounits --id="$pci_normalized" 2>/dev/null | head -1)
+  power=$(nvidia-smi --query-gpu=power.draw --format=csv,noheader,nounits --id="$pci_normalized" 2>/dev/null | head -1)
+  gpu_clock=$(nvidia-smi --query-gpu=clocks.gr --format=csv,noheader,nounits --id="$pci_normalized" 2>/dev/null | head -1)
+  mem_clock=$(nvidia-smi --query-gpu=clocks.mem --format=csv,noheader,nounits --id="$pci_normalized" 2>/dev/null | head -1)
+  vbios=$(nvidia-smi --query-gpu=vbios_version --format=csv,noheader --id="$pci_normalized" 2>/dev/null | head -1)
+
+  # Validate and default values
+  [[ ! "$vram_used" =~ ^[0-9]+$ ]] && vram_used=0
+  [[ ! "$vram_total" =~ ^[0-9]+$ ]] && vram_total=0
+  [[ ! "$temp" =~ ^[0-9]+$ ]] && temp=0
+  [[ ! "$gpu_clock" =~ ^[0-9]+$ ]] && gpu_clock=0
+  [[ ! "$mem_clock" =~ ^[0-9]+$ ]] && mem_clock=0
+
+  # Power can be float
+  if [[ "$power" =~ ^[0-9.]+$ ]]; then
+    power=$(printf "%.0f" "$power")
+  else
+    power=0
+  fi
+
+  # Escape vbios string
+  vbios="${vbios//\\/\\\\}"
+  vbios="${vbios//\"/\\\"}"
+  vbios="${vbios//\$/\\\$}"
+  vbios="${vbios//\`/\\\`}"
+
+  echo "vram_used_mb=$vram_used"
+  echo "vram_total_mb=$vram_total"
+  echo "temp_c=$temp"
+  echo "power_w=$power"
+  echo "gpu_clock_mhz=\"$gpu_clock\""
+  echo "mem_clock_mhz=\"$mem_clock\""
+  echo "vbios=\"$vbios\""
+}
+
+# Get AMD GPU stats from sysfs
+# Returns: associative array with vram_used, vram_total, temp, power, fan, vbios, gtt_used, gtt_total
+get_amd_gpu_stats() {
+  local pci_addr="$1"
+  local drm_card
+  drm_card=$(get_drm_card_for_pci "$pci_addr") || return 1
+
+  local device_path="/sys/class/drm/${drm_card}/device"
+  [[ ! -d "$device_path" ]] && return 1
+
+  local hwmon_path=""
+  for hwmon in "$device_path"/hwmon/hwmon*; do
+    [[ -d "$hwmon" ]] && hwmon_path="$hwmon" && break
+  done
+
+  # VRAM
+  local vram_used=0 vram_total=0
+  [[ -r "$device_path/mem_info_vram_used" ]] && vram_used=$(<"$device_path/mem_info_vram_used")
+  [[ -r "$device_path/mem_info_vram_total" ]] && vram_total=$(<"$device_path/mem_info_vram_total")
+
+  # GTT (system RAM used by GPU)
+  local gtt_used=0 gtt_total=0
+  [[ -r "$device_path/mem_info_gtt_used" ]] && gtt_used=$(<"$device_path/mem_info_gtt_used")
+  [[ -r "$device_path/mem_info_gtt_total" ]] && gtt_total=$(<"$device_path/mem_info_gtt_total")
+
+  # Temperature (milliCelsius)
+  local temp=0
+  [[ -n "$hwmon_path" && -r "$hwmon_path/temp1_input" ]] && temp=$(<"$hwmon_path/temp1_input")
+
+  # Power (microWatts) - try average first, then current
+  local power=0
+  if [[ -n "$hwmon_path" ]]; then
+    if [[ -r "$hwmon_path/power1_average" ]]; then
+      power=$(<"$hwmon_path/power1_average")
+    elif [[ -r "$hwmon_path/power1_input" ]]; then
+      power=$(<"$hwmon_path/power1_input")
+    fi
+  fi
+
+  # Fan speed (RPM)
+  local fan=0
+  [[ -n "$hwmon_path" && -r "$hwmon_path/fan1_input" ]] && fan=$(<"$hwmon_path/fan1_input")
+
+  # VBIOS version
+  local vbios=""
+  [[ -r "$device_path/vbios_version" ]] && vbios=$(<"$device_path/vbios_version")
+
+  # GPU clock levels
+  local gpu_clock="" mem_clock=""
+  if [[ -r "$device_path/pp_dpm_sclk" ]]; then
+    gpu_clock=$(grep '\*' "$device_path/pp_dpm_sclk" 2>/dev/null | grep -oP '\d+(?=Mhz)' | head -1)
+  fi
+  if [[ -r "$device_path/pp_dpm_mclk" ]]; then
+    mem_clock=$(grep '\*' "$device_path/pp_dpm_mclk" 2>/dev/null | grep -oP '\d+(?=Mhz)' | head -1)
+  fi
+
+  # Output as shell variables (MB/Celsius/Watts)
+  vbios="${vbios//\\/\\\\}"
+  vbios="${vbios//\"/\\\"}"
+  vbios="${vbios//\$/\\\$}"
+  vbios="${vbios//\`/\\\`}"
+
+  echo "vram_used_mb=$((vram_used / 1024 / 1024))"
+  echo "vram_total_mb=$((vram_total / 1024 / 1024))"
+  echo "gtt_used_mb=$((gtt_used / 1024 / 1024))"
+  echo "gtt_total_mb=$((gtt_total / 1024 / 1024))"
+  echo "temp_c=$((temp / 1000))"
+  echo "power_w=$((power / 1000000))"
+  echo "fan_rpm=$fan"
+  echo "vbios=\"$vbios\""
+  echo "gpu_clock_mhz=\"$gpu_clock\""
+  echo "mem_clock_mhz=\"$mem_clock\""
+}
+
+# Get GPU power consumption in Watts
+get_gpu_power_watts() {
+  local pci_addr="$1"
+  local vendor_id="${2:-}"
+  local driver="${3:-}"
+
+  # AMD: use sysfs
+  if [[ "$vendor_id" == "1002" ]]; then
+    local drm_card
+    drm_card=$(get_drm_card_for_pci "$pci_addr") || { echo "0"; return; }
+    local hwmon_path=""
+    for hwmon in "/sys/class/drm/${drm_card}/device/hwmon/hwmon"*; do
+      [[ -d "$hwmon" ]] && hwmon_path="$hwmon" && break
+    done
+    if [[ -n "$hwmon_path" ]]; then
+      local power=0
+      if [[ -r "$hwmon_path/power1_average" ]]; then
+        power=$(<"$hwmon_path/power1_average")
+      elif [[ -r "$hwmon_path/power1_input" ]]; then
+        power=$(<"$hwmon_path/power1_input")
+      fi
+      echo "$((power / 1000000))"
+      return
+    fi
+  fi
+
+  # NVIDIA: use nvidia-smi
+  if [[ "$vendor_id" == "10de" ]] && command -v nvidia-smi &>/dev/null; then
+    local pci_normalized
+    pci_normalized=$(normalize_pci_addr "$pci_addr") || { echo "0"; return; }
+    local power
+    power=$(nvidia-smi --query-gpu=power.draw --format=csv,noheader,nounits --id="$pci_normalized" 2>/dev/null | head -1)
+    if [[ "$power" =~ ^[0-9.]+$ ]]; then
+      printf "%.0f" "$power"
+      return
+    fi
+  fi
+
+  echo "0"
+}
+
+# Get GPU temperature in Celsius
+get_gpu_temp_celsius() {
+  local pci_addr="$1"
+  local vendor_id="${2:-}"
+
+  # AMD: use sysfs
+  if [[ "$vendor_id" == "1002" ]]; then
+    local drm_card
+    drm_card=$(get_drm_card_for_pci "$pci_addr") || { echo "0"; return; }
+    local hwmon_path=""
+    for hwmon in "/sys/class/drm/${drm_card}/device/hwmon/hwmon"*; do
+      [[ -d "$hwmon" ]] && hwmon_path="$hwmon" && break
+    done
+    if [[ -n "$hwmon_path" && -r "$hwmon_path/temp1_input" ]]; then
+      local temp=$(<"$hwmon_path/temp1_input")
+      echo "$((temp / 1000))"
+      return
+    fi
+  fi
+
+  # NVIDIA: use nvidia-smi
+  if [[ "$vendor_id" == "10de" ]] && command -v nvidia-smi &>/dev/null; then
+    local pci_normalized
+    pci_normalized=$(normalize_pci_addr "$pci_addr") || { echo "0"; return; }
+    local temp
+    temp=$(nvidia-smi --query-gpu=temperature.gpu --format=csv,noheader,nounits --id="$pci_normalized" 2>/dev/null | head -1)
+    if [[ "$temp" =~ ^[0-9]+$ ]]; then
+      echo "$temp"
+      return
+    fi
+  fi
+
+  echo "0"
+}
+
+# Get VBIOS version
+get_gpu_vbios() {
+  local pci_addr="$1"
+  local vendor_id="${2:-}"
+
+  # AMD: use sysfs
+  if [[ "$vendor_id" == "1002" ]]; then
+    local drm_card
+    drm_card=$(get_drm_card_for_pci "$pci_addr") || { echo ""; return; }
+    local vbios_path="/sys/class/drm/${drm_card}/device/vbios_version"
+    if [[ -r "$vbios_path" ]]; then
+      cat "$vbios_path"
+      return
+    fi
+  fi
+
+  # NVIDIA: use nvidia-smi
+  if [[ "$vendor_id" == "10de" ]] && command -v nvidia-smi &>/dev/null; then
+    local pci_normalized
+    pci_normalized=$(normalize_pci_addr "$pci_addr") || { echo ""; return; }
+    nvidia-smi --query-gpu=vbios_version --format=csv,noheader --id="$pci_normalized" 2>/dev/null | head -1
+    return
+  fi
+
+  echo ""
+}
+
+# Get GPU vRAM in MB
+get_gpu_vram_mb() {
+  local gpu_pci="$1"
+  local vendor_id="${2:-}"
+  local driver="${3:-}"
+
+  # NVIDIA: use nvidia-smi
+  if [[ "$vendor_id" == "10de" ]] && [[ "$driver" == "nvidia" ]] && command -v nvidia-smi &>/dev/null; then
+    local pci_normalized
+    pci_normalized=$(normalize_pci_addr "$gpu_pci") || return 0
+
+    local nvidia_vram
+    nvidia_vram=$(nvidia-smi --query-gpu=memory.total --format=csv,noheader,nounits \
+      --id="$pci_normalized" 2>/dev/null | head -1)
+    if [[ -n "$nvidia_vram" ]]; then
+      if [[ "$nvidia_vram" =~ ^([0-9]+)$ ]]; then
+        echo "${BASH_REMATCH[1]}"
+        return
+      elif [[ "$nvidia_vram" =~ ^([0-9]+)\ GB$ ]]; then
+        echo $((${BASH_REMATCH[1]} * 1024))
+        return
+      elif [[ "$nvidia_vram" =~ ^([0-9]+)\ MiB$ ]]; then
+        echo "${BASH_REMATCH[1]}"
+        return
+      fi
+    fi
+  fi
+
+  # AMD: use sysfs
+  if [[ "$vendor_id" == "1002" ]] && [[ "$driver" == "amdgpu" ]]; then
+    local drm_card=$(get_drm_card_for_pci "$gpu_pci")
+    if [[ -n "$drm_card" ]]; then
+      local sysfs_vram="/sys/class/drm/${drm_card}/device/mem_info_vram_total"
+      if [[ -r "$sysfs_vram" ]]; then
+        local vram_bytes=$(<"$sysfs_vram")
+        if [[ -n "$vram_bytes" && "$vram_bytes" =~ ^[0-9]+$ ]]; then
+          echo "$((vram_bytes / 1024 / 1024))"
+          return
+        fi
+      fi
+    fi
+  fi
+
+  echo "0"
+}
+
+# Get GPU BAR size in MB
+get_gpu_bar_size_mb() {
+  local gpu_pci="$1"
+  local max_size_mb=0
+
+  while IFS= read -r line; do
+    if [[ "$line" =~ \[size=([0-9]+)([GMK])\] ]]; then
+      local size="${BASH_REMATCH[1]}"
+      local unit="${BASH_REMATCH[2]}"
+      local size_mb=0
+      case "$unit" in
+        G) size_mb=$((size * 1024)) ;;
+        M) size_mb="$size" ;;
+        K) size_mb=$((size / 1024)) ;;
+      esac
+      [[ "$size_mb" -gt "$max_size_mb" ]] && max_size_mb="$size_mb"
+    fi
+  done < <(lspci -v -s "$gpu_pci" 2>/dev/null | grep "Memory.*prefetchable")
+
+  echo "$max_size_mb"
+}
+
+# Format memory size for display (MB -> "X GB" or "X MB")
+format_memory_size() {
+  local size_mb="$1"
+  if [[ "$size_mb" -ge 1024 ]]; then
+    echo "$((size_mb / 1024)) GB"
+  elif [[ "$size_mb" -gt 0 ]]; then
+    echo "${size_mb} MB"
+  else
+    echo ""
+  fi
+}
+
+get_gpu_memory() {
+  local gpu_pci="$1"
+  local vendor_id="${2:-}"
+
+  # Detect driver for vRAM lookup
+  local driver=""
+  if [[ "$vendor_id" == "10de" || "$vendor_id" == "1002" ]]; then
+    driver=$(get_pci_driver "$gpu_pci")
+  fi
+
+  # Try vRAM first
+  local vram_mb=$(get_gpu_vram_mb "$gpu_pci" "$vendor_id" "$driver")
+  if [[ "$vram_mb" -gt 0 ]]; then
+    local result=$(format_memory_size "$vram_mb")
+    [[ -n "$result" ]] && echo "$result" && return
+  fi
+
+  # Fall back to BAR size
+  local bar_mb=$(get_gpu_bar_size_mb "$gpu_pci")
+  if [[ "$bar_mb" -gt 0 ]]; then
+    local result=$(format_memory_size "$bar_mb")
+    [[ -n "$result" ]] && echo "$result" && return
+  fi
+
+  echo "Unknown"
+}
+
+# Check if ReBAR enabled (BAR > 256MB)
+check_resizable_bar() {
+  local gpu_pci="$1"
+
+  # Method 1: Check prefetchable BAR size
+  local bar_mb=$(get_gpu_bar_size_mb "$gpu_pci")
+  [[ "$bar_mb" -gt 256 ]] && return 0
+
+  # Method 2: Parse lspci "current size"
+  local current_size size_mb=0
+  current_size=$(lspci -vvvs "$gpu_pci" 2>/dev/null | \
+    grep -A2 "Resizable BAR" | grep -oP 'current size: \K[0-9]+[GM]B' | head -1)
+  [[ -z "$current_size" ]] && return 1
+
+  if [[ "$current_size" =~ ^([0-9]+)GB$ ]]; then
+    size_mb=$(( ${BASH_REMATCH[1]} * 1024 ))
+  elif [[ "$current_size" =~ ^([0-9]+)MB$ ]]; then
+    size_mb="${BASH_REMATCH[1]}"
+  fi
+  [[ "$size_mb" -gt 256 ]] && return 0
+
+  return 1
+}
+
+# Check if early binding is enabled for a GPU
+# Early binding = vfio-pci ids= contains GPU's device ID
+# Returns: 0 = early binding enabled, 1 = runtime binding (or not configured)
+is_early_binding_enabled() {
+  local gpu_pci="${1:-}"
+  local vfio_conf="/etc/modprobe.d/vfio.conf"
+
+  [[ ! -f "$vfio_conf" ]] && return 1
+
+  # Get GPU device ID (e.g., 1002:687f)
+  local device_id=""
+  if [[ -n "$gpu_pci" ]]; then
+    device_id=$(lspci -ns "$gpu_pci" 2>/dev/null | awk '{print $3}')
+  fi
+
+  # Check if vfio.conf has ids= option with this device ID
+  local ids_line
+  ids_line=$(grep -E "^options vfio-pci ids=" "$vfio_conf" 2>/dev/null)
+  [[ -z "$ids_line" ]] && return 1
+
+  # If we have a specific device ID, check if it's in the list
+  if [[ -n "$device_id" ]]; then
+    echo "$ids_line" | grep -qi "${device_id}" && return 0
+    return 1
+  fi
+
+  # No specific GPU, just check if any ids= is configured
+  return 0
+}
+
+# Returns comma-separated vendor:device IDs for USB controllers (e.g., "10de:1ada,10de:1adb")
+get_usb_controller_ids_in_iommu_group() {
+  local gpu_pci="$1"
+  local usb_ids=""
+
+  local iommu_devices=$(get_iommu_group_devices "$gpu_pci")
+  for dev_pci in $iommu_devices; do
+    local dev_class=$(get_pci_class "$dev_pci")
+    # USB controller class: 0c03
+    if [[ "$dev_class" == "0c03" ]]; then
+      local dev_ids=$(get_pci_device_id "$dev_pci")
+      if [[ -n "$dev_ids" ]]; then
+        [[ -n "$usb_ids" ]] && usb_ids="$usb_ids,"
+        usb_ids="$usb_ids$dev_ids"
+      fi
+    fi
+  done
+
+  echo "$usb_ids"
+}
+
+load_gpu_config() {
+  local config_file="$GPU_PASSTHROUGH_CONF"
+
+  if [[ ! -f "$config_file" ]]; then
+    return 1
+  fi
+
+  local config_owner=$(stat -c "%U" "$config_file" 2>/dev/null)
+  local config_perm=$(stat -c "%a" "$config_file" 2>/dev/null)
+
+  if [[ "$config_owner" != "root" ]]; then
+    log_error "Config file has unsafe owner: $config_owner (expected root)"
+    return 1
+  fi
+
+  if [[ "$config_perm" != "644" && "$config_perm" != "600" ]]; then
+    log_warn "Config file has unusual permissions: $config_perm (expected 644 or 600)"
+  fi
+
+  local bad_format_line
+  bad_format_line=$(grep -vE '^\s*(#|$)' "$config_file" 2>/dev/null | grep -vE '^[A-Z_]+="[^"]*"$' | head -1)
+  if [[ -n "$bad_format_line" ]]; then
+    log_error "Config file validation failed: invalid format: $bad_format_line"
+    return 1
+  fi
+
+  local bad_line
+  bad_line=$(grep -E '`|\$\(|\$\{|;|\||&|<|>|\bexec\b|\beval\b|\bsource\b' "$config_file" 2>/dev/null | head -1)
+  if [[ -n "$bad_line" ]]; then
+    log_error "Config file validation failed: dangerous pattern in: $bad_line"
+    return 1
+  fi
+  # Check for `. script` source shorthand only at line start (outside values)
+  bad_line=$(grep -E '^\s*\.\s+' "$config_file" 2>/dev/null | head -1)
+  if [[ -n "$bad_line" ]]; then
+    log_error "Config file validation failed: source shorthand: $bad_line"
+    return 1
+  fi
+
+  source "$config_file" 2>/dev/null || return 1
+
+  if [[ -z "$GPU_PCI_ADDR" ]]; then
+    log_error "Config file missing required GPU_PCI_ADDR"
+    return 1
+  fi
+
+  if ! validate_pci_address "$GPU_PCI_ADDR"; then
+    log_error "Invalid PCI address in config: $GPU_PCI_ADDR"
+    return 1
+  fi
+
+  export GPU_PCI_ADDR
+  export GPU_VENDOR_ID
+  export GPU_DEVICE_ID
+  export GPU_NAME
+  export GPU_DRIVER_ORIGINAL
+  export GPU_AUDIO_PCI
+  export GPU_AUDIO_IDS
+  export GPU_IOMMU_GROUP
+  export GPU_IOMMU_DEVICES
+  export HYBRID_MUXLESS_MODE
+  export IGPU_PCI
+  export DGPU_PCI
+  export IS_MUXLESS_LAPTOP
+  export DGPU_HAS_EXTERNAL_MONITOR
+
+  return 0
+}
+
+get_iommu_group() {
+  local pci_addr
+  pci_addr=$(normalize_pci_addr "$1") || { echo "unknown"; return 1; }
+
+  local iommu_group=$(basename "$(readlink /sys/bus/pci/devices/${pci_addr}/iommu_group 2>/dev/null)" 2>/dev/null)
+
+  if [[ -n "$iommu_group" ]]; then
+    echo "$iommu_group"
+  else
+    echo "unknown"
+  fi
+}
+
+# Get all devices in an IOMMU group
+# Returns: space-separated list of PCI addresses (without 0000: prefix)
+# Note: Filters out PCI bridges (class 0604) - they're host infrastructure, not for VM passthrough
+get_iommu_group_devices() {
+  local pci_addr
+  pci_addr=$(normalize_pci_addr "$1") || return 1
+
+  local iommu_group_path=$(readlink -f /sys/bus/pci/devices/${pci_addr}/iommu_group 2>/dev/null)
+  if [[ -z "$iommu_group_path" ]] || [[ ! -d "$iommu_group_path/devices" ]]; then
+    return 1
+  fi
+
+  local devices=()
+  for dev_path in "$iommu_group_path/devices"/*; do
+    if [[ -d "$dev_path" ]]; then
+      local dev_addr=$(basename "$dev_path")
+
+      # Skip PCI bridges (class 0604) - they're host infrastructure
+      local dev_class=$(get_pci_class "$dev_addr")
+      if [[ "$dev_class" == "0604" ]]; then
+        continue
+      fi
+
+      dev_addr="${dev_addr#0000:}"
+      devices+=("$dev_addr")
+    fi
+  done
+
+  echo "${devices[*]}"
+}
+
+get_drm_card_for_pci() {
+  local pci_addr
+  pci_addr=$(normalize_pci_addr "$1") || return 1
+
+  [[ ! -d /sys/class/drm ]] && return 1
+
+  local device_path="/sys/bus/pci/devices/${pci_addr}"
+  [[ -e "$device_path" ]] || return 1
+
+  for card_dir in "${device_path}"/drm/card*; do
+    [[ "$card_dir" =~ -[A-Za-z] ]] && continue
+
+    [[ "$card_dir" == "/sys/bus/pci/devices/${pci_addr}/drm/card"* ]] || continue
+    if [[ -d "$card_dir" ]]; then
+      basename "$card_dir"
+      return 0
+    fi
+  done
+
+  return 1
+}
+
+get_pci_driver() {
+  local pci_addr="$1"
+  lspci -nnk -s "$pci_addr" 2>/dev/null | grep "Kernel driver in use:" | awk '{print $5}'
+}
+
+get_pci_class() {
+  local pci_addr="$1"
+  lspci -Dn -s "$pci_addr" 2>/dev/null | awk '{print $2}' | cut -d: -f1
+}
+
+get_pci_device_id() {
+  local pci_addr="$1"
+  lspci -nn -s "$pci_addr" 2>/dev/null | grep -oP '\[\K[0-9a-f]{4}:[0-9a-f]{4}(?=\])' | tail -1
+}
+
+is_module_loaded() {
+  local module="$1"
+  [[ -z "$module" ]] && return 1
+  lsmod 2>/dev/null | grep -q "^${module}[[:space:]]"
+}
+
+count_connected_monitors_for_pci() {
+  local pci_addr="$1"
+  local count=0
+
+  local drm_card=$(get_drm_card_for_pci "$pci_addr")
+  if [[ -n "$drm_card" ]]; then
+    for connector in /sys/class/drm/${drm_card}-*/status; do
+      if [[ -f "$connector" ]] && grep -q "^connected$" "$connector" 2>/dev/null; then
+        ((count++))
+      fi
+    done
+  fi
+
+  echo "$count"
+}
+
+detect_bootloader() {
+  if [[ -f "$LIMINE_DEFAULT" ]]; then
+    echo "limine"
+  elif [[ -d /boot/grub ]] || [[ -f "$GRUB_DEFAULT" ]]; then
+    echo "grub"
+  elif [[ -d /boot/loader/entries ]]; then
+    echo "systemd-boot"
+  elif [[ -d /boot/EFI/refind ]]; then
+    echo "refind"
+  else
+    echo "unknown"
+  fi
+}
+
+get_bootloader_display_name() {
+  local id="${1:-$(detect_bootloader)}"
+  case "$id" in
+    limine) echo "Limine" ;;
+    grub) echo "GRUB" ;;
+    systemd-boot) echo "systemd-boot" ;;
+    refind) echo "rEFInd" ;;
+    *) echo "Unknown" ;;
+  esac
+}
+
+get_bootloader_config_path() {
+  local id="${1:-$(detect_bootloader)}"
+  case "$id" in
+    limine) echo "/etc/default/limine" ;;
+    grub) echo "/etc/default/grub" ;;
+    systemd-boot) echo "/boot/loader/entries/*.conf" ;;
+    refind) echo "/boot/refind_linux.conf" ;;
+    *) echo "(unknown)" ;;
+  esac
+}
+
+is_bootloader_supported() {
+  local id="${1:-$(detect_bootloader)}"
+  [[ "$id" == "limine" || "$id" == "grub" ]]
+}
+
+detect_hybrid_graphics_laptop() {
+  IS_MUXLESS_LAPTOP=false
+  DGPU_HAS_EXTERNAL_MONITOR=false
+  IGPU_PCI=""
+  DGPU_PCI=""
+  BIOS_DISPLAY_CONTROL_MISSING=false
+
+  if [[ ${#GPU_PCI_ADDR[@]} -eq 0 ]]; then
+    log_warn "No GPUs detected - cannot detect MUX-less laptop"
+    return 1
+  fi
+
+  CACHED_CHASSIS_TYPE=""
+  [[ -r /sys/class/dmi/id/chassis_type ]] && CACHED_CHASSIS_TYPE=$(<"/sys/class/dmi/id/chassis_type") 2>/dev/null
+
+  for i in "${!GPU_PCI_ADDR[@]}"; do
+    local pci="${GPU_PCI_ADDR[$i]}"
+    local drm_card=$(get_drm_card_for_pci "$pci")
+
+    # Check for internal display connectors (eDP or internal DP)
+    local has_internal_display=false
+    if [[ -n "$drm_card" && -d /sys/class/drm ]]; then
+      # Check eDP first
+      for connector in /sys/class/drm/${drm_card}-eDP-*/status; do
+        if [[ -f "$connector" ]] && grep -qx "connected" "$connector" 2>/dev/null; then
+          has_internal_display=true
+          log_info "Found connected eDP for GPU $pci: $(basename "$(dirname "$connector")")"
+          break
+        fi
+      done
+
+      # If no eDP, check for DP
+      if [[ "$has_internal_display" == "false" ]]; then
+        local dp_connectors=()
+
+        for connector in /sys/class/drm/${drm_card}-DP-*/status; do
+          if [[ -f "$connector" ]] && grep -qx "connected" "$connector" 2>/dev/null; then
+            local connector_name=$(basename "$(dirname "$connector")")
+            dp_connectors+=("$connector_name")
+          fi
+        done
+
+        if [[ ${#dp_connectors[@]} -gt 0 ]]; then
+          local system_has_edp=false
+          if compgen -G "/sys/class/drm/card*-eDP-*/status" > /dev/null 2>&1; then
+            system_has_edp=true
+          fi
+
+          if [[ "$system_has_edp" == "true" ]]; then
+            log_info "System has eDP, treating DP connectors as external for GPU $pci"
+          elif [[ ${#dp_connectors[@]} -eq 1 ]]; then
+            case "$CACHED_CHASSIS_TYPE" in
+              3|4|5|6|7)
+                log_info "Desktop chassis, treating DP-1 as external monitor"
+                ;;
+              8|9|10|14|15)
+                local single_dp="${dp_connectors[0]}"
+                if [[ "$single_dp" == *-DP-1 ]]; then
+                  has_internal_display=true
+                  log_info "Laptop with no eDP, single DP-1 likely internal: $single_dp"
+                fi
+                ;;
+              *)
+                log_info "Unknown chassis type $CACHED_CHASSIS_TYPE, treating DP as external"
+                ;;
+            esac
+          else
+            log_info "Multiple DPs without eDP, treating as external for GPU $pci"
+          fi
+        fi
+      fi
+    fi
+
+    if [[ "$has_internal_display" == "true" ]]; then
+      IGPU_PCI="$pci"
+      log_info "Detected iGPU with internal display: $pci"
+      if [[ "${GPU_TYPE[$i]:-}" != "integrated" ]]; then
+        GPU_TYPE[$i]="integrated"
+        log_info "Updated GPU $pci type to integrated"
+      fi
+    else
+      # GPU without internal display = dGPU
+      if [[ -z "$DGPU_PCI" ]]; then
+        DGPU_PCI="$pci"
+        if [[ -z "$drm_card" ]]; then
+          log_info "Detected dGPU without DRM (driver not loaded): $pci"
+        else
+          log_info "Detected dGPU with external ports only: $pci (DRM: $drm_card)"
+        fi
+      else
+        log_warn "Multiple dGPUs detected ($DGPU_PCI, $pci) - using first"
+      fi
+
+      # Check for external monitor on dGPU
+      if [[ -n "$drm_card" ]]; then
+        for connector_type in HDMI DP VGA; do
+          for connector in /sys/class/drm/${drm_card}-${connector_type}*/status; do
+            if [[ -f "$connector" ]] && grep -qx "connected" "$connector" 2>/dev/null; then
+              DGPU_HAS_EXTERNAL_MONITOR=true
+              log_info "External monitor detected on dGPU $pci: $(basename "$connector")"
+              break 2
+            fi
+          done
+        done
+      fi
+    fi
+  done
+
+  # MUX-less = has both iGPU (with internal display) and dGPU
+  if [[ -n "$IGPU_PCI" && -n "$DGPU_PCI" ]]; then
+    if validate_pci_address "$IGPU_PCI" && validate_pci_address "$DGPU_PCI"; then
+      IS_MUXLESS_LAPTOP=true
+      log_info "MUX-less laptop detected (iGPU: $IGPU_PCI, dGPU: $DGPU_PCI)"
+
+      if ! check_bios_display_control; then
+        BIOS_DISPLAY_CONTROL_MISSING=true
+        log_info "Note: System may lack BIOS display control - Hybrid Mode"
+      fi
+
+      return 0
+    else
+      log_warn "Invalid PCI addresses detected (iGPU: $IGPU_PCI, dGPU: $DGPU_PCI) - not MUX-less"
+      IGPU_PCI=""
+      DGPU_PCI=""
+      return 1
+    fi
+  fi
+
+  return 1
+}
+
+check_bios_display_control() {
+  local chassis="${CACHED_CHASSIS_TYPE:-}"
+  if [[ -z "$chassis" && -r /sys/class/dmi/id/chassis_type ]]; then
+    chassis=$(<"/sys/class/dmi/id/chassis_type") 2>/dev/null || chassis=""
+  fi
+
+  case "$chassis" in
+    3|4|5|6|7) return 0 ;;
+  esac
+
+  if [[ -d /sys/firmware/efi/efivars ]]; then
+    local patterns=(
+      "DisplayInit*" "PrimaryDisplay*" "InitDisplayFirst*"
+      "VBIOSDisplayInit*" "AMIBIOSCDisplayInit*" "SetupDisplayInit*"
+      "VBIOSPrimaryDisplay*" "AMIBIOSCPrimaryDisplay*" "SetupPrimaryDisplay*"
+    )
+    for pattern in "${patterns[@]}"; do
+      for file in /sys/firmware/efi/efivars/${pattern}; do
+        if [[ -f "$file" ]]; then
+          log_info "BIOS display control: ${file##*/}"
+          return 0
+        fi
+      done
+    done
+  fi
+
+  return 1
+}
+
+check_iommu_enabled_cmdline() {
+  local cmdline=""
+  [[ -r /proc/cmdline ]] && cmdline=$(<"/proc/cmdline")
+
+  [[ "$cmdline" =~ (intel_iommu|amd_iommu)=on ]] && return 0
+  journalctl -k -b 2>/dev/null | grep -q "Intel-IOMMU force enabled" && return 0
+
+  return 1
+}
+
+get_cached_iommu_devices() {
+  local pci_addr="$1"
+  local vendor_id="${GPU_VENDOR_ID:-}"
+  local devices="${GPU_IOMMU_DEVICES:-}"
+
+  if [[ -z "$devices" ]]; then
+    # Use get_gpu_passthrough_devices for AMD GPUs with separate audio IOMMU group
+    devices=$(get_gpu_passthrough_devices "$pci_addr" "$vendor_id")
+  fi
+
+  echo "$devices"
+}
+
+update_state_marker() {
+  local mode="$1"
+
+  if ! echo "$mode" | sudo -n /usr/bin/tee "$STATE_MARKER_FILE" >/dev/null 2>&1; then
+    log_warn "Failed to update state marker (continuing anyway)"
+    return 1
+  fi
+  return 0
+}
+
+rebind_usb_controllers_to_xhci() {
+  local iommu_devices="$1"
+
+  [[ ! -d "/sys/bus/pci/drivers/xhci_hcd" ]] && return 0
+
+  for dev_pci in $iommu_devices; do
+    local dev_pci_full
+    dev_pci_full=$(normalize_pci_addr "$dev_pci") || continue
+
+    local dev_class=$(get_pci_class "$dev_pci")
+    if [[ "$dev_class" == "0c03" ]]; then
+      log_info "Rebinding USB controller $dev_pci to xhci_hcd..."
+      echo "$dev_pci_full" | sudo -n tee /sys/bus/pci/drivers/xhci_hcd/bind >/dev/null 2>&1 || true
+    fi
+  done
+
+  return 0
+}
+
+remove_vfio_device_ids() {
+  local iommu_devices="$1"
+
+  for dev_pci in $iommu_devices; do
+    local dev_ids=$(get_pci_device_id "$dev_pci")
+    if [[ -n "$dev_ids" ]]; then
+      echo "${dev_ids/:/ }" | sudo -n tee /sys/bus/pci/drivers/vfio-pci/remove_id >/dev/null 2>&1 || true
+    fi
+  done
+
+  return 0
+}
+
+# Check if GPU has AMD reset bug (cannot rebind to native driver after vfio-pci use)
+# Affected: Vega 10/20, Fiji, Tonga, Hawaii, some Polaris, some Navi 10/14
+# Returns: 0 if GPU has reset bug, 1 if not
+gpu_has_reset_bug() {
+  local pci_addr="$1"
+  local device_id
+  device_id=$(lspci -ns "$pci_addr" 2>/dev/null | awk '{print $3}' | cut -d: -f2)
+
+  [[ "${device_id,,}" =~ ^($AMD_RESET_BUG_DEVICE_IDS)$ ]]
+}
+
+# Check if GPU was bound to vfio-pci during this boot session
+# Used to determine if GPU with reset bug needs reboot before binding to native driver
+was_gpu_on_vfio_this_boot() {
+  local pci_addr="$1"
+  local pci_full
+  pci_full=$(normalize_pci_addr "$pci_addr") || return 1
+
+  # Check dmesg for vfio-pci claiming this device
+  if journalctl -k -b --no-pager 2>/dev/null | grep -F "vfio" | grep -qF "$pci_full"; then
+    return 0
+  fi
+
+  return 1
+}
+
+# Check if GPU needs reboot to use native driver (AMD GPU with reset bug after vfio-pci use)
+# This is the "AMD Reset Bug" - GPU cannot be reset properly without full power cycle
+gpu_needs_reboot_for_native_driver() {
+  local pci_addr="$1"
+  local vendor_id="$2"
+
+  # Only affects AMD GPUs
+  [[ "$vendor_id" != "1002" ]] && return 1
+
+  # Check if GPU has reset bug
+  if ! gpu_has_reset_bug "$pci_addr"; then
+    return 1
+  fi
+
+  # Check if GPU was on vfio-pci this boot
+  if was_gpu_on_vfio_this_boot "$pci_addr"; then
+    return 0
+  fi
+
+  return 1
+}
+
+# Get all devices for GPU passthrough including audio in separate IOMMU groups
+# Returns: space-separated list of PCI addresses (short format without 0000: prefix)
+get_gpu_passthrough_devices() {
+  local gpu_pci="$1"
+  local vendor_id="${2:-}"
+  local devices=()
+
+  # Get devices from main IOMMU group
+  local iommu_devices
+  iommu_devices=$(get_iommu_group_devices "$gpu_pci") || iommu_devices=""
+  for dev in $iommu_devices; do
+    devices+=("$dev")
+  done
+
+  # For AMD GPUs, check if audio device is in a separate IOMMU group
+  if [[ "$vendor_id" == "1002" ]]; then
+    local audio_pci="${gpu_pci%%.*}.1"
+    if lspci -s "$audio_pci" 2>/dev/null | grep -qi "audio"; then
+      local gpu_group audio_group
+      gpu_group=$(get_iommu_group "$gpu_pci")
+      audio_group=$(get_iommu_group "$audio_pci")
+
+      if [[ -n "$audio_group" && "$audio_group" != "unknown" && "$audio_group" != "$gpu_group" ]]; then
+        # Audio is in different group - add it and any other devices in that group
+        log_info "AMD GPU audio in separate IOMMU group (GPU=$gpu_group, Audio=$audio_group)"
+        local audio_group_devices
+        audio_group_devices=$(get_iommu_group_devices "$audio_pci") || audio_group_devices=""
+        for dev in $audio_group_devices; do
+          # Avoid duplicates
+          local found=false
+          for existing in "${devices[@]}"; do
+            [[ "$existing" == "$dev" ]] && found=true && break
+          done
+          [[ "$found" == "false" ]] && devices+=("$dev")
+        done
+      fi
+    fi
+  fi
+
+  echo "${devices[*]}"
+}
+
+# Get all IOMMU groups used by GPU passthrough devices (comma-separated)
+get_gpu_passthrough_iommu_groups() {
+  local gpu_pci="$1"
+  local vendor_id="${2:-}"
+  local groups=()
+
+  # Get main GPU group
+  local gpu_group
+  gpu_group=$(get_iommu_group "$gpu_pci")
+  [[ -n "$gpu_group" && "$gpu_group" != "unknown" ]] && groups+=("$gpu_group")
+
+  # For AMD GPUs, check if audio device is in a separate IOMMU group
+  if [[ "$vendor_id" == "1002" ]]; then
+    local audio_pci="${gpu_pci%%.*}.1"
+    if lspci -s "$audio_pci" 2>/dev/null | grep -qi "audio"; then
+      local audio_group
+      audio_group=$(get_iommu_group "$audio_pci")
+      if [[ -n "$audio_group" && "$audio_group" != "unknown" && "$audio_group" != "$gpu_group" ]]; then
+        groups+=("$audio_group")
+        log_info "Adding separate audio IOMMU group: $audio_group"
+      fi
+    fi
+  fi
+
+  # Return comma-separated list
+  local result
+  result=$(IFS=,; echo "${groups[*]}")
+  echo "$result"
+}
+
+# Check if persistent VFIO mode is enabled for a GPU
+# Returns: 0 if enabled, 1 if not
+is_persistent_vfio_enabled() {
+  local gpu_pci="${1:-}"
+  local vendor_id="${2:-}"
+  local device_id="${3:-}"
+
+  # Check if late binding service exists and is enabled
+  [[ -f "$VFIO_SERVICE" ]] && systemctl is-enabled omarchy-gpu-passthrough.service &>/dev/null
+}
+
+# Enable persistent VFIO mode - GPU will be bound to vfio-pci at boot
+# Uses "late binding" via systemd service (GPU boots on amdgpu for POST, then rebinds)
+enable_persistent_vfio() {
+  local gpu_pci="$1"
+  local vendor_id="$2"
+  local device_id="$3"
+  local skip_initramfs="${4:-false}"
+
+  # Validate inputs
+  if [[ -z "$gpu_pci" ]] || [[ -z "$vendor_id" ]] || [[ -z "$device_id" ]]; then
+    log_error "enable_persistent_vfio: missing required parameters"
+    return 1
+  fi
+
+  if ! [[ "$vendor_id" =~ ^[0-9a-fA-F]{4}$ ]] || ! [[ "$device_id" =~ ^[0-9a-fA-F]{4}$ ]]; then
+    log_error "enable_persistent_vfio: invalid vendor_id or device_id format"
+    return 1
+  fi
+
+  local gpu_id="${vendor_id}:${device_id}"
+
+  # Check if already enabled
+  if is_persistent_vfio_enabled "$gpu_pci" "$vendor_id" "$device_id"; then
+    log_info "Persistent VFIO already enabled for $gpu_id"
+    return 0
+  fi
+
+  # Get all devices in IOMMU group (GPU + audio)
+  # Normalize PCI address to full format (0000:XX:XX.X)
+  local normalized_pci
+  normalized_pci=$(normalize_pci_addr "$gpu_pci")
+  [[ -z "$normalized_pci" ]] && normalized_pci="0000:${gpu_pci}"
+
+  # Get GPU and audio device (function .0 and .1)
+  local base_addr="${normalized_pci%.*}"
+  local devices="$normalized_pci"
+  # Add audio device if exists
+  if [[ -d "/sys/bus/pci/devices/${base_addr}.1" ]]; then
+    devices="$devices ${base_addr}.1"
+  fi
+
+  log_info "Enabling persistent VFIO (late binding) for: $devices"
+
+  # Remove any old early binding ids= from vfio.conf (legacy cleanup)
+  if [[ -f "$VFIO_CONF" ]] && grep -qE "^options vfio-pci ids=" "$VFIO_CONF"; then
+    log_info "Removing legacy early binding ids from vfio.conf..."
+    sudo sed -i '/^options vfio-pci ids=/d' "$VFIO_CONF"
+  fi
+
+  # Create systemd service for late binding
+  # This runs AFTER amdgpu does POST, but BEFORE display-manager
+  local service_content
+  service_content=$(cat <<EOF
+[Unit]
+Description=GPU Passthrough VFIO Late Binding
+Documentation=man:vfio-pci(4)
+DefaultDependencies=no
+# Run after amdgpu loads and does POST
+After=systemd-modules-load.service
+After=systemd-udev-settle.service
+# Run before graphical session starts
+Before=display-manager.service
+Before=graphical.target
+# Don't start if no GPUs configured
+ConditionPathExists=/etc/omarchy-gpu-passthrough.conf
+
+[Service]
+Type=oneshot
+RemainAfterExit=yes
+# Rebind each device from amdgpu to vfio-pci
+# Uses driver_override for clean rebind without ids= parameter
+EOF
+)
+
+  # Add ExecStart for each device
+  for dev in $devices; do
+    service_content+=$'\n'"ExecStart=/bin/bash -c 'dev=\"$dev\"; driver=\$(basename \$(readlink /sys/bus/pci/devices/\$dev/driver 2>/dev/null) 2>/dev/null); if [[ \"\$driver\" != \"vfio-pci\" ]]; then echo \$dev > /sys/bus/pci/devices/\$dev/driver/unbind 2>/dev/null || true; echo vfio-pci > /sys/bus/pci/devices/\$dev/driver_override; echo \$dev > /sys/bus/pci/drivers_probe; fi'"
+  done
+
+  service_content+=$'\n'
+  service_content+=$(cat <<EOF
+
+[Install]
+WantedBy=multi-user.target
+EOF
+)
+
+  # Write and enable service
+  echo "$service_content" | sudo tee "$VFIO_SERVICE" >/dev/null
+  sudo systemctl daemon-reload
+  sudo systemctl enable omarchy-gpu-passthrough.service
+
+  log_success "Late binding service created and enabled"
+  log_info "GPU will boot on amdgpu (POST), then rebind to vfio-pci before login"
+
+  return 0
+}
+
+# Disable persistent VFIO mode - GPU will boot with native driver
+# Removes late binding systemd service
+disable_persistent_vfio() {
+  local gpu_pci="$1"
+  local vendor_id="$2"
+  local device_id="$3"
+  local skip_initramfs="${4:-false}"
+
+  # Validate inputs
+  if [[ -z "$vendor_id" ]] || [[ -z "$device_id" ]]; then
+    log_error "disable_persistent_vfio: missing required parameters"
+    return 1
+  fi
+
+  local gpu_id="${vendor_id}:${device_id}"
+
+  # Check if enabled
+  if ! is_persistent_vfio_enabled "$gpu_pci" "$vendor_id" "$device_id"; then
+    log_info "Persistent VFIO not enabled for $gpu_id"
+    return 0
+  fi
+
+  log_info "Disabling persistent VFIO (late binding) for: $gpu_id"
+
+  # Disable and remove systemd service
+  if [[ -f "$VFIO_SERVICE" ]]; then
+    sudo systemctl disable omarchy-gpu-passthrough.service 2>/dev/null || true
+    sudo rm -f "$VFIO_SERVICE"
+    sudo systemctl daemon-reload
+    log_info "Removed late binding service"
+  fi
+
+  # Also clean up any legacy early binding ids= from vfio.conf
+  if [[ -f "$VFIO_CONF" ]] && grep -qE "^options vfio-pci ids=" "$VFIO_CONF"; then
+    sudo sed -i '/^options vfio-pci ids=/d' "$VFIO_CONF"
+    log_info "Removed legacy early binding ids from vfio.conf"
+  fi
+
+  log_success "Persistent VFIO mode disabled"
+  log_info "GPU will boot with amdgpu after reboot"
+
+  return 0
+}
diff --git a/bin/omarchy-looking-glass-install b/bin/omarchy-looking-glass-install
new file mode 100755
index 0000000000..d0ba355d96
--- /dev/null
+++ b/bin/omarchy-looking-glass-install
@@ -0,0 +1,597 @@
+#!/bin/bash
+# omarchy-looking-glass-install - Install Looking Glass client for VM display
+
+# Preserve original script arguments for exec sg kvm (group refresh)
+ORIGINAL_SCRIPT_ARGS=("$@")
+
+SPICE_DIR="/var/run/omarchy-windows"      # SPICE socket directory (tmpfs, auto-cleaned on reboot)
+SPICE_SOCKET_PATH="$SPICE_DIR/spice.sock" # SPICE Unix socket
+
+msg_error() {
+  echo "❌  Error: $*" >&2
+}
+
+msg_warning() {
+  echo "⚠️  Warning: $*" >&2
+}
+
+msg_success() {
+  echo "✓  $*"
+}
+
+msg_info() {
+  echo "ℹ️  $*"
+}
+
+format_escape_key_name() {
+  case "$1" in
+    KEY_SCROLLLOCK) echo "Scroll Lock" ;;
+    KEY_RIGHTCTRL)  echo "Right Ctrl" ;;
+    KEY_LEFTCTRL)   echo "Left Ctrl" ;;
+    KEY_RIGHTALT)   echo "Right Alt" ;;
+    KEY_PAUSE)      echo "Pause" ;;
+    KEY_INSERT)     echo "Insert" ;;
+    *) echo "${1#KEY_}" ;;
+  esac
+}
+
+create_tmpfiles_config() {
+  local tmpfiles_config_file="/etc/tmpfiles.d/omarchy-windows.conf"
+
+  msg_info "Configuring SPICE directory auto-creation..."
+
+  sudo tee "$tmpfiles_config_file" >/dev/null <<'EOF'
+# Omarchy Windows VM - SPICE socket directory
+# Auto-created on boot by systemd-tmpfiles
+# Directory created in /var/run (tmpfs, cleared on reboot)
+d /var/run/omarchy-windows 0770 root kvm - -
+EOF
+
+  if sudo systemd-tmpfiles --create "$tmpfiles_config_file" 2>/dev/null; then
+    msg_success "SPICE directory tmpfiles configured"
+
+    if [[ -d "$SPICE_DIR" ]]; then
+      local perms=$(stat -c "%a" "$SPICE_DIR" 2>/dev/null)
+      local owner=$(stat -c "%U:%G" "$SPICE_DIR" 2>/dev/null)
+      if [[ "$perms" == "770" ]] && [[ "$owner" == "root:kvm" ]]; then
+        msg_success "SPICE directory ready: $SPICE_DIR"
+      else
+        msg_warning "SPICE directory created but permissions may be incorrect"
+        msg_info "  Expected: 770 root:kvm, Got: $perms $owner"
+      fi
+    else
+      msg_warning "SPICE directory not created (will be created on next boot)"
+    fi
+  else
+    msg_warning "Failed to apply tmpfiles configuration (will be created on next boot)"
+  fi
+
+  return 0
+}
+
+create_sudoers_config() {
+  local sudoers_file="/etc/sudoers.d/omarchy-looking-glass"
+
+  local sudoers_content="# Omarchy Looking Glass - Passwordless Operations
+# Generated by omarchy-looking-glass-install
+
+# SPICE socket detection and permissions
+$USER ALL=(ALL) NOPASSWD: /usr/bin/test -S /var/run/omarchy-windows/spice.sock
+$USER ALL=(ALL) NOPASSWD: /usr/bin/chmod 660 /var/run/omarchy-windows/spice.sock
+$USER ALL=(ALL) NOPASSWD: /usr/bin/chgrp kvm /var/run/omarchy-windows/spice.sock
+
+# SPICE directory creation (fallback if tmpfiles.d fails)
+$USER ALL=(ALL) NOPASSWD: /usr/bin/mkdir -p /var/run/omarchy-windows
+
+# KVMFR module (Looking Glass shared memory)
+$USER ALL=(ALL) NOPASSWD: /usr/bin/modprobe kvmfr, /usr/bin/modprobe kvmfr static_size_mb=*
+"
+
+  local temp_file=$(mktemp)
+  echo "$sudoers_content" > "$temp_file"
+
+  if ! sudo visudo -c -f "$temp_file" 2>&1 | grep -q "parsed OK"; then
+    msg_error "Sudoers syntax validation failed!"
+    echo ""
+    echo "Generated content (for debugging):"
+    cat "$temp_file"
+    echo ""
+    rm -f "$temp_file"
+    return 1
+  fi
+
+  msg_success "Sudoers syntax validated"
+
+  if sudo install -m 440 -o root -g root "$temp_file" "$sudoers_file"; then
+    msg_success "Sudoers rules installed: $sudoers_file"
+
+    if sudo visudo -c 2>&1 | grep -q "parsed OK"; then
+      msg_success "Overall sudoers configuration OK"
+    else
+      msg_error "Overall sudoers check failed!"
+      echo "   This may indicate a conflict with existing sudoers rules"
+      echo "   Check with: sudo visudo -c"
+      sudo rm -f "$sudoers_file"
+      rm -f "$temp_file"
+      return 1
+    fi
+
+  else
+    msg_error "Failed to install sudoers rules"
+    rm -f "$temp_file"
+    return 1
+  fi
+
+  rm -f "$temp_file"
+  return 0
+}
+
+echo "Installing Looking Glass B7..."
+echo "Ultra-low latency VM display as an alternative to RDP."
+echo ""
+
+if ! sudo -v 2>/dev/null; then
+  msg_error "sudo access required for installation"
+  exit 1
+fi
+
+# Check Secure Boot (may block unsigned DKMS modules)
+if command -v mokutil &>/dev/null; then
+  if mokutil --sb-state 2>/dev/null | grep -qi "enabled"; then
+    msg_warning "Secure Boot is ENABLED"
+    echo "   DKMS modules (like kvmfr) may fail to load with Secure Boot."
+    echo "   If installation fails, disable Secure Boot in BIOS settings."
+    echo ""
+  fi
+fi
+
+# Install kernel headers (required for DKMS)
+msg_info "Installing kernel headers..."
+KERNEL=$(uname -r)
+
+# Detect kernel package
+if [[ ! -d "/lib/modules/$KERNEL" ]]; then
+  KERNEL_PACKAGE="linux"
+else
+  KERNEL_PACKAGE=$(pacman -Qo "/lib/modules/$KERNEL" 2>/dev/null | sed -n 's/.* is owned by \([^ ]*\) .*/\1/p' | head -1)
+  [[ -z "$KERNEL_PACKAGE" ]] && KERNEL_PACKAGE="linux"
+fi
+
+# Determine headers package
+case "$KERNEL_PACKAGE" in
+  linux)     HEADERS_PKG="linux-headers" ;;
+  linux-lts) HEADERS_PKG="linux-lts-headers" ;;
+  linux-zen) HEADERS_PKG="linux-zen-headers" ;;
+  *)         HEADERS_PKG="linux-headers" ;;
+esac
+
+# Install quietly
+HEADERS_LOG="/tmp/headers-install-$$.log"
+if ! omarchy-pkg-add "$HEADERS_PKG" > "$HEADERS_LOG" 2>&1; then
+  msg_error "Failed to install $HEADERS_PKG"
+  tail -10 "$HEADERS_LOG"
+  rm -f "$HEADERS_LOG"
+  exit 1
+fi
+rm -f "$HEADERS_LOG"
+msg_success "Kernel headers installed"
+
+if pacman -Q looking-glass looking-glass-module-dkms &>/dev/null; then
+  msg_success "Looking Glass packages already installed"
+else
+  msg_info "Installing packages (looking-glass, looking-glass-module-dkms)..."
+  echo "   This may take a few minutes (downloading and compiling)..."
+
+  LG_LOG_FILE="/tmp/looking-glass-install-$$.log"
+
+  # Run yay in background, capture output to log
+  yay -S --noconfirm --needed --removemake --answerdiff=None --cleanafter looking-glass looking-glass-module-dkms > "$LG_LOG_FILE" 2>&1 &
+  LG_YAY_PID=$!
+
+  # Spinner while building
+  LG_SPINNER=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
+  LG_SPIN_IDX=0
+  while kill -0 $LG_YAY_PID 2>/dev/null; do
+    printf "\r  Building... %s " "${LG_SPINNER[$LG_SPIN_IDX]}"
+    LG_SPIN_IDX=$(( (LG_SPIN_IDX+1) % ${#LG_SPINNER[@]} ))
+    sleep 0.1
+  done
+  printf "\r                    \r"
+
+  wait $LG_YAY_PID
+  LG_EXIT_CODE=$?
+
+  if [[ $LG_EXIT_CODE -ne 0 ]]; then
+    echo ""
+    msg_error "Failed to install Looking Glass packages"
+    echo ""
+    echo "Last 30 lines of build log:"
+    echo "─────────────────────────────────────────"
+    tail -30 "$LG_LOG_FILE"
+    echo "─────────────────────────────────────────"
+    echo ""
+    echo "Full log: $LG_LOG_FILE"
+    exit 1
+  fi
+
+  rm -f "$LG_LOG_FILE"
+  msg_success "Packages installed"
+fi
+
+# Verify DKMS actually built the module (always check, even if packages were pre-installed)
+msg_info "Verifying DKMS module build..."
+dkms_status=$(dkms status 2>/dev/null | grep -i looking-glass || echo "")
+
+if [[ -z "$dkms_status" ]]; then
+  msg_error "DKMS module not found!"
+  echo "   The package is installed but DKMS failed to build the kernel module."
+  echo ""
+  echo "   Common causes:"
+  echo "   - Kernel headers not installed for current kernel"
+  echo "   - Non-standard kernel without DKMS support"
+  echo "   - Secure Boot blocking unsigned modules"
+  echo ""
+  echo "   Check: dkms status"
+  echo "   Check: pacman -Q linux-headers (or linux-zen-headers, etc.)"
+  exit 1
+fi
+
+if ! echo "$dkms_status" | grep -qi "installed"; then
+  msg_warning "DKMS module may not be properly installed"
+  echo "   Status: $dkms_status"
+else
+  msg_success "DKMS module built: $dkms_status"
+fi
+
+# Verify module file exists
+if ! modinfo kvmfr &>/dev/null; then
+  msg_error "kvmfr module file not found!"
+  echo "   DKMS reported success but module file doesn't exist."
+  echo "   This may indicate a kernel mismatch."
+  echo ""
+  echo "   Your kernel: $(uname -r)"
+  echo "   Installed headers: $(pacman -Q linux-headers 2>/dev/null || echo "not found")"
+  echo ""
+  echo "   Make sure kernel and headers match, then reinstall."
+  exit 1
+fi
+
+# Configure udev rules
+msg_info "Configuring udev rules..."
+sudo tee /etc/udev/rules.d/99-kvmfr.rules >/dev/null <<'EOF'
+SUBSYSTEM=="kvmfr", OWNER="root", GROUP="kvm", MODE="0660"
+EOF
+
+if ! sudo udevadm control --reload-rules 2>/dev/null; then
+  msg_warning "Failed to reload udev rules (non-fatal)"
+fi
+
+if ! sudo udevadm trigger 2>/dev/null; then
+  msg_warning "Failed to trigger udev (non-fatal)"
+fi
+
+msg_success "Udev rules configured"
+
+IVSHMEM_SIZE_FROM_ENV="${IVSHMEM_SIZE:-}"
+
+if [[ "${FORCE_RECONFIGURE:-0}" != "1" ]] && [[ -f /etc/modprobe.d/kvmfr.conf ]]; then
+  IVSHMEM_SIZE=$(grep -oP 'static_size_mb=\K\d+' /etc/modprobe.d/kvmfr.conf 2>/dev/null || echo "")
+  if [[ -n "$IVSHMEM_SIZE" ]]; then
+    msg_success "Kernel module already configured (${IVSHMEM_SIZE}MB)"
+  else
+    sudo rm -f /etc/modprobe.d/kvmfr.conf
+    IVSHMEM_SIZE=""
+  fi
+fi
+
+if [[ -n "$IVSHMEM_SIZE_FROM_ENV" ]]; then
+  IVSHMEM_SIZE="$IVSHMEM_SIZE_FROM_ENV"
+  msg_success "Using ${IVSHMEM_SIZE}MB shared memory (from VM config)"
+
+  # Update kvmfr.conf if size differs from current
+  current_size=$(grep -oP 'static_size_mb=\K\d+' /etc/modprobe.d/kvmfr.conf 2>/dev/null || echo "0")
+  if [[ "$current_size" != "$IVSHMEM_SIZE" ]]; then
+    msg_info "Updating kernel module configuration (${current_size}MB → ${IVSHMEM_SIZE}MB)..."
+    sudo tee /etc/modprobe.d/kvmfr.conf >/dev/null <<EOF
+options kvmfr static_size_mb=$IVSHMEM_SIZE
+EOF
+  fi
+fi
+
+if [[ -z "$IVSHMEM_SIZE" ]] || { [[ "${FORCE_RECONFIGURE:-0}" == "1" ]] && [[ -z "$IVSHMEM_SIZE_FROM_ENV" ]]; }; then
+  # Check available RAM before selection
+  available_ram_mb=$(free -m | awk '/^Mem:/{print $7}')
+  if [[ "$available_ram_mb" -lt 512 ]]; then
+    echo ""
+    msg_warning "Low available RAM: ${available_ram_mb}MB"
+    echo "  IVSHMEM uses system RAM. Consider smaller size (32MB) or close applications."
+  fi
+
+  echo ""
+  echo "Select Looking Glass shared memory size:"
+  echo ""
+  echo "  Resolution     Minimum   Recommended"
+  echo "  1920×1080      32 MB     64 MB"
+  echo "  2560×1440      64 MB     128 MB"
+  echo "  3840×2160      128 MB    256 MB"
+  echo ""
+  echo "  Higher refresh rate (144Hz+) needs more memory."
+  echo ""
+
+  RESOLUTION_CHOICE=$(gum choose --selected="1080p (64MB) - recommended" \
+    "1080p (32MB) - minimal, low RAM" \
+    "1080p (64MB) - recommended" \
+    "1440p (128MB)" \
+    "4K (256MB)")
+
+  if [[ -z "$RESOLUTION_CHOICE" ]]; then
+    echo ""
+    echo "Installation cancelled by user"
+    exit 1
+  fi
+
+  case "$RESOLUTION_CHOICE" in
+  *32MB*)
+    IVSHMEM_SIZE=32
+    RES_DISPLAY="1080p (minimal)"
+    ;;
+  *64MB*)
+    IVSHMEM_SIZE=64
+    RES_DISPLAY="1080p"
+    ;;
+  *128MB*)
+    IVSHMEM_SIZE=128
+    RES_DISPLAY="1440p"
+    ;;
+  *256MB*)
+    IVSHMEM_SIZE=256
+    RES_DISPLAY="4K"
+    ;;
+  *)
+    IVSHMEM_SIZE=64
+    RES_DISPLAY="1080p"
+    ;;
+  esac
+
+  msg_success "Allocated ${IVSHMEM_SIZE}MB shared memory (sufficient for ${RES_DISPLAY} displays)"
+
+  if ! [[ "$IVSHMEM_SIZE" =~ ^[0-9]+$ ]] || [[ "$IVSHMEM_SIZE" -lt 32 ]] || [[ "$IVSHMEM_SIZE" -gt 512 ]]; then
+    msg_error "Invalid IVSHMEM_SIZE: $IVSHMEM_SIZE (must be 32-512)"
+    exit 1
+  fi
+
+  msg_info "Writing kernel module configuration..."
+  sudo tee /etc/modprobe.d/kvmfr.conf >/dev/null <<EOF
+options kvmfr static_size_mb=$IVSHMEM_SIZE
+EOF
+fi
+
+if [[ ! -f /etc/modules-load.d/kvmfr.conf ]]; then
+  msg_info "Configuring kernel module auto-load..."
+  echo "kvmfr" | sudo tee /etc/modules-load.d/kvmfr.conf >/dev/null
+  msg_success "Kernel module auto-load configured"
+fi
+
+# Add user to kvm group
+msg_info "Checking kvm group..."
+ADDED_TO_KVM=false
+if ! groups "$USER" | grep -q kvm; then
+  sudo usermod -aG kvm "$USER"
+  msg_success "Added to kvm group"
+  echo ""
+  msg_info "Refreshing group membership for current session..."
+  echo ""
+  exec sg kvm "$0" "${ORIGINAL_SCRIPT_ARGS[@]}"
+else
+  msg_success "Already in kvm group"
+fi
+
+LG_CONFIG="$HOME/.config/looking-glass/client.ini"
+ESCAPE_KEY_FROM_ENV="${ESCAPE_KEY:-}"
+ESCAPE_KEY=""
+ESCAPE_KEY_SOURCE=""
+
+# Check env override (highest priority)
+if [[ -n "$ESCAPE_KEY_FROM_ENV" ]]; then
+  ESCAPE_KEY="$ESCAPE_KEY_FROM_ENV"
+  ESCAPE_KEY_SOURCE="env"
+# Check existing config (if not forcing reconfigure)
+elif [[ "${FORCE_RECONFIGURE:-0}" != "1" ]] && [[ -f "$LG_CONFIG" ]]; then
+  ESCAPE_KEY=$(grep '^escapeKey=' "$LG_CONFIG" 2>/dev/null | cut -d= -f2 | head -1)
+  [[ -n "$ESCAPE_KEY" ]] && ESCAPE_KEY_SOURCE="existing config"
+fi
+
+# Prompt user if no key set
+if [[ -z "$ESCAPE_KEY" ]]; then
+  IS_LAPTOP=false
+  for bat in /sys/class/power_supply/BAT*; do
+    [[ -d "$bat" ]] && IS_LAPTOP=true && break
+  done
+
+  if [[ "$IS_LAPTOP" == true ]]; then
+    DEFAULT_KEY="KEY_RIGHTCTRL"
+    DEFAULT_DESC="Right Ctrl (recommended for laptops)"
+  else
+    DEFAULT_KEY="KEY_SCROLLLOCK"
+    DEFAULT_DESC="Scroll Lock (default)"
+  fi
+
+  echo ""
+  echo "Select Looking Glass capture toggle key:"
+  echo "  Press this key to toggle mouse/keyboard capture."
+  echo "  When captured: mouse stays inside VM."
+  echo "  Press again to release and use host desktop."
+  echo ""
+
+  ESCAPE_CHOICE=$(gum choose --selected="$DEFAULT_DESC" \
+    "Scroll Lock (default)" \
+    "Right Ctrl (recommended for laptops)" \
+    "Right Alt" \
+    "Pause" \
+    "Insert")
+
+  if [[ -z "$ESCAPE_CHOICE" ]]; then
+    echo ""
+    echo "Installation cancelled by user"
+    exit 1
+  fi
+
+  case "$ESCAPE_CHOICE" in
+    *"Scroll Lock"*)  ESCAPE_KEY="KEY_SCROLLLOCK" ;;
+    *"Right Ctrl"*)   ESCAPE_KEY="KEY_RIGHTCTRL" ;;
+    *"Right Alt"*)    ESCAPE_KEY="KEY_RIGHTALT" ;;
+    *"Pause"*)        ESCAPE_KEY="KEY_PAUSE" ;;
+    *"Insert"*)       ESCAPE_KEY="KEY_INSERT" ;;
+    *)                ESCAPE_KEY="$DEFAULT_KEY" ;;
+  esac
+fi
+
+if [[ -n "$ESCAPE_KEY_SOURCE" ]]; then
+  msg_success "Capture toggle key: $(format_escape_key_name "$ESCAPE_KEY") (from $ESCAPE_KEY_SOURCE)"
+else
+  msg_success "Capture toggle key: $(format_escape_key_name "$ESCAPE_KEY")"
+fi
+
+# Create client configuration
+if [[ "$ESCAPE_KEY_SOURCE" == "existing config" ]]; then
+  msg_success "Using existing configuration (preserved)"
+else
+  msg_info "Creating client configuration..."
+  mkdir -p "$HOME/.config/looking-glass"
+  cat >"$LG_CONFIG" <<EOF
+[app]
+shmFile=/dev/kvmfr0
+
+[input]
+rawMouse=yes
+autoCapture=no
+captureOnly=no
+escapeKey=$ESCAPE_KEY
+grabKeyboard=yes
+captureOnFocus=no
+
+[win]
+fullScreen=no
+borderless=no
+
+[spice]
+enable=yes
+host=$SPICE_SOCKET_PATH
+port=0
+input=yes
+audio=yes
+clipboard=yes
+clipboardToVM=yes
+clipboardToLocal=yes
+
+[audio]
+periodSize=256
+bufferLatency=5
+micDefault=allow
+micShowIndicator=no
+EOF
+  msg_success "Configuration created with SPICE support ($LG_CONFIG)"
+fi
+
+create_tmpfiles_config
+create_sudoers_config
+
+msg_info "Installing desktop launcher..."
+mkdir -p "$HOME/.local/share/applications"
+
+cat >"$HOME/.local/share/applications/windows-looking-glass.desktop" <<DESKEOF
+[Desktop Entry]
+Name=Windows [Looking Glass]
+Comment=Connect to Windows VM via Looking Glass (ultra-low latency)
+Exec=uwsm-app -- omarchy-windows-vm launch --lg
+Icon=$HOME/.local/share/applications/icons/windows.png
+Terminal=false
+Type=Application
+Categories=System;Virtualization;
+DESKEOF
+msg_success "Desktop launcher installed"
+
+msg_info "Loading kvmfr module..."
+if lsmod | grep -q kvmfr; then
+  if [[ ! -e /dev/kvmfr0 ]]; then
+    echo "Module loaded but /dev/kvmfr0 missing - reloading with new config..."
+    sudo -n rmmod kvmfr 2>/dev/null || true
+    if sudo -n modprobe kvmfr static_size_mb="$IVSHMEM_SIZE" 2>/dev/null; then
+      udevadm settle --timeout=5 2>/dev/null || sleep 1
+      msg_success "Module reloaded"
+    else
+      msg_warning "Module reload failed (reboot required)"
+    fi
+  else
+    module_size=$(cat /sys/module/kvmfr/parameters/static_size_mb 2>/dev/null || echo "0")
+    if [[ "$module_size" != "$IVSHMEM_SIZE" ]]; then
+      echo "Module loaded with wrong size (${module_size}MB, expected ${IVSHMEM_SIZE}MB) - reloading..."
+      sudo -n rmmod kvmfr 2>/dev/null || true
+      if sudo -n modprobe kvmfr static_size_mb="$IVSHMEM_SIZE" 2>/dev/null; then
+        udevadm settle --timeout=5 2>/dev/null || sleep 1
+        msg_success "Module reloaded with ${IVSHMEM_SIZE}MB"
+      else
+        msg_warning "Module reload failed (reboot required)"
+      fi
+    else
+      msg_success "Module already loaded (${IVSHMEM_SIZE}MB)"
+    fi
+  fi
+else
+  if sudo -n modprobe kvmfr static_size_mb="$IVSHMEM_SIZE" 2>/dev/null; then
+    # Wait for udev to create /dev/kvmfr0
+    udevadm settle --timeout=5 2>/dev/null || sleep 1
+    msg_success "Module loaded"
+  else
+    msg_warning "Module load failed"
+    # Check if Secure Boot might be the cause
+    if command -v mokutil &>/dev/null; then
+      if mokutil --sb-state 2>/dev/null | grep -qi "enabled"; then
+        echo "   Secure Boot is enabled - this may block unsigned modules!"
+        echo "   Either disable Secure Boot in BIOS or sign the module."
+      else
+        echo "   Try rebooting, or check: dmesg | grep -i kvmfr"
+      fi
+    else
+      echo "   Try rebooting, or check: dmesg | grep -i kvmfr"
+    fi
+  fi
+fi
+
+# Check device readability (kvm group membership may need re-login)
+if [[ -e /dev/kvmfr0 ]] && [[ ! -r /dev/kvmfr0 ]]; then
+  msg_warning "Device /dev/kvmfr0 exists but not readable by $USER"
+  echo "  This will be fixed after re-login or reboot (kvm group membership)"
+fi
+
+echo ""
+echo "Installation complete!"
+echo ""
+echo "Capture toggle key: $(format_escape_key_name "$ESCAPE_KEY")"
+echo "  To change, edit: ~/.config/looking-glass/client.ini"
+echo "  Set escapeKey= to: KEY_SCROLLLOCK, KEY_RIGHTCTRL, KEY_RIGHTALT, KEY_PAUSE, KEY_INSERT"
+echo ""
+
+NEEDS_REBOOT=false
+REBOOT_REASONS=""
+
+if ! lsmod | grep -q kvmfr || [[ ! -e /dev/kvmfr0 ]]; then
+  NEEDS_REBOOT=true
+  REBOOT_REASONS="  - Kernel module not active"$'\n'"$REBOOT_REASONS"
+fi
+
+if [[ "$NEEDS_REBOOT" == true ]]; then
+  msg_warning "Reboot required for:"
+  echo "$REBOOT_REASONS"
+  echo ""
+  echo "After reboot, enable Looking Glass during Windows VM installation:"
+  echo "   omarchy-windows-vm install"
+  echo ""
+else
+  msg_success "Looking Glass client ready!"
+  echo ""
+  echo "Next step: Install Windows VM with Looking Glass support"
+  echo "   omarchy-windows-vm install"
+  echo "   (Select 'Yes' when asked about Looking Glass)"
+  echo ""
+fi
diff --git a/bin/omarchy-looking-glass-launch b/bin/omarchy-looking-glass-launch
new file mode 100755
index 0000000000..aa9170e365
--- /dev/null
+++ b/bin/omarchy-looking-glass-launch
@@ -0,0 +1,274 @@
+#!/bin/bash
+# omarchy-looking-glass-launch - Launch Looking Glass client for VM display
+
+# Preserve original script arguments for exec sg kvm (group refresh)
+ORIGINAL_SCRIPT_ARGS=("$@")
+
+SPICE_DIR="/var/run/omarchy-windows"      # SPICE socket directory (tmpfs, auto-cleaned on reboot)
+SPICE_SOCKET_PATH="$SPICE_DIR/spice.sock" # SPICE Unix socket
+
+msg_error() {
+  echo "❌  Error: $*" >&2
+}
+
+msg_warning() {
+  echo "⚠️  Warning: $*" >&2
+}
+
+msg_success() {
+  echo "✓  $*"
+}
+
+msg_info() {
+  echo "ℹ️  $*"
+}
+
+get_escape_key_display() {
+  local lg_config="$HOME/.config/looking-glass/client.ini"
+  local escape_key="Scroll Lock"
+
+  if [[ -f "$lg_config" ]]; then
+    local raw_key=$(grep -E '^\s*escapeKey\s*=' "$lg_config" 2>/dev/null | sed 's/^.*=\s*//' | tr -d ' "')
+    case "$raw_key" in
+      KEY_SCROLLLOCK) escape_key="Scroll Lock" ;;
+      KEY_RIGHTCTRL)  escape_key="Right Ctrl" ;;
+      KEY_LEFTCTRL)   escape_key="Left Ctrl" ;;
+      KEY_RIGHTALT)   escape_key="Right Alt" ;;
+      KEY_PAUSE)      escape_key="Pause" ;;
+      KEY_INSERT)     escape_key="Insert" ;;
+      "") ;;  # No key set, use default
+      *) escape_key="${raw_key#KEY_}" ;;  # Strip KEY_ prefix for unknown keys
+    esac
+  fi
+
+  echo "$escape_key"
+}
+
+ensure_user_in_kvm_group() {
+  if groups "$USER" | grep -q kvm; then
+    return 0
+  fi
+
+  if sudo -n usermod -aG kvm "$USER" 2>/dev/null; then
+    return 1
+  else
+    return 2
+  fi
+}
+
+diagnose_kvmfr_issue() {
+  echo ""
+  echo "Diagnosing kvmfr module issue..."
+  echo ""
+
+  # Kernel info
+  local kernel_ver kernel_pkg
+  kernel_ver=$(uname -r)
+  kernel_pkg=$(pacman -Qo "/lib/modules/$kernel_ver" 2>/dev/null | awk '{print $5}' || echo "unknown")
+  echo "  Kernel: $kernel_ver ($kernel_pkg)"
+
+  # Kernel headers
+  local headers_pkg="${kernel_pkg}-headers"
+  if pacman -Q "$headers_pkg" &>/dev/null; then
+    echo "  Headers: $headers_pkg installed"
+  else
+    echo "  Headers: $headers_pkg NOT installed"
+    echo "   Reinstall: omarchy-looking-glass-install"
+  fi
+
+  # DKMS status
+  if command -v dkms &>/dev/null; then
+    local dkms_status
+    dkms_status=$(dkms status 2>/dev/null | grep -i looking-glass || echo "")
+    if [[ -n "$dkms_status" ]]; then
+      echo "  DKMS: $dkms_status"
+    else
+      echo "  DKMS: looking-glass NOT found"
+      echo "   Reinstall: omarchy-looking-glass-install"
+    fi
+  else
+    echo "  DKMS: not installed"
+  fi
+
+  # Module file
+  if modinfo kvmfr &>/dev/null; then
+    echo "  Module: Found"
+  else
+    echo "  Module: NOT found (DKMS build failed?)"
+  fi
+
+  # Secure Boot
+  if command -v mokutil &>/dev/null; then
+    local sb_state
+    sb_state=$(mokutil --sb-state 2>/dev/null || echo "unknown")
+    if echo "$sb_state" | grep -qi "enabled"; then
+      echo "  Secure Boot: ENABLED (may block unsigned modules)"
+      echo "   Disable Secure Boot in BIOS, or sign the module"
+    else
+      echo "  Secure Boot: Disabled"
+    fi
+  fi
+
+  # Config files
+  if [[ -f /etc/modprobe.d/kvmfr.conf ]]; then
+    local ivshmem_size
+    ivshmem_size=$(grep -oP 'static_size_mb=\K\d+' /etc/modprobe.d/kvmfr.conf 2>/dev/null || echo "?")
+    echo "  Module config: Found (${ivshmem_size}MB)"
+  else
+    echo "  Module config: MISSING"
+  fi
+
+  if [[ -f /etc/modules-load.d/kvmfr.conf ]]; then
+    echo "  Auto-load: Enabled"
+  else
+    echo "  Auto-load: NOT configured"
+  fi
+
+  # Udev rules
+  if [[ -f /etc/udev/rules.d/99-kvmfr.rules ]]; then
+    echo "  Udev rules: Found"
+  else
+    echo "  Udev rules: MISSING"
+    echo "   Reinstall: omarchy-looking-glass-install"
+  fi
+
+  # User in kvm group
+  if groups "$USER" 2>/dev/null | grep -q '\bkvm\b'; then
+    echo "  KVM group: $USER is member"
+  else
+    echo "  KVM group: $USER NOT in kvm group"
+    echo "   Reinstall: omarchy-looking-glass-install"
+  fi
+
+  # Kernel log (use sudo if available for full access)
+  local dmesg_errors
+  if sudo -n dmesg &>/dev/null; then
+    dmesg_errors=$(sudo -n dmesg 2>/dev/null | grep -i kvmfr | tail -5 || echo "")
+  else
+    dmesg_errors=$(dmesg 2>/dev/null | grep -i kvmfr | tail -5 || echo "")
+  fi
+  if [[ -n "$dmesg_errors" ]]; then
+    echo "  Kernel log:"
+    echo "$dmesg_errors" | while read -r line; do
+      echo "   $line"
+    done
+  else
+    echo "  Kernel log: No kvmfr messages"
+  fi
+
+  echo ""
+}
+
+check_docker_running() {
+  if docker ps &>/dev/null; then
+    return 0
+  fi
+
+  msg_error "Docker is not running"
+  echo "   Start: sudo systemctl start docker"
+  return 1
+}
+
+get_container_status() {
+  local container_name="${1:-omarchy-windows}"
+  docker inspect --format='{{.State.Status}}' "$container_name" 2>/dev/null
+}
+
+if ! command -v looking-glass-client &>/dev/null; then
+  msg_error "Looking Glass is not installed"
+  echo "   Install: omarchy-looking-glass-install"
+  exit 1
+fi
+
+if ! lsmod | grep -q kvmfr; then
+  msg_warning "kvmfr module not loaded, attempting to load..."
+  if timeout 10 sudo -n /usr/bin/modprobe kvmfr 2>/dev/null; then
+    msg_success "Module loaded successfully"
+    sleep 1
+  else
+    msg_error "Failed to load kvmfr module"
+    diagnose_kvmfr_issue
+    exit 1
+  fi
+fi
+
+if [[ ! -e /dev/kvmfr0 ]]; then
+  msg_error "/dev/kvmfr0 device not found!"
+  diagnose_kvmfr_issue
+  exit 1
+fi
+
+if [[ ! -r /dev/kvmfr0 ]]; then
+  msg_error "Cannot read /dev/kvmfr0"
+
+  ensure_user_in_kvm_group
+  case "$?" in
+  1)
+    msg_success "Added to kvm group"
+    msg_info "Refreshing group membership for current session..."
+    exec sg kvm "$0" "${ORIGINAL_SCRIPT_ARGS[@]}"
+    ;;
+  0)
+    echo "   You are in the 'kvm' group but still cannot read the device."
+    echo "   This usually means your session hasn't refreshed the group membership yet."
+    msg_info "Refreshing group membership for current session..."
+    exec sg kvm "$0" "${ORIGINAL_SCRIPT_ARGS[@]}"
+    ;;
+  2)
+    msg_error "Failed to add user to kvm group"
+    exit 1
+    ;;
+  esac
+fi
+
+COMPOSE_FILE="$HOME/.config/windows/docker-compose.yml"
+if [[ ! -f "$COMPOSE_FILE" ]]; then
+  msg_error "Windows VM not configured"
+  echo "   Run: omarchy-windows-vm install"
+  exit 1
+fi
+
+if ! grep -q "ivshmem-plain" "$COMPOSE_FILE"; then
+  msg_error "Windows VM is not configured with Looking Glass support!"
+  echo "   Your VM was installed without IVSHMEM device."
+  echo "   To enable Looking Glass, you need to reinstall:"
+  echo "     omarchy-windows-vm remove"
+  echo "     omarchy-windows-vm install"
+  echo "   During installation, select 'Yes' when asked about Looking Glass."
+  echo "   Alternatively, connect via RDP:"
+  echo "     omarchy-windows-vm launch"
+  exit 1
+fi
+
+if ! check_docker_running; then
+  exit 1
+fi
+
+CONTAINER_STATUS=$(get_container_status "omarchy-windows")
+if [[ "$CONTAINER_STATUS" != "running" ]]; then
+  msg_error "Windows VM is not running"
+  echo "   Start: omarchy-windows-vm launch --keep-alive"
+  exit 1
+fi
+
+if [[ ! -S "$SPICE_SOCKET_PATH" ]]; then
+  msg_warning "SPICE socket not found: $SPICE_SOCKET_PATH"
+  echo "   VM may still be starting, or SPICE is not configured correctly."
+  echo "   Looking Glass will launch without audio/clipboard integration."
+fi
+
+escape_key=$(get_escape_key_display)
+echo "Connecting to Windows VM via Looking Glass..."
+echo "$escape_key: release | $escape_key + F: fullscreen | $escape_key + Q: quit"
+
+if [[ -S "$SPICE_SOCKET_PATH" ]] && [[ ! -r "$SPICE_SOCKET_PATH" ]]; then
+  msg_info "Fixing SPICE socket permissions..."
+  sudo -n chmod 660 "$SPICE_SOCKET_PATH" 2>/dev/null || true
+  sudo -n chgrp kvm "$SPICE_SOCKET_PATH" 2>/dev/null || true
+fi
+
+if [[ "$#" -eq 0 ]]; then
+  exec setsid uwsm-app -- looking-glass-client -F
+else
+  exec setsid uwsm-app -- looking-glass-client "$@"
+fi
diff --git a/bin/omarchy-snapshot b/bin/omarchy-snapshot
index ee79512a7c..553c2e2da7 100755
--- a/bin/omarchy-snapshot
+++ b/bin/omarchy-snapshot
@@ -3,10 +3,15 @@
 set -e
 
 COMMAND="$1"
+DESCRIPTION="${2:-}"  # Optional custom description
 OMARCHY_PATH=${OMARCHY_PATH:-$HOME/.local/share/omarchy}
 
 if [[ -z $COMMAND ]]; then
-  echo "Usage: omarchy-snapshot <create|restore>" >&2
+  echo "Usage: omarchy-snapshot <create|restore> [description]" >&2
+  echo "" >&2
+  echo "Examples:" >&2
+  echo "  omarchy-snapshot create                    # Uses omarchy version as description" >&2
+  echo "  omarchy-snapshot create \"GPU Passthrough\"  # Custom description" >&2
   exit 1
 fi
 
@@ -16,7 +21,12 @@ fi
 
 case "$COMMAND" in
 create)
-  DESC="$(omarchy-version)"
+  # Use custom description if provided, otherwise use omarchy version
+  if [[ -n "$DESCRIPTION" ]]; then
+    DESC="$DESCRIPTION"
+  else
+    DESC="$(omarchy-version)"
+  fi
 
   echo -e "\e[32mCreate system snapshot\e[0m"
 
diff --git a/bin/omarchy-windows-vm b/bin/omarchy-windows-vm
index 3ef9eb1102..1deb971d68 100755
--- a/bin/omarchy-windows-vm
+++ b/bin/omarchy-windows-vm
@@ -1,383 +1,3820 @@
 #!/bin/bash
+
+# Get script directory for accessing resources (icons, etc.)
+SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
+
 COMPOSE_FILE="$HOME/.config/windows/docker-compose.yml"
+DOCKER_IMAGE="dockurr/windows:latest"
+SPICE_DIR="/var/run/omarchy-windows"      # SPICE socket directory (tmpfs, auto-cleaned on reboot)
+SPICE_SOCKET_PATH="$SPICE_DIR/spice.sock" # SPICE Unix socket from dockurr/windows container
+
+msg_error() {
+  echo "❌  Error: $*" >&2
+}
+
+msg_warning() {
+  echo "⚠️  Warning: $*" >&2
+}
+
+msg_success() {
+  echo "✓  $*"
+}
+
+msg_info() {
+  echo "ℹ️  $*"
+}
+
+notify_silent() {
+  local title="$1"
+  local message="$2"
+  local urgency="${3:-normal}"
+
+  if command -v notify-send &>/dev/null; then
+    notify-send -u "$urgency" -- "$title" "$message" 2>/dev/null || true
+  fi
+}
+
+run_with_spinner() {
+  local message="$1"
+  shift
+  local spinner=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
+  local spin_idx=0
+
+  "$@" &
+  local pid=$!
+
+  while kill -0 $pid 2>/dev/null; do
+    printf "\r%s %s " "$message" "${spinner[$spin_idx]}"
+    spin_idx=$(( (spin_idx + 1) % ${#spinner[@]} ))
+    sleep 0.1
+  done
+
+  wait $pid
+  local exit_code=$?
+  printf "\r%s   \r" "$message"
+  return $exit_code
+}
+
+# Returns: 0=already in group, 1=added (relogin needed), 2=failed
+ensure_user_in_kvm_group() {
+  if groups "$USER" | grep -q kvm; then
+    return 0
+  fi
+
+  # Use -n to avoid blocking in background processes
+  if sudo -n usermod -aG kvm "$USER" 2>/dev/null; then
+    return 1
+  else
+    return 2
+  fi
+}
+
+is_looking_glass_ready() {
+  command -v looking-glass-client &>/dev/null &&
+    lsmod | grep -q kvmfr &&
+    [[ -e /dev/kvmfr0 ]]
+}
+
+get_escape_key_display() {
+  local lg_config="$HOME/.config/looking-glass/client.ini"
+  local escape_key="Scroll Lock"
+
+  if [[ -f "$lg_config" ]]; then
+    local raw_key=$(grep -E '^\s*escapeKey\s*=' "$lg_config" 2>/dev/null | sed 's/^.*=\s*//' | tr -d ' "')
+    case "$raw_key" in
+      KEY_SCROLLLOCK) escape_key="Scroll Lock" ;;
+      KEY_RIGHTCTRL)  escape_key="Right Ctrl" ;;
+      KEY_LEFTCTRL)   escape_key="Left Ctrl" ;;
+      KEY_RIGHTALT)   escape_key="Right Alt" ;;
+      KEY_PAUSE)      escape_key="Pause" ;;
+      KEY_INSERT)     escape_key="Insert" ;;
+      "") ;;  # No key set, use default
+      *) escape_key="${raw_key#KEY_}" ;;  # Strip KEY_ prefix for unknown keys
+    esac
+  fi
+
+  echo "$escape_key"
+}
+
+check_docker_running() {
+  if docker ps &>/dev/null; then
+    return 0
+  fi
+
+  msg_error "Docker is not running"
+  echo "   Start: sudo systemctl start docker"
+  exit 1
+}
+
+# Get container status by name
+get_container_status() {
+  local container_name="${1:-omarchy-windows}"
+  docker inspect --format='{{.State.Status}}' "$container_name" 2>/dev/null
+}
+
+get_rdp_scale() {
+  command -v jq &>/dev/null || return
+  local hypr_scale=$(hyprctl monitors -j 2>/dev/null | jq -r '.[] | select (.focused == true) | .scale' 2>/dev/null)
+  [[ -z "$hypr_scale" ]] && return
+
+  local scale_percent=$(echo "$hypr_scale" | awk '{print int($1 * 100)}')
+  [[ "$scale_percent" =~ ^[0-9]+$ ]] || return
+
+  [[ "$scale_percent" -ge 170 ]] && echo "/scale:180" && return
+  [[ "$scale_percent" -ge 130 ]] && echo "/scale:140"
+}
+
+test_rdp_ready() {
+  local -r X224_CR="\x03\x00\x00\x13\x0e\xe0\x00\x00\x00\x00\x00\x01\x00\x08\x00\x03\x00\x00\x00"
+
+  printf '%b' "$X224_CR" | timeout 2 nc -w2 127.0.0.1 3389 2>/dev/null |
+    head -c2 | od -An -tx1 | tr -d ' \n' | grep -q "^0300$"
+}
+
+# Check and warn about GPU IOTLB errors (AMD reset bug)
+warn_if_gpu_iotlb_error() {
+  if command -v omarchy-gpu-passthrough-info &>/dev/null; then
+    if omarchy-gpu-passthrough-info gpu-health &>/dev/null; then
+      msg_warning "GPU Health: IOTLB_INV_TIMEOUT detected"
+      echo "   The GPU may need a cold boot (poweroff + unplug power 30s)"
+      echo "   Details: omarchy-gpu-passthrough-info health"
+    fi
+  fi
+}
+
+convert_to_crlf() {
+  local file="$1"
+  [[ ! -f "$file" ]] && {
+    msg_error "File not found: $file"
+    return 1
+  }
+
+  sed -i -e 's/\r$//' -e 's/$/\r/' "$file" || return 1
+}
+
+# Connect to Windows VM via RDP
+# Parameters:
+#   $1 - USERNAME
+#   $2 - PASSWORD
+#   $3 - BACKGROUND: true (detached) or false (foreground) - default: false
+connect_rdp() {
+  local USERNAME="$1"
+  local PASSWORD="$2"
+  local BACKGROUND="${3:-false}"
+
+  local RDP_SCALE=$(get_rdp_scale)
+
+  if ! command -v xfreerdp3 &>/dev/null; then
+    echo ""
+    msg_warning "xfreerdp3 not found - cannot launch RDP"
+    echo "   Install freerdp: omarchy-pkg-add freerdp"
+    echo "   Or manually connect via VNC: http://127.0.0.1:8006"
+    echo ""
+    if [[ "$BACKGROUND" == true ]]; then
+      echo "Windows VM is running in background."
+      echo "After installing freerdp, connect with: omarchy-windows-vm launch"
+    fi
+    return 1
+  fi
+
+  local RDP_ARGS=(
+    /u:"$USERNAME"
+    /p:"$PASSWORD"
+    /v:127.0.0.1:3389
+    -grab-keyboard
+    /sound
+    /microphone
+    /cert:ignore
+    /title:"Windows VM - Omarchy"
+    /dynamic-resolution
+    /gfx:AVC444
+    /floatbar:sticky:off,default:visible,show:fullscreen
+  )
+  [[ -n "$RDP_SCALE" ]] && RDP_ARGS+=("$RDP_SCALE")
+
+  if [[ "$BACKGROUND" == true ]]; then
+    # Background mode: User can close terminal and keep using Windows
+    setsid uwsm-app -- xfreerdp3 "${RDP_ARGS[@]}" >/dev/null 2>&1 &
+
+    echo ""
+    msg_success "RDP window opened in background"
+    echo "   You can close this terminal/browser and keep using Windows"
+    echo ""
+  else
+    # Foreground mode: Wait for RDP to close (for --keep-alive logic)
+    # Note: Keyboard shortcuts are printed by launch_windows() before calling connect_rdp()
+    local MAX_RETRIES=3
+    local ATTEMPT=1
+
+    while [[ $ATTEMPT -le $MAX_RETRIES ]]; do
+      setsid xfreerdp3 "${RDP_ARGS[@]}" >/dev/null 2>&1 &
+      local RDP_PID=$!
+      local START_TIME=$(date +%s)
+
+      wait $RDP_PID
+      local RDP_EXIT=$?
+      local END_TIME=$(date +%s)
+      local ELAPSED=$((END_TIME - START_TIME))
+
+      # If RDP session lasted more than 3 seconds, consider it a real session (user closed it)
+      # If it failed quickly (<3s) with error, it was likely a connection failure - retry
+      if [[ $ELAPSED -gt 3 ]] || [[ $RDP_EXIT -eq 0 ]]; then
+        return $RDP_EXIT
+      fi
+
+      ATTEMPT=$((ATTEMPT + 1))
+      if [[ $ATTEMPT -le $MAX_RETRIES ]]; then
+        echo "RDP connection failed, waiting for Windows to be ready... (attempt $ATTEMPT/$MAX_RETRIES)"
+
+        # Wait for RDP service to be ready (up to 30s per retry)
+        local WAIT_ELAPSED=0
+        local WAIT_MAX=30
+        while [[ $WAIT_ELAPSED -lt $WAIT_MAX ]]; do
+          if test_rdp_ready; then
+            echo "  RDP ready, connecting..."
+            break
+          fi
+          sleep 3
+          WAIT_ELAPSED=$((WAIT_ELAPSED + 3))
+          echo "  Waiting for RDP service... (${WAIT_ELAPSED}s)"
+        done
+      fi
+    done
+
+    echo "RDP connection failed after $MAX_RETRIES attempts"
+    return 1
+  fi
+}
+
+# Check KVM virtualization support
+check_kvm_available() {
+  if [[ ! -e /dev/kvm ]]; then
+    msg_error "KVM virtualization not available!"
+    echo ""
+    echo "   Please enable virtualization in BIOS or run:"
+    echo "     sudo modprobe kvm-intel  # for Intel CPUs"
+    echo "     sudo modprobe kvm-amd    # for AMD CPUs"
+    return 1
+  fi
+  return 0
+}
+
+check_prerequisites() {
+  local DISK_SIZE_GB=${1:-64}
+  local REQUIRED_SPACE=$((DISK_SIZE_GB + 10)) # Add 10GB for Windows ISO and overhead
+
+  if ! check_kvm_available; then
+    exit 1
+  fi
+
+  AVAILABLE_SPACE=$(df "$HOME" | awk 'NR==2 {print int($4/1024/1024)}')
+
+  if ! [[ "$AVAILABLE_SPACE" =~ ^[0-9]+$ ]] || [[ "$AVAILABLE_SPACE" -eq 0 ]]; then
+    msg_error "Failed to calculate available disk space!"
+    echo "   Could not determine space on $HOME"
+    exit 1
+  fi
+
+  if [[ "$AVAILABLE_SPACE" -lt "$REQUIRED_SPACE" ]]; then
+    msg_error "Insufficient disk space!"
+    echo "   Available: ${AVAILABLE_SPACE}GB"
+    echo "   Required: ${REQUIRED_SPACE}GB (${DISK_SIZE_GB}GB disk + 10GB for Windows image)"
+    exit 1
+  fi
+}
+
+check_vm_configured() {
+  if [[ ! -f "$COMPOSE_FILE" ]]; then
+    msg_error "Windows VM not configured"
+    echo "   Run: omarchy-windows-vm install"
+    exit 1
+  fi
+}
+
+configure_sudoers_windows_vm() {
+  local sudoers_file="/etc/sudoers.d/omarchy-windows-vm"
+
+  if sudo test -f "$sudoers_file"; then
+    return 0
+  fi
+
+  local sudoers_content="# Omarchy Windows VM - Passwordless Operations
+# Generated by omarchy-windows-vm install
+
+# System information (SMBIOS spoofing for anti-cheat)
+$USER ALL=(ALL) NOPASSWD: /usr/bin/dmidecode -s *
+$USER ALL=(ALL) NOPASSWD: /usr/bin/dmidecode -t processor
+"
+
+  local temp_file
+  temp_file=$(mktemp)
+  echo "$sudoers_content" > "$temp_file"
+
+  if ! sudo visudo -c -f "$temp_file" 2>&1 | grep -q "parsed OK"; then
+    msg_warning "Sudoers syntax validation failed - skipping"
+    rm -f "$temp_file"
+    return 1
+  fi
+
+  if sudo install -m 440 -o root -g root "$temp_file" "$sudoers_file"; then
+    rm -f "$temp_file"
+    if ! sudo visudo -c 2>&1 | grep -q "parsed OK"; then
+      msg_warning "Sudoers file issue - removing"
+      sudo rm -f "$sudoers_file"
+      return 1
+    fi
+  else
+    msg_warning "Failed to install sudoers file"
+    rm -f "$temp_file"
+    return 1
+  fi
+
+  return 0
+}
+
+install_looking_glass_client() {
+  # Returns: 0=success, 1=reboot needed, 2=failed
+  # This is a wrapper that calls the dedicated installation script
+
+  if is_looking_glass_ready; then
+    msg_success "Looking Glass already installed"
+    if [[ -f /etc/modprobe.d/kvmfr.conf ]]; then
+      IVSHMEM_SIZE=$(grep -oP 'static_size_mb=\K\d+' /etc/modprobe.d/kvmfr.conf 2>/dev/null || echo "64")
+    else
+      IVSHMEM_SIZE=64
+    fi
+    export IVSHMEM_SIZE
+    return 0
+  fi
+
+  if ! command -v omarchy-looking-glass-install &>/dev/null; then
+    msg_error "omarchy-looking-glass-install not found"
+    echo "   Make sure Omarchy scripts are in PATH"
+    return 2
+  fi
+
+  echo "Running Looking Glass installation..."
+
+  # Note: Script handles all installation steps interactively
+  # It will ask user for resolution choice (1080p/1440p/4K)
+  # FORCE_RECONFIGURE=1 allows user to change resolution on each install
+  if FORCE_RECONFIGURE=1 omarchy-looking-glass-install; then
+    if [[ -f /etc/modprobe.d/kvmfr.conf ]]; then
+      IVSHMEM_SIZE=$(grep -oP 'static_size_mb=\K\d+' /etc/modprobe.d/kvmfr.conf 2>/dev/null || echo "64")
+    else
+      IVSHMEM_SIZE=64
+    fi
+    export IVSHMEM_SIZE
+
+    if ! is_looking_glass_ready; then
+      return 1
+    fi
+    return 0
+  else
+    echo ""
+    msg_error "Looking Glass installation failed"
+    return 2
+  fi
+}
+
+create_oem_powershell_script() {
+  local OEM_DIR="$1"
+  local SCRIPT_VERSION="$2"
+
+  printf '\xEF\xBB\xBF' >"$OEM_DIR/install.ps1"
+  cat >>"$OEM_DIR/install.ps1" <<'EOFPS1'
+# Omarchy Windows VM Setup Script
+# This script runs automatically after Windows installation completes
+# Logs are saved to C:\OEM\install-log.txt for debugging
+
+$LogFile = "C:\OEM\install-log.txt"
+
+# Initialize log file (create if doesn't exist)
+try {
+    if (-not (Test-Path $LogFile)) {
+        New-Item -ItemType File -Path $LogFile -Force | Out-Null
+    }
+}
+catch {
+    # If we can't create log file, continue anyway (logs will only go to console)
+    Write-Host "WARNING: Could not create log file at $LogFile" -ForegroundColor Yellow
+}
+
+function Write-Log {
+    param([string]$Message, [string]$Color = "White")
+    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
+    $logEntry = "[$timestamp] $Message"
+    Write-Host $Message -ForegroundColor $Color
+
+    try {
+        Add-Content -Path $LogFile -Value $logEntry -Encoding UTF8 -ErrorAction Stop
+    }
+    catch {
+        # Silently continue if log write fails
+    }
+}
+
+Write-Log "=== Omarchy Windows VM Setup Script ===" "Cyan"
+Write-Log "Version: SCRIPT_VERSION_PLACEHOLDER" "Gray"
+Write-Log "Windows installation complete - running Omarchy setup..." "Green"
+Write-Log ""
+
+function Set-InstallationMarker {
+    Write-Log "Creating installation completion marker..."
+
+    try {
+        Write-Log "Mounting shared folder \\host.lan\Data as Z:..."
+        $null = net use Z: \\host.lan\Data /persistent:yes 2>&1
+
+        $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
+        $markerContent = "Installation completed at $timestamp"
+
+        if (Test-Path "Z:\") {
+            $markerContent | Out-File -FilePath "Z:\installation-complete.txt" -Encoding UTF8
+            Write-Log "✓ Marker file created: Z:\installation-complete.txt" "Green"
+        }
+        else {
+            Write-Log "WARNING: Z: drive not available, trying UNC path..." "Yellow"
+            $markerContent | Out-File -FilePath "\\host.lan\Data\installation-complete.txt" -Encoding UTF8
+
+            if (Test-Path "\\host.lan\Data\installation-complete.txt") {
+                Write-Log "✓ Marker file created via UNC path" "Green"
+            }
+            else {
+                Write-Log "ERROR: Failed to create marker file!" "Red"
+            }
+        }
+    }
+    catch {
+        Write-Log "ERROR creating marker: $($_.Exception.Message)" "Red"
+    }
+}
+
+function Install-LookingGlass {
+    $installer = "C:\OEM\looking-glass-host-setup.exe"
+
+    if (Test-Path $installer) {
+        Write-Log "Installing Looking Glass host..." "Cyan"
+        Write-Log "  Installer: $installer" "Gray"
+        Write-Log "  Installer size: $((Get-Item $installer).Length) bytes" "Gray"
+
+        try {
+            # Log execution context for debugging
+            Write-Log "  Current user: $env:USERNAME" "Gray"
+            Write-Log "  User domain: $env:USERDOMAIN" "Gray"
+            Write-Log "  Running as admin: $(([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator))" "Gray"
+
+            # Start installer with timeout to prevent hanging
+            # Using only /S for NSIS silent install (not Inno Setup params)
+            # IMPORTANT: Do NOT use -NoNewWindow or redirect stdout/stderr during OEM setup
+            # as it can cause the installer to hang waiting for console
+            Write-Log "  Starting installer (NSIS silent mode with 120s timeout)..." "Gray"
+            Write-Log "  Command: $installer /S" "Gray"
+
+            $process = Start-Process -FilePath $installer -ArgumentList "/S" -PassThru -WindowStyle Hidden -ErrorAction Stop
+
+            # Wait max 120 seconds (2 minutes) for installation
+            # NSIS installers are typically fast, longer timeout suggests hang
+            $timeout = 120
+            $waitResult = $process.WaitForExit($timeout * 1000)
+
+            if ($waitResult) {
+                $exitCode = $process.ExitCode
+                Write-Log "  Installer finished with exit code: $exitCode" "Gray"
+
+                # Check if installation actually succeeded by looking for files
+                $lgPaths = @(
+                    "C:\Program Files\Looking Glass (host)",
+                    "C:\Program Files (x86)\Looking Glass (host)"
+                )
+
+                $installed = $false
+                foreach ($path in $lgPaths) {
+                    if (Test-Path $path) {
+                        Write-Log "  Found installation at: $path" "Gray"
+                        $installed = $true
+                        break
+                    }
+                }
+
+                if ($installed) {
+                    Write-Log "✓ Looking Glass host installation complete!" "Green"
+
+                    # Verify Looking Glass service
+                    Start-Sleep -Seconds 1
+                    $lgService = Get-Service -Name "looking-glass-host" -ErrorAction SilentlyContinue
+                    if ($lgService) {
+                        Write-Log "  Service detected: $($lgService.Status)" "Gray"
+                        Write-Log "  The service will start after reboot." "Gray"
+                    } else {
+                        Write-Log "  Service not yet registered (will be available after reboot)" "Gray"
+                    }
+                }
+                elseif ($exitCode -eq 0) {
+                    Write-Log "✓ Installer completed (exit code 0)" "Green"
+                    Write-Log "  Installation directory not verified (may be custom location)" "Gray"
+                }
+                else {
+                    Write-Log "WARNING: Installation may have failed (exit code: $exitCode)" "Yellow"
+                    Write-Log "  Continuing with setup anyway..." "Gray"
+                }
+            }
+            else {
+                Write-Log "WARNING: Looking Glass installer did not complete within $timeout seconds" "Yellow"
+                Write-Log "  This likely means the installer hung or requires user interaction" "Yellow"
+                Write-Log "  Attempting to terminate installer process..." "Gray"
+
+                try {
+                    if (-not $process.HasExited) {
+                        $process.Kill()
+                        $process.WaitForExit(5000)  # Wait 5s for graceful termination
+                        Write-Log "  Process terminated" "Gray"
+                    }
+                }
+                catch {
+                    Write-Log "  Could not terminate process: $_" "Gray"
+                }
+
+                Write-Log "  Continuing with remaining setup tasks..." "Yellow"
+            }
+        }
+        catch {
+            Write-Log "ERROR starting Looking Glass installer: $($_.Exception.Message)" "Red"
+            Write-Log "  Continuing with remaining setup tasks..." "Yellow"
+        }
+    }
+    else {
+        Write-Log "Looking Glass installer not found at: $installer" "Yellow"
+        Write-Log "  Expected during installation with GPU passthrough" "Gray"
+    }
+}
+
+function Install-SpiceGuestTools {
+    $installer = "C:\OEM\spice-guest-tools-setup.exe"
+
+    if (Test-Path $installer) {
+        Write-Log "Installing SPICE Guest Tools..." "Cyan"
+        Write-Log "  Installer: $installer" "Gray"
+        Write-Log "  Installer size: $((Get-Item $installer).Length) bytes" "Gray"
+
+        try {
+            # Log execution context for debugging
+            Write-Log "  Current user: $env:USERNAME" "Gray"
+            Write-Log "  User domain: $env:USERDOMAIN" "Gray"
+            Write-Log "  Running as admin: $(([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator))" "Gray"
+
+            # Use schtasks to run installer as SYSTEM (prevents driver approval prompts)
+            # Windows OEM setup may run as user context, but SPICE drivers require SYSTEM
+            $taskName = "OmarchyInstallSPICE"
+            Write-Log "  Creating scheduled task to run as SYSTEM (bypass driver prompts)..." "Gray"
+
+            # Create task (force overwrite if exists)
+            $taskCmd = "`"$installer`" /S"
+            schtasks /Create /TN $taskName /TR $taskCmd /SC ONCE /ST 00:00 /RU SYSTEM /RL HIGHEST /F | Out-Null
+
+            if ($LASTEXITCODE -ne 0) {
+                Write-Log "WARNING: Could not create scheduled task (code: $LASTEXITCODE)" "Yellow"
+                Write-Log "  Falling back to direct execution..." "Gray"
+
+                # Fallback: run directly
+                $process = Start-Process -FilePath $installer -ArgumentList "/S" -PassThru -WindowStyle Hidden -ErrorAction Stop
+                $timeout = 120
+                $waitResult = $process.WaitForExit($timeout * 1000)
+
+                if (-not $waitResult) {
+                    Write-Log "WARNING: Installer timeout, may require user interaction" "Yellow"
+                    if (-not $process.HasExited) {
+                        $process.Kill()
+                        $process.WaitForExit(5000)
+                    }
+                }
+
+                if ($process.HasExited) {
+                    $exitCode = $process.ExitCode
+                } else {
+                    $exitCode = -1  # Timeout
+                }
+            }
+            else {
+                # Run task immediately
+                Write-Log "  Executing installer as SYSTEM..." "Gray"
+                schtasks /Run /TN $taskName | Out-Null
+
+                # Wait for task to complete (max 120 seconds)
+                $timeout = 120
+                $elapsed = 0
+                $exitCode = 0
+
+                while ($elapsed -lt $timeout) {
+                    Start-Sleep -Seconds 2
+                    $elapsed += 2
+
+                    # Query task status
+                    $taskInfo = schtasks /Query /TN $taskName /FO LIST 2>&1 | Out-String
+                    if ($taskInfo -match "Status:\s+(.+)") {
+                        $status = $matches[1].Trim()
+                        if ($status -ne "Running") {
+                            Write-Log "  Task completed (status: $status)" "Gray"
+                            break
+                        }
+                    }
+                }
+
+                if ($elapsed -ge $timeout) {
+                    Write-Log "WARNING: SPICE installer did not complete within $timeout seconds" "Yellow"
+                }
+
+                # Delete task
+                schtasks /Delete /TN $taskName /F 2>&1 | Out-Null
+            }
+
+            # Check if installation actually succeeded by looking for SPICE agent
+            Start-Sleep -Seconds 2  # Give filesystem time to update
+
+            $spicePaths = @(
+                "C:\Program Files\SPICE Guest Tools",
+                "C:\Program Files (x86)\SPICE Guest Tools",
+                "C:\Windows\System32\drivers\vioser.sys"
+            )
+
+            $installed = $false
+            foreach ($path in $spicePaths) {
+                if (Test-Path $path) {
+                    Write-Log "  Found SPICE installation at: $path" "Gray"
+                    $installed = $true
+                    break
+                }
+            }
+
+            if ($installed) {
+                Write-Log "✓ SPICE Guest Tools installation complete!" "Green"
+                Write-Log "  Auto-resolution, clipboard, and copy-paste will be available after reboot." "Gray"
+            }
+            elseif ($exitCode -eq 0) {
+                Write-Log "✓ Installer completed (exit code 0)" "Green"
+                Write-Log "  Installation directory not verified (may be custom location)" "Gray"
+            }
+            else {
+                Write-Log "WARNING: Installation may have failed (exit code: $exitCode)" "Yellow"
+                Write-Log "  Continuing with setup anyway..." "Gray"
+            }
+        }
+        catch {
+            Write-Log "ERROR starting SPICE Guest Tools installer: $($_.Exception.Message)" "Red"
+            Write-Log "  Continuing with remaining setup tasks..." "Yellow"
+        }
+    }
+    else {
+        Write-Log "SPICE Guest Tools installer not found at: $installer" "Yellow"
+        Write-Log "  Expected during installation with Looking Glass and GPU passthrough" "Gray"
+    }
+}
+
+function Set-OmarchyWallpaper {
+    $wallpaperSrc = "C:\OEM\wallpaper\omarchy.png"
+    $wallpaperDst = "C:\Windows\Web\Wallpaper\Omarchy\omarchy.png"
+
+    if (Test-Path $wallpaperSrc) {
+        Write-Log "Setting up Omarchy wallpaper..."
+
+        try {
+            $wallpaperDir = Split-Path -Parent $wallpaperDst
+            if (-not (Test-Path $wallpaperDir)) {
+                New-Item -ItemType Directory -Path $wallpaperDir -Force | Out-Null
+            }
+            Copy-Item -Path $wallpaperSrc -Destination $wallpaperDst -Force
+            Write-Log "  Wallpaper copied to: $wallpaperDst" "Gray"
+
+            Set-ItemProperty -Path 'HKCU:\Control Panel\Desktop' -Name Wallpaper -Value $wallpaperDst -ErrorAction SilentlyContinue
+
+            Add-Type -TypeDefinition @"
+using System;
+using System.Runtime.InteropServices;
+public class Wallpaper {
+    [DllImport("user32.dll", CharSet = CharSet.Auto)]
+    public static extern int SystemParametersInfo(int uAction, int uParam, string lpvParam, int fuWinIni);
+}
+"@ -ErrorAction SilentlyContinue
+
+            $SPI_SETDESKWALLPAPER = 0x0014
+            $SPIF_UPDATEINIFILE = 0x0001
+            $SPIF_SENDCHANGE = 0x0002
+
+            [Wallpaper]::SystemParametersInfo($SPI_SETDESKWALLPAPER, 0, $wallpaperDst, $SPIF_UPDATEINIFILE -bor $SPIF_SENDCHANGE) | Out-Null
+
+            Write-Log "✓ Omarchy wallpaper set successfully" "Green"
+            Write-Log "  Note: Wallpaper applies immediately (no login required)" "Gray"
+        }
+        catch {
+            Write-Log "ERROR setting wallpaper: $($_.Exception.Message)" "Red"
+        }
+    }
+    else {
+        Write-Log "Wallpaper file not found at: $wallpaperSrc" "Yellow"
+    }
+}
+
+Write-Log ""
+Write-Log "Starting OEM setup tasks..."
+Write-Log ""
+
+Set-OmarchyWallpaper
+Install-LookingGlass
+Install-SpiceGuestTools
+Set-InstallationMarker
+
+Write-Log ""
+Write-Log "=== OEM setup complete! ===" "Green"
+Write-Log "Log file saved to: C:\OEM\install-log.txt"
+
+Write-Log ""
+Write-Log "Copying log to shared folder..."
+try {
+    $sharedPath = if (Test-Path "Z:\") { "Z:\" } elseif (Test-Path "\\host.lan\Data") { "\\host.lan\Data\" } else { $null }
+
+    if ($sharedPath) {
+        Copy-Item -Path $LogFile -Destination "$sharedPath\install-log.txt" -Force -ErrorAction Stop
+        Write-Log "✓ Log copied to: $sharedPath\install-log.txt" "Green"
+        Write-Log "  (Available on host: ~/Windows/install-log.txt)" "Gray"
+    }
+    else {
+        Write-Log "WARNING: Shared folder not accessible, log not copied" "Yellow"
+    }
+}
+catch {
+    Write-Log "WARNING: Could not copy log to shared folder: $_" "Yellow"
+}
+EOFPS1
+
+  SCRIPT_VERSION_ESCAPED=$(printf '%s\n' "$SCRIPT_VERSION" | sed 's/[&/\]/\\&/g')
+  sed -i "s/SCRIPT_VERSION_PLACEHOLDER/$SCRIPT_VERSION_ESCAPED/" "$OEM_DIR/install.ps1"
+
+  convert_to_crlf "$OEM_DIR/install.ps1"
+}
+
+create_oem_batch_script() {
+  local OEM_DIR="$1"
+
+  cat >"$OEM_DIR/install.bat" <<'EOFBAT'
+@echo off
+setlocal EnableDelayedExpansion
+
+REM Create marker file to indicate script started
+echo OEM setup started at %DATE% %TIME% > C:\OEM\oem-started.txt
+
+REM ======================================
+REM Omarchy Windows VM OEM Setup
+REM Post-installation customization script
+REM ======================================
+
+REM Check for admin privileges
+net session >nul 2>&1
+if %errorLevel% neq 0 (
+    echo ERROR: This script requires administrator privileges!
+    echo Please run as administrator.
+    pause
+    exit /b 1
+)
+
+echo ======================================
+echo Omarchy Windows VM OEM Setup
+echo ======================================
+echo.
+echo Starting PowerShell setup script...
+echo Logs will be saved to C:\OEM\install-log.txt
+echo.
+
+REM Log basic information
+echo [BATCH] OEM setup started > C:\OEM\batch-log.txt
+echo [BATCH] Current directory: %CD% >> C:\OEM\batch-log.txt
+echo [BATCH] Script location: %~dp0 >> C:\OEM\batch-log.txt
+echo [BATCH] About to execute: powershell.exe -ExecutionPolicy Bypass -NoProfile -File "%~dp0install.ps1" >> C:\OEM\batch-log.txt
+echo.
+
+REM Execute PowerShell script and capture exit code
+powershell.exe -ExecutionPolicy Bypass -NoProfile -File "%~dp0install.ps1"
+set PS_EXIT_CODE=%errorLevel%
+
+echo.
+echo ======================================
+if %PS_EXIT_CODE% equ 0 (
+    echo Setup completed successfully!
+    echo Check C:\OEM\install-log.txt for details
+) else (
+    echo WARNING: Setup finished with errors ^(exit code: %PS_EXIT_CODE%^)
+    echo Check C:\OEM\install-log.txt for error details
+    echo.
+    echo Troubleshooting:
+    echo   - Check network connectivity for shared folder
+    echo   - Verify file permissions in C:\OEM\
+    echo   - Review install-log.txt for specific errors
+)
+echo ======================================
+
+REM Wait 5 seconds before closing (gives time to read output)
+timeout /t 5 /nobreak >nul
+
+exit /b %PS_EXIT_CODE%
+EOFBAT
+
+  convert_to_crlf "$OEM_DIR/install.bat"
+}
+
+detect_smbios_and_disk_info() {
+  # Detect SMBIOS info from host for VM anti-cheat spoofing
+  # Sets global variables: SMBIOS_FLAGS, DISK_FLAGS
+
+  SMBIOS_FLAGS=""
+  DISK_FLAGS=""
+
+  if ! command -v dmidecode &>/dev/null; then
+    msg_warning "dmidecode not found - SMBIOS spoofing disabled" >&2
+    echo "   Install dmidecode for better anti-cheat compatibility" >&2
+    return 0
+  fi
+
+  escape_for_qemu() {
+    local value="$1"
+    value="${value// /_}"  # QEMU -smbios doesn't support spaces
+    value="${value//,/,,}" # Escape commas (QEMU convention: double comma)
+    echo "$value"
+  }
+
+  # Helper to check for placeholder values (case-insensitive)
+  is_valid_smbios_value() {
+    local val="${1,,}"  # lowercase
+    [[ -n "$1" ]] && [[ "$val" != "unknown" ]] && [[ "$val" != "not specified" ]] && [[ "$val" != *"to be filled"* ]] && [[ "$val" != "default string" ]] && [[ "$val" != "default" ]] && [[ "$val" != "n/a" ]]
+  }
+
+  # SMBIOS Type 0: BIOS Information
+  local BIOS_VENDOR="$(sudo -n /usr/bin/dmidecode -s bios-vendor 2>/dev/null | head -1)"
+  local BIOS_VERSION="$(sudo -n /usr/bin/dmidecode -s bios-version 2>/dev/null | head -1)"
+  local BIOS_DATE="$(sudo -n /usr/bin/dmidecode -s bios-release-date 2>/dev/null | head -1)"
+
+  if is_valid_smbios_value "$BIOS_VENDOR" && is_valid_smbios_value "$BIOS_VERSION"; then
+    SMBIOS_FLAGS="${SMBIOS_FLAGS} -smbios type=0,vendor=$(escape_for_qemu "$BIOS_VENDOR"),version=$(escape_for_qemu "$BIOS_VERSION")"
+    [[ -n "$BIOS_DATE" ]] && SMBIOS_FLAGS="${SMBIOS_FLAGS},date=$(escape_for_qemu "$BIOS_DATE")"
+    SMBIOS_FLAGS="${SMBIOS_FLAGS},uefi=on"
+  fi
+
+  # SMBIOS Type 1: System Information
+  local SYS_MANUFACTURER="$(sudo -n /usr/bin/dmidecode -s system-manufacturer 2>/dev/null | head -1)"
+  local SYS_PRODUCT="$(sudo -n /usr/bin/dmidecode -s system-product-name 2>/dev/null | head -1)"
+  local SYS_VERSION="$(sudo -n /usr/bin/dmidecode -s system-version 2>/dev/null | head -1)"
+  local SYS_SERIAL="$(sudo -n /usr/bin/dmidecode -s system-serial-number 2>/dev/null | head -1)"
+  local SYS_UUID="$(sudo -n /usr/bin/dmidecode -s system-uuid 2>/dev/null | head -1)"
+
+  if is_valid_smbios_value "$SYS_MANUFACTURER" && is_valid_smbios_value "$SYS_PRODUCT"; then
+    SMBIOS_FLAGS="${SMBIOS_FLAGS} -smbios type=1,manufacturer=$(escape_for_qemu "$SYS_MANUFACTURER"),product=$(escape_for_qemu "$SYS_PRODUCT")"
+    is_valid_smbios_value "$SYS_VERSION" && SMBIOS_FLAGS="${SMBIOS_FLAGS},version=$(escape_for_qemu "$SYS_VERSION")"
+    is_valid_smbios_value "$SYS_SERIAL" && SMBIOS_FLAGS="${SMBIOS_FLAGS},serial=$(escape_for_qemu "$SYS_SERIAL")"
+    # UUID must be in format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (only add if valid)
+    if [[ "$SYS_UUID" =~ ^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$ ]]; then
+      SMBIOS_FLAGS="${SMBIOS_FLAGS},uuid=$SYS_UUID"
+    fi
+  fi
+
+  # SMBIOS Type 4: Processor Information (required by BenchMate for Max Core Frequency)
+  local CPU_MANUFACTURER="$(sudo -n /usr/bin/dmidecode -t processor 2>/dev/null | grep -m1 'Manufacturer:' | sed 's/.*Manufacturer: //')"
+  local CPU_VERSION="$(sudo -n /usr/bin/dmidecode -t processor 2>/dev/null | grep -m1 'Version:' | sed 's/.*Version: //')"
+  local CPU_CURRENT_SPEED="$(sudo -n /usr/bin/dmidecode -t processor 2>/dev/null | grep -m1 'Current Speed:' | grep -oP '\d+' | head -1)"
+  local CPU_MAX_SPEED="$(sudo -n /usr/bin/dmidecode -t processor 2>/dev/null | grep -m1 'Max Speed:' | grep -oP '\d+' | head -1)"
+
+  if [[ -n "$CPU_MANUFACTURER" ]] && [[ -n "$CPU_VERSION" ]]; then
+    SMBIOS_FLAGS="${SMBIOS_FLAGS} -smbios type=4,manufacturer=$(escape_for_qemu "$CPU_MANUFACTURER"),version=$(escape_for_qemu "$CPU_VERSION")"
+    [[ -n "$CPU_CURRENT_SPEED" ]] && SMBIOS_FLAGS="${SMBIOS_FLAGS},current-speed=${CPU_CURRENT_SPEED}"
+    [[ -n "$CPU_MAX_SPEED" ]] && SMBIOS_FLAGS="${SMBIOS_FLAGS},max-speed=${CPU_MAX_SPEED}"
+  fi
+
+  # SMBIOS Type 2: Baseboard Information
+  local BOARD_MANUFACTURER="$(sudo -n /usr/bin/dmidecode -s baseboard-manufacturer 2>/dev/null | head -1)"
+  local BOARD_PRODUCT="$(sudo -n /usr/bin/dmidecode -s baseboard-product-name 2>/dev/null | head -1)"
+  local BOARD_VERSION="$(sudo -n /usr/bin/dmidecode -s baseboard-version 2>/dev/null | head -1)"
+  local BOARD_SERIAL="$(sudo -n /usr/bin/dmidecode -s baseboard-serial-number 2>/dev/null | head -1)"
+
+  if is_valid_smbios_value "$BOARD_MANUFACTURER" && is_valid_smbios_value "$BOARD_PRODUCT"; then
+    SMBIOS_FLAGS="${SMBIOS_FLAGS} -smbios type=2,manufacturer=$(escape_for_qemu "$BOARD_MANUFACTURER"),product=$(escape_for_qemu "$BOARD_PRODUCT")"
+    is_valid_smbios_value "$BOARD_VERSION" && SMBIOS_FLAGS="${SMBIOS_FLAGS},version=$(escape_for_qemu "$BOARD_VERSION")"
+    is_valid_smbios_value "$BOARD_SERIAL" && SMBIOS_FLAGS="${SMBIOS_FLAGS},serial=$(escape_for_qemu "$BOARD_SERIAL")"
+  fi
+
+  # SMBIOS Type 3: Chassis Information
+  local CHASSIS_MANUFACTURER="$(sudo -n /usr/bin/dmidecode -s chassis-manufacturer 2>/dev/null | head -1)"
+  local CHASSIS_SERIAL="$(sudo -n /usr/bin/dmidecode -s chassis-serial-number 2>/dev/null | head -1)"
+
+  if is_valid_smbios_value "$CHASSIS_MANUFACTURER"; then
+    SMBIOS_FLAGS="${SMBIOS_FLAGS} -smbios type=3,manufacturer=$(escape_for_qemu "$CHASSIS_MANUFACTURER")"
+    is_valid_smbios_value "$CHASSIS_SERIAL" && SMBIOS_FLAGS="${SMBIOS_FLAGS},serial=$(escape_for_qemu "$CHASSIS_SERIAL")"
+  fi
+
+  # SMBIOS Type 17: Memory Device (find first populated DIMM)
+  local MEM_MANUFACTURER="$(sudo -n /usr/bin/dmidecode -t memory 2>/dev/null | grep 'Manufacturer:' | grep -v 'Not Specified' | head -1 | sed 's/.*Manufacturer: //' | xargs)"
+  local MEM_PART="$(sudo -n /usr/bin/dmidecode -t memory 2>/dev/null | grep 'Part Number:' | grep -v 'Not Specified' | head -1 | sed 's/.*Part Number: //' | xargs)"
+  local MEM_SPEED="$(sudo -n /usr/bin/dmidecode -t memory 2>/dev/null | grep 'Speed:' | grep -v 'Unknown' | head -1 | grep -oP '\d+' | head -1)"
+  local MEM_SERIAL="$(sudo -n /usr/bin/dmidecode -t memory 2>/dev/null | grep 'Serial Number:' | grep -v 'Not Specified' | head -1 | sed 's/.*Serial Number: //' | xargs)"
+
+  if is_valid_smbios_value "$MEM_MANUFACTURER"; then
+    SMBIOS_FLAGS="${SMBIOS_FLAGS} -smbios type=17,manufacturer=$(escape_for_qemu "$MEM_MANUFACTURER"),loc_pfx=DIMM_A1,bank=Bank_0"
+    is_valid_smbios_value "$MEM_SERIAL" && SMBIOS_FLAGS="${SMBIOS_FLAGS},serial=$(escape_for_qemu "$MEM_SERIAL")"
+    is_valid_smbios_value "$MEM_PART" && SMBIOS_FLAGS="${SMBIOS_FLAGS},part=$(escape_for_qemu "$MEM_PART")"
+    [[ -n "$MEM_SPEED" ]] && SMBIOS_FLAGS="${SMBIOS_FLAGS},speed=${MEM_SPEED}"
+  fi
+
+  # Disk spoofing - detect disk containing $HOME (where VM data lives)
+  local HOME_PARTITION DISK_DEVICE=""
+  HOME_PARTITION=$(df -P "$HOME" 2>/dev/null | tail -1 | awk '{print $1}')
+  if [[ -n "$HOME_PARTITION" ]] && [[ -b "$HOME_PARTITION" ]]; then
+    # Get parent device (strip partition): /dev/nvme1n1p2 → nvme1n1, /dev/sda2 → sda
+    DISK_DEVICE="/dev/$(lsblk -no PKNAME "$HOME_PARTITION" 2>/dev/null | head -1)"
+  fi
+
+  # Fallback chain: detected disk → nvme0n1 → sda
+  [[ ! -b "$DISK_DEVICE" ]] && DISK_DEVICE="/dev/nvme0n1"
+  [[ ! -b "$DISK_DEVICE" ]] && DISK_DEVICE="/dev/sda"
+
+  local DISK_VENDOR="$(lsblk -ndo VENDOR "$DISK_DEVICE" 2>/dev/null | xargs)"
+  local DISK_MODEL="$(lsblk -ndo MODEL "$DISK_DEVICE" 2>/dev/null | xargs)"
+  local DISK_SERIAL="$(lsblk -ndo SERIAL "$DISK_DEVICE" 2>/dev/null | xargs)"
+
+  if [[ -n "$DISK_MODEL" ]]; then
+    [[ -n "$DISK_VENDOR" ]] && DISK_FLAGS="${DISK_FLAGS} -global scsi-hd.vendor=$(escape_for_qemu "$DISK_VENDOR")"
+    DISK_FLAGS="${DISK_FLAGS} -global scsi-hd.product=$(escape_for_qemu "$DISK_MODEL")"
+    [[ -n "$DISK_SERIAL" ]] && DISK_FLAGS="${DISK_FLAGS} -global scsi-hd.serial=$(escape_for_qemu "$DISK_SERIAL")"
+    # Performance optimization: removed rotation_rate=1 (metadata only, no anti-cheat value)
+  fi
+}
+
+# Format CPU range: "X" for single, "X-Y" for range
+format_cpu_range() {
+  local start=$1 end=$2
+  if ((end == start)); then
+    echo "$start"
+  else
+    echo "${start}-${end}"
+  fi
+}
+
+# Detect SMP topology for proper hyperthreading/SMT support in guest
+detect_smp_topology() {
+  local selected_vcpus="${1:-}"
+  SMP_FLAGS=""
+  SMT_ENABLED=false
+  THREADS_PER_CORE=1
+  VM_PHYSICAL_CORES=0
+
+  [[ -z "$selected_vcpus" ]] || ! [[ "$selected_vcpus" =~ ^[0-9]+$ ]] && return 1
+
+  # Detect host threads per core
+  local host_threads_per_core
+  host_threads_per_core=$(lscpu 2>/dev/null | grep -E "^Thread\(s\) per core:" | awk '{print $NF}')
+  [[ -z "$host_threads_per_core" ]] && host_threads_per_core=1
+
+  if ((host_threads_per_core >= 2)); then
+    SMT_ENABLED=true
+    THREADS_PER_CORE=2
+  fi
+
+  # Calculate physical cores and threads for VM
+  # selected_vcpus = number of physical cores user wants
+  # With SMT: each core has 2 threads, so total vCPUs = cores × 2
+  if [[ "$SMT_ENABLED" == true ]]; then
+    VM_PHYSICAL_CORES=$selected_vcpus
+    local vm_threads=$((VM_PHYSICAL_CORES * 2))
+
+    # -smp total,sockets=1,cores=X,threads=2
+    # Example: 8 cores with SMT → -smp 16,sockets=1,cores=8,threads=2
+    SMP_FLAGS="-smp ${vm_threads},sockets=1,cores=${VM_PHYSICAL_CORES},threads=2"
+  else
+    # Without SMT: each vCPU is a physical core
+    VM_PHYSICAL_CORES=$selected_vcpus
+    SMP_FLAGS="-smp ${selected_vcpus},sockets=1,cores=${selected_vcpus},threads=1"
+  fi
+
+  return 0
+}
+
+# Detect CPU pinning for Intel Hybrid CPUs (P-core + E-core)
+# Limits VM to P-cores for better gaming performance (E-cores are slower)
+# Note: Host can still use all cores - cpuset only limits the container
+detect_cpu_pinning_set() {
+  local selected_cores="${1:-}"
+  CPU_PINNING_SET=""
+
+  local total_threads
+  total_threads=$(nproc --all 2>/dev/null) || return 1
+  ((total_threads < 6)) && return 1
+
+  local -a cpu_freqs=()
+  local -A freq_seen=()
+  local -a unique_freqs=()
+  local cpu freq
+
+  for ((cpu = 0; cpu < total_threads; cpu++)); do
+    local freq_file="/sys/devices/system/cpu/cpu${cpu}/cpufreq/cpuinfo_max_freq"
+    [[ -r "$freq_file" ]] || continue
+    freq=$(<"$freq_file") || continue
+    [[ "$freq" =~ ^[0-9]+$ ]] || continue
+    cpu_freqs[$cpu]=$freq
+    if [[ -z "${freq_seen[$freq]:-}" ]]; then
+      freq_seen[$freq]=1
+      unique_freqs+=("$freq")
+    fi
+  done
+
+  if [[ ${#cpu_freqs[@]} -eq 0 ]]; then
+    detect_cpu_pinning_set_simple "$selected_cores"
+    return $?
+  fi
+
+  # Hybrid CPU: multiple max frequencies - use P-cores (faster) for VM
+  if [[ ${#unique_freqs[@]} -gt 1 ]]; then
+    local lowest_freq
+    lowest_freq=$(printf '%s\n' "${unique_freqs[@]}" | sort -n | head -1)
+
+    local -a vm_cpus=()
+    for ((cpu = 0; cpu < total_threads; cpu++)); do
+      [[ -z "${cpu_freqs[$cpu]:-}" ]] && continue
+      [[ "${cpu_freqs[$cpu]}" != "$lowest_freq" ]] && vm_cpus+=("$cpu")
+    done
+
+    if [[ ${#vm_cpus[@]} -lt 4 ]]; then
+      detect_cpu_pinning_set_simple "$selected_cores"
+      return $?
+    fi
+
+    # selected_cores = number of physical cores user wants
+    # With SMT, need selected_cores * threads_per_core host threads
+    # Use global THREADS_PER_CORE set by detect_smp_topology()
+    if [[ -n "$selected_cores" ]] && [[ "$selected_cores" =~ ^[0-9]+$ ]]; then
+      local needed_threads=$((selected_cores * THREADS_PER_CORE))
+      if ((needed_threads < ${#vm_cpus[@]})); then
+        vm_cpus=("${vm_cpus[@]:0:$needed_threads}")
+      fi
+    fi
+
+    CPU_PINNING_SET=$(compact_cpu_list "${vm_cpus[@]}")
+  else
+    detect_cpu_pinning_set_simple "$selected_cores"
+    return $?
+  fi
+
+  return 0
+}
+
+# CPU pinning: reserves core 0 (IRQs) or core 0,1 for host to reduce micro-stutters
+# Dynamic: max vCPU=no reserve, max-2=1 core, ≤max-4=2 cores, fallback if can't fit
+detect_cpu_pinning_set_simple() {
+  local selected_cores="${1:-}"
+  local total_threads physical_cores
+
+  total_threads=$(nproc --all 2>/dev/null) || return 1
+  ((total_threads < 4)) && return 1
+
+  if [[ -z "$selected_cores" ]] || ! [[ "$selected_cores" =~ ^[0-9]+$ ]] || ((selected_cores >= total_threads)); then
+    CPU_PINNING_SET="0-$((total_threads - 1))"
+    return 0
+  fi
+
+  physical_cores=$((total_threads / THREADS_PER_CORE))
+
+  local vm_start phys_cores_needed
+  phys_cores_needed=$selected_cores
+
+  # Dynamic reservation: prefer 2 cores, fallback to 1, then 0
+  if ((selected_cores >= total_threads - 2)); then
+    vm_start=1
+  else
+    vm_start=2
+  fi
+
+  # Reduce if can't fit requested cores
+  while ((vm_start > 0)) && ((phys_cores_needed > physical_cores - vm_start)); do
+    ((vm_start--))
+  done
+
+  if ((vm_start == 0)); then
+    CPU_PINNING_SET="0-$((total_threads - 1))"
+    return 0
+  fi
+
+  if ((THREADS_PER_CORE == 1)); then
+    local vm_end=$((vm_start + selected_cores - 1))
+    ((vm_end >= physical_cores)) && vm_end=$((physical_cores - 1))
+    CPU_PINNING_SET=$(format_cpu_range "$vm_start" "$vm_end")
+  else
+    # SMT: use full physical cores for cache locality
+    local available_cores=$((physical_cores - vm_start))
+    local primary_end sibling_start sibling_end
+
+    if ((phys_cores_needed >= available_cores)); then
+      primary_end=$((physical_cores - 1))
+      sibling_start=$((physical_cores + vm_start))
+      sibling_end=$((total_threads - 1))
+    else
+      primary_end=$((vm_start + phys_cores_needed - 1))
+      sibling_start=$((physical_cores + vm_start))
+      sibling_end=$((sibling_start + phys_cores_needed - 1))
+    fi
+
+    CPU_PINNING_SET="$(format_cpu_range "$vm_start" "$primary_end"),$(format_cpu_range "$sibling_start" "$sibling_end")"
+  fi
+
+  return 0
+}
+
+# Convert "0 1 2 5 6 7" → "0-2,5-7"
+compact_cpu_list() {
+  local -a cpus=("$@")
+  [[ ${#cpus[@]} -eq 0 ]] && return
+
+  local -a sorted_cpus
+  mapfile -t sorted_cpus < <(printf '%s\n' "${cpus[@]}" | sort -n)
+
+  local result="" start="" prev=""
+  for current in "${sorted_cpus[@]}"; do
+    if [[ -z "$start" ]]; then
+      start=$current
+      prev=$current
+    elif ((current == prev + 1)); then
+      prev=$current
+    else
+      if [[ "$start" == "$prev" ]]; then
+        result+="${result:+,}$start"
+      else
+        result+="${result:+,}${start}-${prev}"
+      fi
+      start=$current
+      prev=$current
+    fi
+  done
+
+  # Close final range
+  if [[ -n "$start" ]]; then
+    if [[ "$start" == "$prev" ]]; then
+      result+="${result:+,}$start"
+    else
+      result+="${result:+,}${start}-${prev}"
+    fi
+  fi
+
+  echo "$result"
+}
+
+create_docker_compose_config() {
+  local COMPOSE_FILE="$1"
+  local SELECTED_RAM="$2"
+  local SELECTED_CORES="$3"
+  local SELECTED_DISK="$4"
+  local USERNAME="$5"
+  local PASSWORD="$6"
+  local LG_ENABLED="$7"
+  local IVSHMEM_SIZE="${8:-64}"
+  local GPU_PASSTHROUGH_ENABLED="${9:-false}"
+  local GPU_PCI_ADDR="${10:-}"
+  local GPU_IOMMU_GROUP="${11:-}"
+  local GPU_IOMMU_DEVICES="${12:-}"
+  local TPM_ENABLED="${13:-true}"
+
+  # Detect SMBIOS and disk info for anti-cheat spoofing
+  detect_smbios_and_disk_info
+
+  # Detect SMP topology
+  detect_smp_topology "$SELECTED_CORES"
+
+  # Detect CPU pinning based on selected cores
+  detect_cpu_pinning_set "$SELECTED_CORES"
+
+  local MACHINE_FLAGS="-machine kernel-irqchip=on"
+  local HV_VENDOR_ID="AuthenticAMD"
+  local CPU_EXTRA=""
+
+  if grep -qi 'GenuineIntel' /proc/cpuinfo 2>/dev/null; then
+    HV_VENDOR_ID="GenuineIntel"
+    CPU_EXTRA=",+hv-evmcs"
+    [[ "$LG_ENABLED" == true ]] && CPU_EXTRA="${CPU_EXTRA},host-phys-bits-limit=39"
+  else
+    if [[ "$SMT_ENABLED" == true ]]; then
+      CPU_EXTRA=",+topoext"
+    fi
+  fi
+
+  local CPU_FLAGS="-cpu host,-hypervisor,hv_vendor_id=${HV_VENDOR_ID},+pdpe1gb,+tsc-deadline${CPU_EXTRA}"
+
+  # Auto-detect host timezone
+  local HOST_TZ=""
+  if [[ -r /etc/timezone ]]; then
+    HOST_TZ=$(<"/etc/timezone")
+    HOST_TZ="${HOST_TZ//[[:space:]]/}"
+  elif command -v timedatectl &>/dev/null; then
+    HOST_TZ=$(timedatectl show -p Timezone --value 2>/dev/null)
+    HOST_TZ="${HOST_TZ//[[:space:]]/}"
+  fi
+  [[ -z "$HOST_TZ" ]] && HOST_TZ="UTC"
+
+  # Build ARGUMENTS section based on configuration
+  local ARGUMENTS_SECTION=""
+  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]] && [[ "$LG_ENABLED" == true ]]; then
+    # GPU Passthrough + Looking Glass + SPICE
+    # vfio-pci passthrough GPU is primary display (console 0)
+    # No QXL needed - Looking Glass uses passthrough GPU for display
+    ARGUMENTS_SECTION="
+      ARGUMENTS: >-"
+    [[ -n "$MACHINE_FLAGS" ]] && ARGUMENTS_SECTION+="
+        $MACHINE_FLAGS"
+    ARGUMENTS_SECTION+="
+        $CPU_FLAGS"
+    [[ -n "$SMP_FLAGS" ]] && ARGUMENTS_SECTION+="
+        $SMP_FLAGS"
+    [[ -n "$SMBIOS_FLAGS" ]] && ARGUMENTS_SECTION+="
+        ${SMBIOS_FLAGS# }"
+    [[ -n "$DISK_FLAGS" ]] && ARGUMENTS_SECTION+="
+        ${DISK_FLAGS# }"
+    ARGUMENTS_SECTION+="
+        -device ivshmem-plain,id=shmem0,memdev=looking-glass
+        -object memory-backend-file,id=looking-glass,mem-path=/dev/kvmfr0,size=${IVSHMEM_SIZE}M,share=yes"
+
+    # AMD GPU requires dedicated PCIe root-port for Windows drivers
+    # Check if GPU is multifunction device (has multiple functions like .0, .1)
+    local gpu_base_addr="${GPU_PCI_ADDR%.*}"  # e.g., 03:00.0 -> 03:00
+    local gpu_function_count=0
+    local gpu_devices_filtered=()
+
+    for dev_pci in $GPU_IOMMU_DEVICES; do
+      # Skip PCI bridges (class 0604) - they're host infrastructure
+      local dev_class=$(lspci -Dn -s "$dev_pci" 2>/dev/null | awk '{print $2}' | cut -d: -f1)
+      if [[ "$dev_class" == "0604" ]]; then
+        continue
+      fi
+      gpu_devices_filtered+=("$dev_pci")
+      # Count functions on same base address (multifunction detection)
+      if [[ "${dev_pci%.*}" == "$gpu_base_addr" ]]; then
+        ((gpu_function_count++))
+      fi
+    done
+
+    # Multifunction if more than one function on same base address
+    local is_multifunction=false
+    [[ "$gpu_function_count" -gt 1 ]] && is_multifunction=true
+
+    ARGUMENTS_SECTION+="
+        -device pcie-root-port,id=pcie_gpu,bus=pcie.0,addr=1c.0,slot=1,chassis=1,multifunction=on"
+
+    local gpu_device_idx=0
+
+    for dev_pci in "${gpu_devices_filtered[@]}"; do
+      # Get function number from PCI address (e.g., 03:00.0 -> 0, 03:00.1 -> 1)
+      local func_num="${dev_pci##*.}"
+
+      if [[ "$gpu_device_idx" -eq 0 ]]; then
+        # First device (GPU video)
+        if [[ "$is_multifunction" == true ]]; then
+          ARGUMENTS_SECTION+="
+        -device vfio-pci,host=0000:${dev_pci},bus=pcie_gpu,addr=00.${func_num},multifunction=on"
+        else
+          ARGUMENTS_SECTION+="
+        -device vfio-pci,host=0000:${dev_pci},bus=pcie_gpu,addr=00.${func_num}"
+        fi
+      else
+        # Subsequent devices (audio etc.) - same bus, addr=00.X
+        ARGUMENTS_SECTION+="
+        -device vfio-pci,host=0000:${dev_pci},bus=pcie_gpu,addr=00.${func_num}"
+      fi
+      ((gpu_device_idx++))
+    done
+    ARGUMENTS_SECTION+="
+        -audiodev spice,id=spice
+        -device intel-hda
+        -device hda-duplex,audiodev=spice
+        -spice unix=on,addr=/tmp/spice/spice.sock,disable-ticketing=on,agent-mouse=off
+        -device virtio-serial-pci
+        -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0
+        -chardev spicevmc,id=spicechannel0,name=vdagent
+        -device virtio-mouse-pci
+        -device virtio-keyboard-pci
+        -global ICH9-LPC.disable_s3=1
+        -global ICH9-LPC.disable_s4=1
+
+      USB: \"no\""
+  elif [[ "$LG_ENABLED" == true ]]; then
+    # Looking Glass only (no GPU passthrough)
+    local LG_ARGS="$MACHINE_FLAGS $CPU_FLAGS $SMP_FLAGS $SMBIOS_FLAGS $DISK_FLAGS -device ivshmem-plain,id=shmem0,memdev=looking-glass -object memory-backend-file,id=looking-glass,mem-path=/dev/kvmfr0,size=${IVSHMEM_SIZE}M,share=yes"
+    LG_ARGS="${LG_ARGS# }" # Trim leading space
+    ARGUMENTS_SECTION="
+      ARGUMENTS: \"$LG_ARGS\""
+  else
+    # No GPU passthrough, no Looking Glass - CPU-only VM with anti-cheat flags
+    if [[ -n "$MACHINE_FLAGS" ]] || [[ "$CPU_FLAGS" != "-cpu host" ]] || [[ -n "$SMBIOS_FLAGS" ]] || [[ -n "$DISK_FLAGS" ]] || [[ -n "$SMP_FLAGS" ]]; then
+      local CPU_ARGS="$MACHINE_FLAGS $CPU_FLAGS $SMP_FLAGS $SMBIOS_FLAGS $DISK_FLAGS"
+      CPU_ARGS="${CPU_ARGS# }" # Trim leading space
+      ARGUMENTS_SECTION="
+      ARGUMENTS: \"$CPU_ARGS\""
+    fi
+  fi
+
+  # Build devices section
+  local DEVICES_KVMFR=""
+  if [[ "$LG_ENABLED" == true ]]; then
+    DEVICES_KVMFR="
+      - /dev/kvmfr0:/dev/kvmfr0"
+  fi
+
+  local DEVICES_VFIO=""
+  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]]; then
+    DEVICES_VFIO=""
+    for group in $(echo "$GPU_IOMMU_GROUP" | tr ',' ' '); do
+      DEVICES_VFIO+="
+      - /dev/vfio/${group}:/dev/vfio/${group}"
+    done
+    DEVICES_VFIO+="
+      - /dev/vfio/vfio:/dev/vfio/vfio"
+  fi
+
+  # Build ulimits section (needed for VFIO memory locking)
+  local ULIMITS_SECTION=""
+  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]]; then
+    ULIMITS_SECTION="
+
+    ulimits:
+      memlock:
+        soft: -1
+        hard: -1"
+  fi
+
+  # Build volumes section
+  local VOLUMES_SPICE=""
+  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]] && [[ "$LG_ENABLED" == true ]]; then
+    VOLUMES_SPICE="
+      - $SPICE_DIR:/tmp/spice"
+  fi
+
+  # Build TPM/Secure Boot section
+  local TPM_SECTION=""
+  if [[ "$TPM_ENABLED" == true ]]; then
+    TPM_SECTION="
+      TPM: \"Y\"
+      BOOT_MODE: \"windows_secure\""
+  fi
+
+  local CPUSET_SECTION=""
+  if [[ -n "$CPU_PINNING_SET" ]]; then
+    CPUSET_SECTION="
+    cpuset: \"$CPU_PINNING_SET\""
+  fi
+
+  # Create docker-compose.yml with clean variable substitution
+  # If COMPOSE_FILE is "-" or "/dev/stdout", print to stdout instead of file
+  if [[ "$COMPOSE_FILE" == "-" ]] || [[ "$COMPOSE_FILE" == "/dev/stdout" ]]; then
+    cat <<EOF
+services:
+  windows:
+    image: $DOCKER_IMAGE
+    pull_policy: if_not_present
+    container_name: omarchy-windows
+    environment:
+      VERSION: "11"
+      RAM_SIZE: "$SELECTED_RAM"
+      CPU_CORES: "$SELECTED_CORES"
+      DISK_SIZE: "$SELECTED_DISK"
+      USERNAME: "$USERNAME"
+      PASSWORD: "$PASSWORD"
+      TZ: "$HOST_TZ"$TPM_SECTION$ARGUMENTS_SECTION
+    devices:
+      - /dev/kvm
+      - /dev/net/tun$DEVICES_KVMFR$DEVICES_VFIO
+    cap_add:
+      - NET_ADMIN$ULIMITS_SECTION$CPUSET_SECTION
+    ports:
+      - 8006:8006
+      - 3389:3389/tcp
+      - 3389:3389/udp
+    volumes:
+      - \${HOME}/.windows:/storage
+      - \${HOME}/Windows:/shared
+      - \${HOME}/.config/windows/oem:/oem$VOLUMES_SPICE
+    restart: "no"
+    stop_grace_period: 2m
+EOF
+  else
+    cat >"$COMPOSE_FILE" <<EOF
+services:
+  windows:
+    image: $DOCKER_IMAGE
+    pull_policy: if_not_present
+    container_name: omarchy-windows
+    environment:
+      VERSION: "11"
+      RAM_SIZE: "$SELECTED_RAM"
+      CPU_CORES: "$SELECTED_CORES"
+      DISK_SIZE: "$SELECTED_DISK"
+      USERNAME: "$USERNAME"
+      PASSWORD: "$PASSWORD"
+      TZ: "$HOST_TZ"$TPM_SECTION$ARGUMENTS_SECTION
+    devices:
+      - /dev/kvm
+      - /dev/net/tun$DEVICES_KVMFR$DEVICES_VFIO
+    cap_add:
+      - NET_ADMIN$ULIMITS_SECTION$CPUSET_SECTION
+    ports:
+      - 8006:8006
+      - 3389:3389/tcp
+      - 3389:3389/udp
+    volumes:
+      - \${HOME}/.windows:/storage
+      - \${HOME}/Windows:/shared
+      - \${HOME}/.config/windows/oem:/oem$VOLUMES_SPICE
+    restart: "no"
+    stop_grace_period: 2m
+EOF
+    chmod 600 "$COMPOSE_FILE"
+  fi
+}
+
+show_installation_header() {
+  local IS_FRESH_INSTALL="$1"
+
+  if [[ "$IS_FRESH_INSTALL" == "true" ]]; then
+    echo "Waiting for Windows installation to complete..."
+  else
+    echo "Waiting for Windows boot..."
+  fi
+  echo ""
+}
+
+draw_progress_bar() {
+  local PERCENT="$1"
+  local BAR_WIDTH=20
+
+  # Validate and clamp PERCENT to 0-100 range
+  [[ ! "$PERCENT" =~ ^[0-9]+$ ]] && PERCENT=0
+  [[ "$PERCENT" -gt 100 ]] && PERCENT=100
+
+  # Calculate filled and empty parts
+  local FILLED=$((PERCENT * BAR_WIDTH / 100))
+  local EMPTY=$((BAR_WIDTH - FILLED))
+
+  # Build progress bar
+  local BAR="["
+  for ((i = 0; i < FILLED; i++)); do
+    BAR+="█"
+  done
+  for ((i = 0; i < EMPTY; i++)); do
+    BAR+="░"
+  done
+  BAR+="]"
+
+  echo "$BAR"
+}
+
+show_disk_usage() {
+  local VM_DISK="$1"
+  local TIME_PREFIX="$2"
+
+  local DISK_SIZE_MB=0
+  if [[ -f "$VM_DISK" ]]; then
+    DISK_SIZE_MB=$(du -m "$VM_DISK" | cut -f1 2>/dev/null || echo "0")
+    [[ "$DISK_SIZE_MB" =~ ^[0-9]+$ ]] || DISK_SIZE_MB=0
+  fi
+
+  # Get max disk size from docker-compose config
+  local MAX_DISK_GB=256
+  if [[ -f "$COMPOSE_FILE" ]]; then
+    MAX_DISK_GB=$(grep -E '^\s*DISK_SIZE:' "$COMPOSE_FILE" | grep -oP '\d+' | head -1)
+    [[ "$MAX_DISK_GB" =~ ^[0-9]+$ ]] || MAX_DISK_GB=256
+  fi
+
+  # Calculate percentage used
+  local MAX_DISK_MB=$((MAX_DISK_GB * 1024))
+  local PERCENT_USED=0
+  if [[ "$MAX_DISK_MB" -gt 0 ]] && [[ "$DISK_SIZE_MB" -gt 0 ]]; then
+    PERCENT_USED=$((DISK_SIZE_MB * 100 / MAX_DISK_MB))
+  fi
+
+  # Format with comma separator for MB (using sed, works everywhere)
+  local FORMATTED_MB=$(echo "$DISK_SIZE_MB" | sed ':a;s/\B[0-9]\{3\}\>/,&/;ta')
+
+  printf "%s Storage: %s MB / %d GB (%d%% used)\n" "$TIME_PREFIX" "$FORMATTED_MB" "$MAX_DISK_GB" "$PERCENT_USED"
+}
+
+handle_installation_marker() {
+  local COMPLETION_MARKER="$1"
+  local TIME_PREFIX="$2"
+
+  # Remove UTF-8 BOM if present
+  local MARKER_CONTENT=$(cat "$COMPLETION_MARKER" 2>/dev/null | LC_ALL=C sed 's/^\xEF\xBB\xBF//' || echo "marker detected")
+
+  printf "%s Installation complete! Windows reports: %s\n" "$TIME_PREFIX" "$MARKER_CONTENT"
+  printf "%s Waiting for RDP service...\n" "$TIME_PREFIX"
+  sleep 10
+
+  if command -v nc &>/dev/null && nc -z 127.0.0.1 3389 2>/dev/null; then
+    printf "%s RDP port accessible\n" "$TIME_PREFIX"
+  fi
+}
+
+show_installation_summary() {
+  local ELAPSED="$1"
+  local USERNAME="$2"
+  local PASSWORD="$3"
+  local LG_ENABLED="${4:-false}"
+  local DOWNLOAD_START="$5"
+  local EXTRACT_START="$6"
+  local OEM_START="$7"
+  local BUILD_START="$8"
+  local DISK_START="$9"
+  local BOOT_START="${10}"
+  local WINDOWS_START="${11}"
+  local CURRENT="${12}"
+  local IS_FRESH_INSTALL="${13:-false}"
+
+  local MINUTES=$((ELAPSED / 60))
+  local SECONDS=$((ELAPSED % 60))
+
+  echo ""
+  echo "Installation Complete!"
+  printf "  Total time: %dm %ds\n" "$MINUTES" "$SECONDS"
+  echo ""
+
+  # Calculate individual stage durations (show only non-zero)
+  echo "  Stage Timing:"
+  if [[ "$DOWNLOAD_START" -gt 0 ]] && [[ "$EXTRACT_START" -gt 0 ]]; then
+    local DUR=$((EXTRACT_START - DOWNLOAD_START))
+    if [[ "$DUR" -gt 0 ]]; then
+      printf "    Download:        %dm %ds\n" "$((DUR / 60))" "$((DUR % 60))"
+    fi
+  fi
+  if [[ "$EXTRACT_START" -gt 0 ]] && [[ "$OEM_START" -gt 0 ]]; then
+    local DUR=$((OEM_START - EXTRACT_START))
+    if [[ "$DUR" -gt 0 ]]; then
+      printf "    Extract:         %dm %ds\n" "$((DUR / 60))" "$((DUR % 60))"
+    fi
+  fi
+  if [[ "$BUILD_START" -gt 0 ]] && [[ "$DISK_START" -gt 0 ]]; then
+    local DUR=$((DISK_START - BUILD_START))
+    if [[ "$DUR" -gt 0 ]]; then
+      printf "    Build:           %dm %ds\n" "$((DUR / 60))" "$((DUR % 60))"
+    fi
+  fi
+  if [[ "$BOOT_START" -gt 0 ]] && [[ "$WINDOWS_START" -gt 0 ]]; then
+    local DUR=$((WINDOWS_START - BOOT_START))
+    if [[ "$DUR" -gt 0 ]]; then
+      printf "    First boot:      %dm %ds\n" "$((DUR / 60))" "$((DUR % 60))"
+    fi
+  fi
+  if [[ "$WINDOWS_START" -gt 0 ]] && [[ "$CURRENT" -gt 0 ]]; then
+    local DUR=$((CURRENT - WINDOWS_START))
+    printf "    Windows setup:   %dm %ds\n" "$((DUR / 60))" "$((DUR % 60))"
+  fi
+  echo ""
+
+  # Show installed components
+  echo "  Installed Components:"
+  echo "    [OK] Windows 11 Pro"
+  if [[ "$LG_ENABLED" == true ]]; then
+    echo "    [OK] Looking Glass host service"
+  fi
+  echo "    [OK] SPICE Guest Tools"
+  echo ""
+
+  # Desktop notification
+  notify_silent "Windows VM" "Installation complete! (${MINUTES}m ${SECONDS}s)" "normal"
+
+  if [[ "$LG_ENABLED" == true ]]; then
+    echo ""
+    echo "Looking Glass Setup"
+    echo "  1. Ensure display is connected to GPU (monitor, 2nd cable, or dummy plug)"
+    echo "     Note: dummy plugs limit Windows refresh rate"
+    echo ""
+    echo "  2. Wait for Windows to install GPU drivers (few minutes)"
+    echo "     → Close noVNC browser tab (no longer needed)"
+    echo ""
+    echo "  3. Device Manager → Disable 'Red Hat VirtIO GPU DOD controller'"
+    echo "     WARNING: Screen will FREEZE after this - this is normal!"
+    echo ""
+    echo "  4. Immediately restart the VM:"
+    echo "     → omarchy-windows-vm stop"
+    echo "     → omarchy-windows-vm launch --lg --keep-alive --windowed"
+    echo ""
+    echo "  5. After restart, wait for Windows to configure the GPU display"
+    echo "     → Looking Glass will show native GPU output"
+    echo ""
+    echo "  6. Optional: Set resolution and refresh rate in Windows Display Settings"
+    echo ""
+    echo "  7. Install GPU drivers (NVIDIA/AMD) for best performance"
+    echo "     Screen may FREEZE during install - restart VM as in step 4"
+    echo "     Tip: RDP works even when LG freezes (omarchy-windows-vm launch)"
+    echo ""
+    echo "Done! You now have full GPU performance in Looking Glass."
+    echo "     Now you can update Windows, install games and apps."
+    echo ""
+    echo "If Looking Glass doesn't start automatically:"
+    echo "  → omarchy-windows-vm launch --lg --keep-alive"
+    echo "  → or use app menu: 'Windows [Looking Glass]'"
+    echo ""
+  fi
+}
+
+connect_looking_glass() {
+  local KEEP_ALIVE="${1:-true}"
+  local WINDOWED="${2:-false}"
+
+  # Note: sudo -v removed - no longer needed with sudoers rules configured
+  # Socket permissions are fixed automatically via passwordless sudo rules
+
+  # Auto-fix Looking Glass config if using old SPICE socket path
+  LG_CONFIG="$HOME/.config/looking-glass/client.ini"
+  if [[ -f "$LG_CONFIG" ]]; then
+    if grep -q "host=/tmp/spice/spice.sock" "$LG_CONFIG" 2>/dev/null; then
+      echo "  Updating Looking Glass config to new SPICE socket path..."
+      sed -i 's|host=/tmp/spice/spice.sock|host=/var/run/omarchy-windows/spice.sock|g' "$LG_CONFIG"
+      msg_success "Config updated"
+    fi
+  fi
+
+  # Validate Looking Glass requirements: client, module, device, permissions
+  if ! command -v looking-glass-client &>/dev/null; then
+    msg_error "Looking Glass is not installed!"
+    echo ""
+    echo "Install it with: omarchy-looking-glass-install"
+    echo "Or search for 'Install Looking Glass' in the application menu"
+    exit 1
+  fi
+
+  if ! lsmod | grep -q kvmfr; then
+    msg_warning "kvmfr module not loaded, attempting to load..."
+    if sudo -n /usr/bin/modprobe kvmfr 2>/dev/null; then
+      msg_success "Module loaded successfully"
+      sleep 1 # Give udev time to create device
+    else
+      msg_error "Failed to load kvmfr module"
+      echo "   Install: omarchy-looking-glass-install"
+      echo "   Then reboot"
+      exit 1
+    fi
+  fi
+
+  if [[ ! -e /dev/kvmfr0 ]]; then
+    msg_error "/dev/kvmfr0 not found (module loaded but device missing)"
+    echo "   Reinstall: omarchy-looking-glass-install"
+    echo "   Then reboot"
+    exit 1
+  fi
+
+  # Check /dev/kvmfr0 permissions and auto-fix if needed
+  USE_SG_KVM=false
+  if [[ ! -r /dev/kvmfr0 ]]; then
+    # Try to fix permissions silently
+    ensure_user_in_kvm_group
+    local kvm_status=$?
+    case "$kvm_status" in
+    1)
+      # User was just added to kvm group - use temporary access (silent)
+      USE_SG_KVM=true
+      ;;
+    0)
+      # User already in kvm group but session not refreshed - use temporary access (silent)
+      USE_SG_KVM=true
+      ;;
+    2)
+      echo ""
+      msg_error "Cannot access /dev/kvmfr0"
+      echo "   Failed to add user to kvm group."
+      echo ""
+      echo "   Manual fix:"
+      echo "   1. sudo usermod -aG kvm \"$USER\""
+      echo "   2. Logout and login again (or reboot)"
+      echo "   3. Verify: ls -la /dev/kvmfr0"
+      echo ""
+      exit 1
+      ;;
+    *)
+      msg_error "Cannot access /dev/kvmfr0 (code: $kvm_status)"
+      echo "  Fix: sudo usermod -aG kvm \"$USER\" && reboot"
+      echo "  Help: https://github.com/basecamp/omarchy/discussions/3455"
+      exit 1
+      ;;
+    esac
+  fi
+
+  local escape_key=$(get_escape_key_display)
+
+  # Wait for QEMU SPICE listener to be ready
+  MAX_WAIT=30
+  ELAPSED=0
+  SPICE_READY=false
+
+  while [[ "$ELAPSED" -lt "$MAX_WAIT" ]]; do
+    # Check socket and fix permissions if needed
+    if sudo -n test -S "$SPICE_SOCKET_PATH" 2>/dev/null; then
+      sudo -n chmod 660 "$SPICE_SOCKET_PATH" 2>/dev/null || true
+      sudo -n chgrp kvm "$SPICE_SOCKET_PATH" 2>/dev/null || true
+    fi
+
+    if timeout 1 env SOCKET_PATH="$SPICE_SOCKET_PATH" python3 -c "import socket, os; s=socket.socket(socket.AF_UNIX); s.connect(os.environ['SOCKET_PATH'])" 2>/dev/null; then
+      SPICE_READY=true
+      break
+    fi
+    sleep 2
+    ELAPSED=$((ELAPSED + 2))
+  done
+
+  if [[ "$SPICE_READY" != true ]]; then
+    msg_error "SPICE listener not ready after ${MAX_WAIT}s"
+    echo "   Try RDP instead: omarchy-windows-vm launch"
+    exit 1
+  fi
+
+  echo ""
+  echo "Connecting to Windows VM via Looking Glass..."
+  echo ""
+  echo "  $escape_key         - Release mouse/keyboard (hold for info menu)"
+  echo "  $escape_key + F     - Toggle fullscreen (or SUPER + F)"
+  echo "  $escape_key + Q     - Quit Looking Glass"
+  echo ""
+  echo "Press Ctrl+C to return to shell (Looking Glass will keep running)"
+  echo ""
+  sleep 3
+
+  # Launch Looking Glass client in background (hide logs, immune to Ctrl+C)
+  local lg_args=""
+
+  if [[ "$USE_SG_KVM" == true ]]; then
+    # User needs temporary kvm group access - run through sg kvm
+    sg kvm -c "setsid uwsm-app -- looking-glass-client $lg_args >/dev/null 2>&1" &
+    LG_PID=$!
+  else
+    # Normal launch (user has direct access to /dev/kvmfr0)
+    setsid uwsm-app -- looking-glass-client $lg_args >/dev/null 2>&1 &
+    LG_PID=$!
+  fi
+
+  # Wait for Looking Glass to close (blocks here)
+  wait $LG_PID
+  LG_EXIT=$?
+
+  # After Looking Glass closes
+  if [[ "$LG_EXIT" -eq 0 ]] || [[ "$LG_EXIT" -eq 255 ]] || [[ "$LG_EXIT" -eq 130 ]]; then
+    if [[ "$KEEP_ALIVE" == false ]]; then
+      echo ""
+      echo "Looking Glass session closed. Stopping Windows VM..."
+      docker-compose -f "$COMPOSE_FILE" stop
+      echo "VM stopped. Restart: omarchy-windows-vm launch --lg"
+    else
+      echo ""
+      echo "Looking Glass session closed. VM still running."
+      echo "To stop: omarchy-windows-vm stop"
+    fi
+  else
+    echo ""
+    msg_error "Looking Glass error (code: $LG_EXIT)"
+    echo "   Try RDP instead: omarchy-windows-vm launch"
+    exit 1
+  fi
+}
+
+launch_after_install() {
+  local USERNAME="$1"
+  local PASSWORD="$2"
+  local USE_LG="${3:-false}"
+
+  if [[ "$USE_LG" == true ]]; then
+    if ! command -v looking-glass-client &>/dev/null; then
+      msg_warning "Looking Glass not installed - run: omarchy-looking-glass-install"
+      return
+    fi
+    if [[ ! -e /dev/kvmfr0 ]]; then
+      msg_warning "KVMFR not ready - reboot required after Looking Glass installation"
+      return
+    fi
+
+    # Wait 30s for Windows post-install configuration, then launch Looking Glass
+    echo ""
+    printf "Waiting for Windows to finish configuration"
+    local spice_wait=0
+    local spice_ready=false
+    while [[ "$spice_wait" -lt 10 ]]; do
+      sleep 3
+      spice_wait=$((spice_wait + 1))
+      printf "."
+
+      # Fix permissions if socket exists
+      if sudo -n test -S "$SPICE_SOCKET_PATH" 2>/dev/null; then
+        sudo -n chmod 660 "$SPICE_SOCKET_PATH" 2>/dev/null || true
+        sudo -n chgrp kvm "$SPICE_SOCKET_PATH" 2>/dev/null || true
+      fi
+    done
+    echo ""
+
+    # Verify socket accepts connections
+    if timeout 1 env SOCKET_PATH="$SPICE_SOCKET_PATH" python3 -c "import socket, os; s=socket.socket(socket.AF_UNIX); s.connect(os.environ['SOCKET_PATH'])" 2>/dev/null; then
+      spice_ready=true
+    fi
+
+    if [[ "$spice_ready" != true ]]; then
+      msg_warning "SPICE not ready - try later: omarchy-windows-vm launch --lg"
+      return
+    fi
+
+    local escape_key=$(get_escape_key_display)
+    echo ""
+    echo "Connecting to Windows VM via Looking Glass..."
+    echo ""
+    echo "  $escape_key         - Release mouse/keyboard (hold for info menu)"
+    echo "  $escape_key + F     - Toggle fullscreen (or SUPER + F)"
+    echo "  $escape_key + Q     - Quit Looking Glass"
+    echo ""
+
+    # Launch Looking Glass in background (windowed mode)
+    local use_sg_kvm=false
+    if [[ ! -r /dev/kvmfr0 ]]; then
+      ensure_user_in_kvm_group
+      local kvm_status=$?
+      [[ "$kvm_status" -le 1 ]] && use_sg_kvm=true
+    fi
+
+    local lg_args="-F win:fullScreen=no"
+    if [[ "$use_sg_kvm" == true ]]; then
+      sg kvm -c "setsid uwsm-app -- looking-glass-client $lg_args >/dev/null 2>&1" &
+    else
+      setsid uwsm-app -- looking-glass-client $lg_args >/dev/null 2>&1 &
+    fi
+
+    sleep 3
+    if pgrep -x looking-glass-c >/dev/null 2>&1; then
+      msg_success "Looking Glass started (windowed mode)"
+    else
+      msg_warning "Looking Glass may not have started - try: omarchy-windows-vm launch --lg"
+    fi
+  else
+    # RDP: wait briefly then connect
+    echo ""
+    printf "Connecting via RDP"
+    for _ in {1..3}; do sleep 1; printf "."; done
+    echo ""
+    connect_rdp "$USERNAME" "$PASSWORD" true
+  fi
+}
+
+monitor_installation_progress() {
+  local USERNAME="$1"
+  local PASSWORD="$2"
+  local IS_FRESH_INSTALL="${3:-true}"
+  local LG_ENABLED="${4:-false}"
+  local VM_DISK="$HOME/.windows/data.img"
+  local COMPLETION_MARKER="$HOME/Windows/installation-complete.txt"
+  local INSTALL_LOG="$HOME/Windows/install-log.txt"
+  local START_TIME=$(date +%s)
+  local LAST_DISPLAY_TIME=0
+  local LAST_LOG_CHECK=0
+  local DISPLAY_INTERVAL=60
+  local LOG_CHECK_INTERVAL=5
+  local MARKER_CHECK_INTERVAL=5
+  local TIMEOUT=3600
+  local MARKER_DETECTED=false
+  local BOOT_COUNT=0
+  local SEEN_STAGES=""
+  local LAST_PROGRESS=-1
+  local DOWNLOADING=false
+
+  # Stage timing tracking
+  local DOWNLOAD_START_TIME=0
+  local EXTRACT_START_TIME=0
+  local OEM_START_TIME=0
+  local BUILD_START_TIME=0
+  local DISK_START_TIME=0
+  local BOOT_START_TIME=0
+  local WINDOWS_START_TIME=0
+
+  rm -f "$COMPLETION_MARKER" "$INSTALL_LOG" 2>/dev/null
+
+  show_installation_header "$IS_FRESH_INSTALL"
+
+  while true; do
+    # Calculate elapsed time and format timestamp
+    local CURRENT_TIME=$(date +%s)
+    local ELAPSED=$((CURRENT_TIME - START_TIME))
+    local ELAPSED_MIN=$((ELAPSED / 60))
+    local ELAPSED_SEC=$((ELAPSED % 60))
+    local TIME_PREFIX=$(printf "[%s | +%dm %02ds]" "$(date +%H:%M:%S)" "$ELAPSED_MIN" "$ELAPSED_SEC")
+
+    # Parse Docker logs for installation stages (only during fresh install)
+    if [[ "$IS_FRESH_INSTALL" == "true" ]] && [[ "$((CURRENT_TIME - LAST_LOG_CHECK))" -ge "$LOG_CHECK_INTERVAL" ]]; then
+      LAST_LOG_CHECK=$CURRENT_TIME
+
+      # Check if container exists and is running
+      if ! docker inspect omarchy-windows &>/dev/null; then
+        # Container doesn't exist yet, skip log parsing this iteration
+        sleep "$MARKER_CHECK_INTERVAL"
+        continue
+      fi
+
+      # Check if container crashed during installation
+      local CONTAINER_STATUS=$(docker ps -a --filter "name=omarchy-windows" --format "{{.Status}}" 2>/dev/null)
+      if [[ "$CONTAINER_STATUS" =~ ^Exited ]]; then
+        msg_error "VM crashed during installation"
+        echo "  Check logs: docker logs omarchy-windows"
+        return 1
+      fi
+
+      # Get last 500 lines from Docker logs (covers full download cycle + previous stages)
+      local DOCKER_LOGS=$(docker logs --tail 500 omarchy-windows 2>&1)
+
+      # Check for key stages (only show each once)
+      if [[ ! "$SEEN_STAGES" =~ "downloading" ]] && echo "$DOCKER_LOGS" | grep -q "Downloading Windows 11"; then
+        printf "%s Downloading Windows 11 image...\n" "$TIME_PREFIX"
+        SEEN_STAGES="${SEEN_STAGES}downloading "
+        DOWNLOADING=true
+        DOWNLOAD_START_TIME=$CURRENT_TIME
+      fi
+
+      # Show download progress while downloading
+      if [[ "$DOWNLOADING" == true ]] && [[ ! "$SEEN_STAGES" =~ "download_complete" ]]; then
+        # Extract latest progress % from download lines (format: "65536K .... 1% 97.5M 1m43s")
+        local PROGRESS=$(echo "$DOCKER_LOGS" | grep -oP '\s+\K\d+(?=%)' | tail -1)
+        if [[ -n "$PROGRESS" ]] && [[ "$PROGRESS" != "$LAST_PROGRESS" ]]; then
+          # Extract download speed (e.g., "97.5M" from "1% 97.5M 1m43s")
+          local SPEED=$(echo "$DOCKER_LOGS" | grep -oP '\d+%\s+\K[\d.]+[KMG](?=\s)' | tail -1)
+          [[ -z "$SPEED" ]] && SPEED="--"
+
+          # Extract ETA (e.g., "1m43s", "43s", "2m", "1h20m")
+          local ETA=$(echo "$DOCKER_LOGS" | grep -oP '\d+%\s+[\d.]+[KMG]\s+\K[\dhms]+' | tail -1)
+          local ETA_DISPLAY=""
+          if [[ -n "$ETA" ]]; then
+            ETA_DISPLAY=" ~$ETA remaining"
+          fi
+
+          # Draw progress bar
+          local PROGRESS_BAR=$(draw_progress_bar "$PROGRESS")
+
+          # Use \r to update same line (carriage return without newline)
+          # Clear line with spaces to prevent artifacts from previous longer output
+          printf "\r%-100s\r" ""
+          printf "%s Downloading: %s %d%% (%s/s)%s" "$TIME_PREFIX" "$PROGRESS_BAR" "$PROGRESS" "$SPEED" "$ETA_DISPLAY"
+          LAST_PROGRESS=$PROGRESS
+        fi
+      fi
+
+      if [[ ! "$SEEN_STAGES" =~ "download_complete" ]] && echo "$DOCKER_LOGS" | grep -q "100%.*=.*s$"; then
+        # Print newline to finish progress line, then completion message
+        [[ "$DOWNLOADING" == true ]] && echo ""
+        printf "%s Download complete [OK]\n" "$TIME_PREFIX"
+        SEEN_STAGES="${SEEN_STAGES}download_complete "
+        DOWNLOADING=false
+      fi
+
+      if [[ ! "$SEEN_STAGES" =~ "extracting" ]] && echo "$DOCKER_LOGS" | grep -q "Extracting Windows"; then
+        printf "%s Extracting Windows image...\n" "$TIME_PREFIX"
+        SEEN_STAGES="${SEEN_STAGES}extracting "
+        EXTRACT_START_TIME=$CURRENT_TIME
+      fi
+
+      if [[ ! "$SEEN_STAGES" =~ "oem" ]] && echo "$DOCKER_LOGS" | grep -q "Adding OEM folder"; then
+        if [[ "$EXTRACT_START_TIME" -gt 0 ]]; then
+          printf "%s Extracting complete [OK]\n" "$TIME_PREFIX"
+        fi
+        printf "%s Adding OEM setup (Looking Glass + SPICE Guest Tools)...\n" "$TIME_PREFIX"
+        SEEN_STAGES="${SEEN_STAGES}oem "
+        OEM_START_TIME=$CURRENT_TIME
+      fi
+
+      if [[ ! "$SEEN_STAGES" =~ "building" ]] && echo "$DOCKER_LOGS" | grep -q "Building Windows.*image"; then
+        if [[ "$OEM_START_TIME" -gt 0 ]]; then
+          printf "%s OEM setup complete [OK]\n" "$TIME_PREFIX"
+        fi
+        printf "%s Building Windows image...\n" "$TIME_PREFIX"
+        SEEN_STAGES="${SEEN_STAGES}building "
+        BUILD_START_TIME=$CURRENT_TIME
+      fi
+
+      if [[ ! "$SEEN_STAGES" =~ "disk_created" ]] && echo "$DOCKER_LOGS" | grep -q "Creating a.*growable disk image"; then
+        if [[ "$BUILD_START_TIME" -gt 0 ]]; then
+          printf "%s Building complete [OK]\n" "$TIME_PREFIX"
+        fi
+        printf "%s Creating virtual disk...\n" "$TIME_PREFIX"
+        SEEN_STAGES="${SEEN_STAGES}disk_created "
+        DISK_START_TIME=$CURRENT_TIME
+      fi
+
+      if [[ ! "$SEEN_STAGES" =~ "booting" ]] && echo "$DOCKER_LOGS" | grep -q "Booting Windows using QEMU"; then
+        if [[ "$DISK_START_TIME" -gt 0 ]]; then
+          printf "%s Disk creation complete [OK]\n" "$TIME_PREFIX"
+        fi
+        printf "%s Booting Windows...\n" "$TIME_PREFIX"
+        SEEN_STAGES="${SEEN_STAGES}booting "
+        BOOT_START_TIME=$CURRENT_TIME
+      fi
+
+      if [[ ! "$SEEN_STAGES" =~ "started" ]] && echo "$DOCKER_LOGS" | grep -q "Windows started successfully"; then
+        if [[ "$BOOT_START_TIME" -gt 0 ]]; then
+          printf "%s Boot complete [OK]\n" "$TIME_PREFIX"
+        fi
+        printf "%s Windows installation started\n" "$TIME_PREFIX"
+        SEEN_STAGES="${SEEN_STAGES}started "
+        WINDOWS_START_TIME=$CURRENT_TIME
+      fi
+
+      # Count Windows Boot Manager occurrences (reboots during setup)
+      # Note: Each reboot shows "loading" AND "starting" - count only "loading" to avoid duplicates
+      local NEW_BOOT_COUNT
+      NEW_BOOT_COUNT=$(echo "$DOCKER_LOGS" | grep -c "BdsDxe: loading Boot.*Windows Boot Manager" 2>/dev/null) || NEW_BOOT_COUNT=0
+      # Ensure clean number (remove any whitespace/newlines)
+      NEW_BOOT_COUNT=$(echo "$NEW_BOOT_COUNT" | tr -d '[:space:]')
+      NEW_BOOT_COUNT=${NEW_BOOT_COUNT:-0}
+      if [[ "$NEW_BOOT_COUNT" -gt "$BOOT_COUNT" ]] && [[ "$NEW_BOOT_COUNT" -gt 1 ]]; then
+        # Show each reboot increment (in case we missed a check cycle)
+        for ((i = $((BOOT_COUNT + 1)); i <= NEW_BOOT_COUNT; i++)); do
+          if [[ "$i" -gt 1 ]]; then
+            printf "%s Windows setup reboot #%d\n" "$TIME_PREFIX" "$((i - 1))"
+          fi
+        done
+        BOOT_COUNT=$NEW_BOOT_COUNT
+      fi
+    fi
+
+    # Display storage size every minute (only after disk is created)
+    if [[ "$SEEN_STAGES" =~ "disk_created" ]]; then
+      if [[ "$((CURRENT_TIME - LAST_DISPLAY_TIME))" -ge "$DISPLAY_INTERVAL" ]] || [[ "$LAST_DISPLAY_TIME" -eq 0 ]]; then
+        LAST_DISPLAY_TIME=$CURRENT_TIME
+        show_disk_usage "$VM_DISK" "$TIME_PREFIX"
+      fi
+    fi
+
+    # Check for OEM completion marker (created by Windows after installation)
+    if [[ "$MARKER_DETECTED" == false ]]; then
+      if [[ -f "$COMPLETION_MARKER" ]]; then
+        MARKER_DETECTED=true
+        handle_installation_marker "$COMPLETION_MARKER" "$TIME_PREFIX"
+      else
+        # Check if container crashed while waiting for marker
+        local CONTAINER_STATUS=$(docker ps -a --filter "name=omarchy-windows" --format "{{.Status}}" 2>/dev/null)
+        if [[ "$CONTAINER_STATUS" =~ ^Exited ]]; then
+          msg_error "VM crashed during installation"
+          echo "  Check logs: docker logs omarchy-windows"
+          return 1
+        fi
+        sleep $MARKER_CHECK_INTERVAL
+        continue
+      fi
+    fi
+
+    if [[ "$MARKER_DETECTED" == true ]]; then
+      show_installation_summary "$ELAPSED" "$USERNAME" "$PASSWORD" "$LG_ENABLED" \
+        "$DOWNLOAD_START_TIME" "$EXTRACT_START_TIME" "$OEM_START_TIME" \
+        "$BUILD_START_TIME" "$DISK_START_TIME" "$BOOT_START_TIME" \
+        "$WINDOWS_START_TIME" "$CURRENT_TIME" "$IS_FRESH_INSTALL"
+      launch_after_install "$USERNAME" "$PASSWORD" "$LG_ENABLED" "$IS_FRESH_INSTALL"
+      break
+    fi
+
+    if [[ "$ELAPSED" -ge "$TIMEOUT" ]]; then
+      msg_warning "Monitoring timeout - VM still running"
+      echo "   Check: http://127.0.0.1:8006 or omarchy-windows-vm launch"
+      break
+    fi
+  done
+}
+
+# Build dockurr/windows:latest with SPICE support
+# SPICE module (qemu-system-modules-spice) was rejected from upstream
+# See: https://github.com/dockur/windows/pull/1567
+build_dockurr_windows_with_spice() {
+  local build_dir="/tmp/dockurr-windows-spice-$$"
+
+  # Cleanup on exit (success, failure, or Ctrl+C)
+  trap "rm -rf '$build_dir' 2>/dev/null || true" EXIT INT TERM
+
+  msg_info "Building Docker image with SPICE support..."
+
+  # Clone dockur/windows repository
+  if ! git clone --quiet --depth 1 https://github.com/dockur/windows.git "$build_dir" 2>/dev/null; then
+    msg_error "Failed to clone repository (check internet)"
+    return 1
+  fi
+
+  cd "$build_dir" || return 1
+
+  # Modify Dockerfile to add SPICE support (if not already present)
+  if ! grep -q 'qemu-system-modules-spice' Dockerfile; then
+    if ! sed -i 's/libarchive-tools && \\/libarchive-tools \\\n        qemu-system-modules-spice \&\& \\/' Dockerfile; then
+      msg_error "Failed to patch Dockerfile"
+      return 1
+    fi
+  fi
+
+  local DOCKER_BUILD_LOG="/tmp/docker-build-$(date +%Y%m%d-%H%M%S).log"
+  if ! run_with_spinner "   Building Docker image..." bash -c 'docker build -t dockurr/windows:latest . >"$1" 2>&1' _ "$DOCKER_BUILD_LOG"; then
+    msg_error "Docker build failed (log: $DOCKER_BUILD_LOG)"
+    return 1
+  fi
+
+  msg_success "Docker image built with SPICE support"
+  return 0
+}
+
+# Ensure dockurr/windows:latest has SPICE support
+# Checks if image exists and has qemu-system-modules-spice
+# Rebuilds if missing or lacks SPICE
+ensure_dockurr_windows_with_spice() {
+  # Check Docker daemon is running
+  if ! docker info &>/dev/null; then
+    msg_error "Docker daemon is not running"
+    echo "   Start: sudo systemctl start docker"
+    return 1
+  fi
+
+  # Check if image exists locally with SPICE
+  if docker image inspect dockurr/windows:latest &>/dev/null; then
+    if docker history --no-trunc dockurr/windows:latest 2>/dev/null | grep -q 'qemu-system-modules-spice'; then
+      msg_success "Docker image ready (SPICE support detected)"
+      return 0
+    fi
+    # Image exists but lacks SPICE - remove it
+    docker rmi dockurr/windows:latest 2>/dev/null || true
+  fi
+
+  # Build image with SPICE
+  if ! build_dockurr_windows_with_spice; then
+    msg_error "Failed to build Docker image with SPICE support"
+    return 1
+  fi
+
+  return 0
+}
+
+install_windows() {
+  # Set up trap to handle Ctrl+C
+  trap "echo ''; echo 'Installation cancelled by user'; exit 1" INT
+
+  # Request sudo access upfront (avoids password prompt during installation)
+  if ! sudo -v 2>/dev/null; then
+    msg_error "sudo access required for installation"
+    exit 1
+  fi
+
+  # Initialize previous config variables
+  PREVIOUS_TPM_ENABLED=""
+
+  # Handle existing installation - fresh or quick reinstall
+  if [[ -f "$COMPOSE_FILE" ]] || [[ -d "$HOME/.windows" ]]; then
+    # Read previous configuration before showing reinstall choice
+    PREVIOUS_RAM=""
+    PREVIOUS_CPU=""
+    PREVIOUS_DISK=""
+    PREVIOUS_USERNAME=""
+    PREVIOUS_PASSWORD=""
+    PREVIOUS_LG_ENABLED=false
+    PREVIOUS_GPU_ENABLED=false
+    PREVIOUS_TPM_ENABLED=false
+    PREVIOUS_IVSHMEM_SIZE=""
+
+    if [[ -f "$COMPOSE_FILE" ]]; then
+      # Extract values from docker-compose.yml
+      PREVIOUS_RAM=$(grep '^\s*RAM_SIZE:' "$COMPOSE_FILE" | sed 's/.*RAM_SIZE: "\(.*\)".*/\1/' | tr -d '"')
+      PREVIOUS_CPU=$(grep '^\s*CPU_CORES:' "$COMPOSE_FILE" | sed 's/.*CPU_CORES: "\(.*\)".*/\1/' | tr -d '"')
+      PREVIOUS_DISK=$(grep '^\s*DISK_SIZE:' "$COMPOSE_FILE" | sed 's/.*DISK_SIZE: "\(.*\)".*/\1/' | tr -d '"')
+      PREVIOUS_USERNAME=$(grep '^\s*USERNAME:' "$COMPOSE_FILE" | sed 's/.*USERNAME: "\(.*\)".*/\1/' | tr -d '"')
+      PREVIOUS_PASSWORD=$(grep '^\s*PASSWORD:' "$COMPOSE_FILE" | sed 's/.*PASSWORD: "\(.*\)".*/\1/' | tr -d '"')
+
+      # Check Looking Glass (ivshmem-plain in ARGUMENTS) and extract IVSHMEM size
+      if grep -q 'ivshmem-plain' "$COMPOSE_FILE"; then
+        PREVIOUS_LG_ENABLED=true
+        PREVIOUS_IVSHMEM_SIZE=$(grep -oP 'size=\K[0-9]+' "$COMPOSE_FILE" | head -1)
+        [[ -z "$PREVIOUS_IVSHMEM_SIZE" ]] && PREVIOUS_IVSHMEM_SIZE=64
+      fi
+
+      # Check GPU passthrough (vfio-pci in ARGUMENTS)
+      if grep -q 'vfio-pci' "$COMPOSE_FILE"; then
+        PREVIOUS_GPU_ENABLED=true
+      fi
+
+      # Check TPM (TPM: "Y" in environment)
+      if grep -q 'TPM:.*Y' "$COMPOSE_FILE"; then
+        PREVIOUS_TPM_ENABLED=true
+      fi
+    fi
+
+    msg_warning "Previous Windows VM installation detected"
+    echo ""
+    echo "Found:"
+    [[ -f "$COMPOSE_FILE" ]] && echo "  • Configuration: $COMPOSE_FILE"
+    [[ -d "$HOME/.windows" ]] && echo "  • VM disk: $HOME/.windows/"
+
+    # Show previous configuration if available
+    if [[ -n "$PREVIOUS_RAM" ]]; then
+      echo ""
+      echo "Previous configuration:"
+      echo "  RAM:              $PREVIOUS_RAM"
+      echo "  CPU:              $PREVIOUS_CPU cores"
+      echo "  Disk:             $PREVIOUS_DISK"
+      echo "  Username:         $PREVIOUS_USERNAME"
+      echo "  GPU Passthrough:  $([[ "$PREVIOUS_GPU_ENABLED" == true ]] && echo "Enabled" || echo "Disabled")"
+      echo "  Looking Glass:    $([[ "$PREVIOUS_LG_ENABLED" == true ]] && echo "Enabled" || echo "Disabled")"
+      echo "  TPM/Secure Boot:  $([[ "$PREVIOUS_TPM_ENABLED" == true ]] && echo "Enabled" || echo "Disabled")"
+    fi
+
+    echo ""
+    echo "What would you like to do?"
+
+    REINSTALL_CHOICE=$(gum choose --selected="Quick reinstall (keep VM data, update config)" \
+      "Quick reinstall (keep VM data, update config)" \
+      "Fresh install (delete all data and reinstall)")
+
+    # Check if user cancelled (Ctrl+C returns empty string)
+    if [[ -z "$REINSTALL_CHOICE" ]]; then
+      echo ""
+      echo "Installation cancelled by user"
+      exit 1
+    fi
+
+    if [[ "$REINSTALL_CHOICE" == "Fresh install"* ]]; then
+      echo ""
+      echo "Fresh installation: Removing all previous data..."
+      echo ""
+      echo "This will DELETE:"
+      echo "  ⚠️  VM disk and Windows OS ($HOME/.windows/)"
+      echo "  ⚠️  Configuration files"
+      echo ""
+      echo "This will KEEP:"
+      echo "  ✓  Shared files ($HOME/Windows/) - your data"
+      echo ""
+
+      docker-compose -f "$COMPOSE_FILE" down 2>/dev/null || true
+      rm -f "$COMPOSE_FILE"
+      rm -rf "$HOME/.config/windows"
+
+      if [[ -d "$HOME/.windows" ]]; then
+        echo "  • Removing VM disk..."
+        sudo rm -rf "$HOME/.windows"
+      fi
+
+      [[ -d "$HOME/.config/windows/oem" ]] && rm -rf "$HOME/.config/windows/oem" 2>/dev/null
+      rm -f "$HOME/Windows/installation-complete.txt" 2>/dev/null
+      rm -f "$HOME/.local/share/applications/windows-vm.desktop" "$HOME/.local/share/applications/windows-looking-glass.desktop"
+
+      # Update desktop database after removing old icons
+      if command -v update-desktop-database &>/dev/null; then
+        update-desktop-database "$HOME/.local/share/applications" 2>/dev/null || true
+      fi
+
+      echo ""
+      msg_success "Previous installation completely removed"
+      echo ""
+
+      # Clear previous values to use intelligent defaults for fresh install
+      PREVIOUS_RAM=""
+      PREVIOUS_CPU=""
+      PREVIOUS_DISK=""
+      PREVIOUS_USERNAME=""
+      PREVIOUS_PASSWORD=""
+      PREVIOUS_LG_ENABLED=false
+      PREVIOUS_GPU_ENABLED=false
+      PREVIOUS_TPM_ENABLED=false
+      PREVIOUS_IVSHMEM_SIZE=""
+    else
+      echo ""
+      echo "Quick reinstall: Keeping VM disk, updating configuration..."
+      echo ""
+
+      # Stop VM but keep configuration until user confirms new settings
+      docker-compose -f "$COMPOSE_FILE" down 2>/dev/null || true
+
+      msg_success "VM stopped, configuration preserved (will update after confirmation)"
+      echo ""
+      msg_info "Quick reinstall only updates docker-compose configuration"
+      echo "   Windows installation and all your files remain unchanged"
+      echo "   VM will boot to existing Windows system with new config"
+      echo ""
+
+      # Skip OEM auto-run since Windows is already installed
+      # Mark for later cleanup (after user confirms configuration)
+      SKIP_OEM_AUTORUN=true
+      QUICK_REINSTALL_CLEANUP=true
+    fi
+  fi
+
+  check_prerequisites
+
+  # Install dependencies quietly
+  msg_info "Installing dependencies..."
+  DEPS_LOG="/tmp/omarchy-windows-deps-$$.log"
+
+  # Build dependency list (skip netcat if nc already available - avoids gnu-netcat conflict)
+  local deps="freerdp dmidecode"
+  if ! command -v nc &>/dev/null; then
+    deps="$deps openbsd-netcat"
+  fi
+
+  if ! omarchy-pkg-add $deps > "$DEPS_LOG" 2>&1; then
+    msg_error "Failed to install dependencies"
+    echo ""
+    tail -15 "$DEPS_LOG"
+    rm -f "$DEPS_LOG"
+    exit 1
+  fi
+  rm -f "$DEPS_LOG"
+  msg_success "Dependencies installed"
+
+  configure_sudoers_windows_vm
+
+  mkdir -p "$HOME/.windows"
+  mkdir -p "$HOME/.config/windows"
+
+  # Get system resources
+  TOTAL_RAM=$(free -h | awk 'NR==2 {print $2}')
+  TOTAL_RAM_GB=$(awk 'NR==1 {printf "%d", $2/1024/1024}' /proc/meminfo)
+  TOTAL_CORES=$(nproc)
+
+  # Validate RAM detection (must be positive number)
+  if ! [[ "$TOTAL_RAM_GB" =~ ^[0-9]+$ ]] || [[ "$TOTAL_RAM_GB" -eq 0 ]]; then
+    msg_warning "Could not detect total RAM, using safe default (8GB)"
+    TOTAL_RAM_GB=8
+    TOTAL_RAM="8G"
+  fi
+
+  # Validate TOTAL_RAM display value (Bug #30 fix)
+  if [[ -z "$TOTAL_RAM" ]]; then
+    TOTAL_RAM="${TOTAL_RAM_GB}G"
+  fi
+
+  echo "System resources: $TOTAL_RAM RAM, $TOTAL_CORES CPU cores"
+  echo ""
+
+  RAM_OPTIONS=""
+  for size in 2 4 8 16 32 64; do
+    if [[ "$size" -le "$TOTAL_RAM_GB" ]]; then
+      RAM_OPTIONS="$RAM_OPTIONS ${size}G"
+    fi
+  done
+  RAM_OPTIONS="$RAM_OPTIONS Custom"
+
+  # Use previous RAM if available AND in options list, otherwise calculate intelligent default
+  if [[ -n "$PREVIOUS_RAM" ]] && echo "$RAM_OPTIONS" | grep -q "$PREVIOUS_RAM"; then
+    DEFAULT_RAM="$PREVIOUS_RAM"
+  else
+    # Calculate half of total RAM, find largest value from options that is smaller than half
+    HALF_RAM=$((TOTAL_RAM_GB / 2))
+    DEFAULT_RAM="4G"            # fallback
+    for size in 32 16 8 4 2; do # reversed order (largest to smallest)
+      if [[ "$size" -lt "$HALF_RAM" ]] && [[ "$size" -le "$TOTAL_RAM_GB" ]]; then
+        DEFAULT_RAM="${size}G"
+        break
+      fi
+    done
+  fi
+  SELECTED_RAM=$(echo "$RAM_OPTIONS" | tr ' ' '\n' | gum choose --selected="$DEFAULT_RAM" --header="How much RAM would you like to allocate to Windows VM?")
+
+  # Check if user cancelled
+  if [[ -z "$SELECTED_RAM" ]]; then
+    echo "Installation cancelled by user"
+    exit 1
+  fi
+
+  # Handle Custom RAM option
+  if [[ "$SELECTED_RAM" == "Custom" ]]; then
+    local MAX_RAM_GB=$((TOTAL_RAM_GB - 4))
+    [[ "$MAX_RAM_GB" -lt 2 ]] && MAX_RAM_GB=2
+    while true; do
+      CUSTOM_RAM=$(gum input --placeholder "Enter RAM in GB (2-${MAX_RAM_GB})" --header="Custom RAM size")
+      if [[ -z "$CUSTOM_RAM" ]]; then
+        echo "Installation cancelled by user"
+        exit 1
+      fi
+      if [[ "$CUSTOM_RAM" =~ ^[0-9]+$ ]] && [[ "$CUSTOM_RAM" -ge 2 ]] && [[ "$CUSTOM_RAM" -le "$MAX_RAM_GB" ]]; then
+        SELECTED_RAM="${CUSTOM_RAM}G"
+        break
+      else
+        msg_warning "RAM must be between 2 and ${MAX_RAM_GB} GB"
+      fi
+    done
+  fi
+
+  msg_success "RAM: $SELECTED_RAM"
+
+  # Use previous CPU cores if available, otherwise calculate intelligent default (quarter of total)
+  if [[ -n "$PREVIOUS_CPU" ]]; then
+    DEFAULT_CORES="$PREVIOUS_CPU"
+  else
+    # Calculate quarter of total cores (conservative: leave more for host)
+    DEFAULT_CORES=$((TOTAL_CORES / 4))
+    [[ "$DEFAULT_CORES" -lt 1 ]] && DEFAULT_CORES=1
+  fi
+  SELECTED_CORES=$(gum input --placeholder="Number of CPU cores (1-$TOTAL_CORES)" --value="$DEFAULT_CORES" --header="How many CPU cores would you like to allocate to Windows VM?" --char-limit=2)
+
+  # Check if user cancelled (Ctrl+C in gum input returns empty string)
+  if [[ -z "$SELECTED_CORES" ]]; then
+    echo "Installation cancelled by user"
+    exit 1
+  fi
+
+  if ! [[ "$SELECTED_CORES" =~ ^[0-9]+$ ]] || [[ "$SELECTED_CORES" -lt 1 ]] || [[ "$SELECTED_CORES" -gt "$TOTAL_CORES" ]]; then
+    echo "Invalid input. Using default: 2 cores"
+    SELECTED_CORES=2
+  fi
+
+  msg_success "CPU: $SELECTED_CORES cores"
+
+  AVAILABLE_SPACE=$(df "$HOME" | awk 'NR==2 {print int($4/1024/1024)}')
+  MAX_DISK_GB=$((AVAILABLE_SPACE - 10)) # Leave 10GB for Windows image
+
+  # Check if we have enough space for minimum
+  if [[ "$MAX_DISK_GB" -lt 32 ]]; then
+    msg_error "Insufficient disk space for Windows VM!"
+    echo "   Available: ${AVAILABLE_SPACE}GB"
+    echo "   Minimum required: 42GB (32GB disk + 10GB for Windows image)"
+    exit 1
+  fi
+
+  DISK_OPTIONS=""
+  for size in 32 64 128 256 512 1024 2048 4096 8192; do
+    if [[ "$size" -le "$MAX_DISK_GB" ]]; then
+      DISK_OPTIONS="$DISK_OPTIONS ${size}G"
+    fi
+  done
+  DISK_OPTIONS="$DISK_OPTIONS Custom"
+
+  # Use previous disk if available, otherwise calculate intelligent default (half of max, choose smaller, cap at 256GB)
+  if [[ -n "$PREVIOUS_DISK" ]] && echo "$DISK_OPTIONS" | grep -q "$PREVIOUS_DISK"; then
+    DEFAULT_DISK="$PREVIOUS_DISK"
+  else
+    # Calculate half of max disk space, find largest value smaller than half (max suggestion: 256GB)
+    HALF_DISK=$((MAX_DISK_GB / 2))
+    DEFAULT_DISK="32G"            # fallback
+    for size in 256 128 64 32; do # removed 512, max suggestion is 256GB
+      if [[ "$size" -lt "$HALF_DISK" ]] && [[ "$size" -le "$MAX_DISK_GB" ]]; then
+        DEFAULT_DISK="${size}G"
+        break
+      fi
+    done
+  fi
+
+  SELECTED_DISK=$(echo "$DISK_OPTIONS" | tr ' ' '\n' | gum choose --selected="$DEFAULT_DISK" --header="How much disk space would you like to give Windows VM? (64GB+ recommended)")
+
+  # Check if user cancelled
+  if [[ -z "$SELECTED_DISK" ]]; then
+    echo "Installation cancelled by user"
+    exit 1
+  fi
+
+  # Handle Custom disk option
+  if [[ "$SELECTED_DISK" == "Custom" ]]; then
+    while true; do
+      CUSTOM_DISK=$(gum input --placeholder "Enter size in GB (32-${MAX_DISK_GB})" --header="Custom disk size")
+      if [[ -z "$CUSTOM_DISK" ]]; then
+        echo "Installation cancelled by user"
+        exit 1
+      fi
+      if [[ "$CUSTOM_DISK" =~ ^[0-9]+$ ]] && [[ "$CUSTOM_DISK" -ge 32 ]] && [[ "$CUSTOM_DISK" -le "$MAX_DISK_GB" ]]; then
+        SELECTED_DISK="${CUSTOM_DISK}G"
+        break
+      else
+        msg_warning "Disk size must be between 32 and ${MAX_DISK_GB} GB"
+      fi
+    done
+  fi
+
+  msg_success "Disk: $SELECTED_DISK"
+
+  # Extract just the number for prerequisite check
+  DISK_SIZE_NUM=$(echo "$SELECTED_DISK" | sed 's/G//')
+
+  # Re-check prerequisites with selected disk size
+  check_prerequisites "$DISK_SIZE_NUM"
+
+  # Prompt for username and password
+  # Use previous username if available, otherwise show default
+  if [[ -n "$PREVIOUS_USERNAME" ]]; then
+    USERNAME=$(gum input --placeholder="Username (Press enter to use previous: $PREVIOUS_USERNAME)" --value="$PREVIOUS_USERNAME" --header="Enter Windows username:")
+    if [[ -z "$USERNAME" ]]; then
+      USERNAME="$PREVIOUS_USERNAME"
+    fi
+  else
+    USERNAME=$(gum input --placeholder="Username (Press enter to use default: docker)" --header="Enter Windows username:")
+    if [[ -z "$USERNAME" ]]; then
+      USERNAME="docker"
+    fi
+  fi
+
+  # Validate username (no quotes or special YAML chars)
+  if [[ "$USERNAME" =~ [\"\'\`\$\\] ]]; then
+    msg_error "Username cannot contain quotes, backticks, dollar signs, or backslashes"
+    echo "   These characters would break the configuration file"
+    exit 1
+  fi
+
+  # Password prompt - different logic for Quick reinstall vs Fresh install
+  if [[ -n "$PREVIOUS_USERNAME" ]]; then
+    # Quick reinstall - ask if user wants to change password
+    echo ""
+    if gum confirm --default=false "Change Windows password in docker-compose configuration?"; then
+      echo ""
+      msg_warning "Important: This only updates docker-compose.yml configuration"
+      echo "   Password in Windows VM remains unchanged"
+      echo "   To match: Change password in Windows first, then update here"
+      echo ""
+
+      PASSWORD=$(gum input --placeholder="Enter new password for docker-compose" --password --header="New Windows password:")
+      if [[ -z "$PASSWORD" ]]; then
+        echo "Password cannot be empty"
+        exit 1
+      fi
+      PASSWORD_DISPLAY="(changed)"
+    else
+      # Keep previous password (already extracted before COMPOSE_FILE was deleted)
+      if [[ -z "$PREVIOUS_PASSWORD" ]]; then
+        echo ""
+        msg_warning "Could not extract previous password from docker-compose.yml"
+        echo "   Please enter password for configuration:"
+        echo ""
+        PASSWORD=$(gum input --placeholder="Enter password" --password --header="Windows password:")
+        if [[ -z "$PASSWORD" ]]; then
+          echo "Password cannot be empty"
+          exit 1
+        fi
+        PASSWORD_DISPLAY="(re-entered)"
+      else
+        PASSWORD="$PREVIOUS_PASSWORD"
+        PASSWORD_DISPLAY="(kept previous)"
+      fi
+    fi
+  else
+    # Fresh install - prompt for password
+    PASSWORD=$(gum input --placeholder="Password (Press enter to use default: admin)" --password --header="Enter Windows password:")
+    if [[ -z "$PASSWORD" ]]; then
+      PASSWORD="admin"
+      PASSWORD_DISPLAY="(default)"
+    else
+      PASSWORD_DISPLAY="(user-defined)"
+    fi
+  fi
+
+  # Validate password (no quotes or special YAML chars)
+  if [[ "$PASSWORD" =~ [\"\'\`\$\\] ]]; then
+    msg_error "Password cannot contain quotes, backticks, dollar signs, or backslashes"
+    echo "   These characters would break the configuration file"
+    exit 1
+  fi
+
+  msg_success "Credentials: $USERNAME"
+  mkdir -p "$HOME/Windows"
+
+  # TPM & Secure Boot (optional, enables BitLocker/Windows Hello)
+  local TPM_DEFAULT=true
+  [[ "$PREVIOUS_TPM_ENABLED" == false ]] && TPM_DEFAULT=false
+
+  if gum confirm --default="$TPM_DEFAULT" "Enable TPM & Secure Boot?"; then
+    TPM_ENABLED=true
+    msg_success "Security: TPM + Secure Boot"
+  else
+    TPM_ENABLED=false
+    msg_info "Security: Disabled"
+  fi
+
+  # GPU detection and configuration prompts (decision only, no execution yet)
+  HAS_DEDICATED_GPU=false
+  GPU_INFO=""
+  GPU_PASSTHROUGH_READY=false
+  GPU_PASSTHROUGH_ENABLED=false
+  GPU_PASSTHROUGH_NEEDS_SETUP=false
+
+  # Looking Glass requires dedicated GPU (NVIDIA/AMD/Intel Arc), not integrated
+  if command -v lspci &>/dev/null; then
+    GPU_INFO=$(lspci | grep -iE 'VGA compatible|3D controller|Display controller' | grep -E 'NVIDIA|AMD|Arc' | grep -vE 'Intel.*(UHD|HD Graphics [0-9]{3,4}$)' | head -1)
+    if [[ -n "$GPU_INFO" ]]; then
+      HAS_DEDICATED_GPU=true
+
+      # Extract clean GPU name (e.g., "NVIDIA RTX 5070" instead of full lspci output)
+      # Use last bracket for AMD GPUs with multiple brackets: [AMD/ATI] ... [Radeon RX 7900 XT]
+      GPU_NAME=$(echo "$GPU_INFO" | grep -oP '\[[^\]]+\]' | tail -1 | tr -d '[]')
+
+      # Add vendor prefix and remove redundant prefixes
+      if [[ -n "$GPU_NAME" ]]; then
+        if [[ "$GPU_INFO" =~ NVIDIA ]]; then
+          GPU_NAME="${GPU_NAME#GeForce }"
+          GPU_NAME="NVIDIA $GPU_NAME"
+        elif [[ "$GPU_INFO" =~ AMD|ATI ]]; then
+          GPU_NAME="${GPU_NAME#Radeon }"
+          GPU_NAME="AMD $GPU_NAME"
+        elif [[ "$GPU_INFO" =~ Arc ]]; then
+          GPU_NAME="Intel $GPU_NAME"
+        fi
+      else
+        # Fallback if no brackets found (unlikely but safe)
+        GPU_NAME="$GPU_INFO"
+      fi
+
+      msg_success "Dedicated GPU detected: $GPU_NAME"
+    else
+      msg_warning "No dedicated GPU detected (NVIDIA/AMD/Arc required for Looking Glass)"
+    fi
+  else
+    msg_warning "lspci not available - cannot detect GPU"
+  fi
+
+  # Check GPU passthrough configuration
+  if [[ "$HAS_DEDICATED_GPU" == true ]]; then
+    if command -v omarchy-gpu-passthrough-info &>/dev/null; then
+      # Check if GPU passthrough is already configured
+      if omarchy-gpu-passthrough-info is-configured &>/dev/null; then
+        msg_success "GPU passthrough ready"
+
+        if gum confirm "Use GPU passthrough for this VM?"; then
+          GPU_PASSTHROUGH_READY=true
+          GPU_PASSTHROUGH_ENABLED=true
+
+          GPU_PCI_ADDR=""
+          GPU_IOMMU_GROUP=""
+          GPU_IOMMU_DEVICES=""
+          GPU_CONFIG=$(omarchy-gpu-passthrough-info get-docker-config 2>/dev/null)
+          if [[ -n "$GPU_CONFIG" ]]; then
+            read -r GPU_PCI_ADDR GPU_IOMMU_GROUP GPU_IOMMU_DEVICES <<<"$GPU_CONFIG"
+          fi
+        else
+          GPU_PASSTHROUGH_READY=false
+          GPU_PASSTHROUGH_ENABLED=false
+          msg_info "VM will use CPU-only graphics"
+        fi
+      else
+        msg_warning "GPU passthrough not configured"
+        echo "  Benefits: Native GPU performance, ray tracing, Looking Glass"
+
+        if gum confirm "Configure GPU passthrough now? (requires reboot)"; then
+          GPU_PASSTHROUGH_NEEDS_SETUP=true
+          GPU_PASSTHROUGH_ENABLED=true
+        else
+          msg_info "Skipping - configure later with: omarchy-gpu-passthrough setup"
+        fi
+      fi
+    else
+      msg_warning "omarchy-gpu-passthrough not found"
+    fi
+  fi
+
+  # Looking Glass configuration
+  LG_ENABLED=false
+  LG_NEEDS_INSTALL=false
+
+  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]]; then
+    if is_looking_glass_ready; then
+      msg_success "Looking Glass ready"
+      LG_ENABLED=true
+    else
+      if gum confirm "Do you have a display connected to GPU?"; then
+        if gum confirm "Enable Looking Glass?"; then
+          LG_ENABLED=true
+          LG_NEEDS_INSTALL=true
+
+          echo ""
+          echo "Select Looking Glass shared memory size:"
+          echo ""
+          echo "  Resolution     Minimum   Recommended"
+          echo "  1920×1080      32 MB     64 MB"
+          echo "  2560×1440      64 MB     128 MB"
+          echo "  3840×2160      128 MB    256 MB"
+          echo ""
+          echo "  Higher refresh rate (144Hz+) needs more memory."
+          echo "  If VM fails to start, try smaller size."
+          echo ""
+          echo "  Note: IVSHMEM size controls memory, not resolution."
+          echo ""
+          RESOLUTION_CHOICE=$(gum choose --selected="1080p (64MB) - recommended" \
+            "1080p (32MB) - minimal, low RAM" \
+            "1080p (64MB) - recommended" \
+            "1440p (128MB)" \
+            "4K (256MB)")
+
+          if [[ -z "$RESOLUTION_CHOICE" ]]; then
+            echo ""
+            echo "Installation cancelled by user"
+            exit 0
+          fi
+
+          case "$RESOLUTION_CHOICE" in
+          *32MB*) IVSHMEM_SIZE=32 ;;
+          *64MB*) IVSHMEM_SIZE=64 ;;
+          *128MB*) IVSHMEM_SIZE=128 ;;
+          *256MB*) IVSHMEM_SIZE=256 ;;
+          *) IVSHMEM_SIZE=64 ;;
+          esac
+          export IVSHMEM_SIZE
+          msg_success "IVSHMEM: ${IVSHMEM_SIZE}MB"
+        else
+          msg_info "Skipping - use VNC/RDP instead (add later: omarchy-looking-glass-install)"
+        fi
+      else
+        msg_info "Looking Glass requires display connected to GPU"
+        echo "  Options:"
+        echo "    • Second monitor on GPU"
+        echo "    • Same monitor with 2 cables"
+        echo "    • HDMI dummy plug (~\$5)"
+        echo "  Run: omarchy-looking-glass-install (after connecting display)"
+      fi
+    fi
+  fi
+
+  # Configuration summary
+  echo ""
+  echo "Configuration Summary"
+  echo "  Resources:  $SELECTED_RAM RAM, $SELECTED_CORES cores, $SELECTED_DISK disk"
+  echo "  User:       $USERNAME $PASSWORD_DISPLAY"
+  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]]; then
+    if [[ "$GPU_PASSTHROUGH_NEEDS_SETUP" == true ]]; then
+      echo "  GPU:        Will be configured (reboot required)"
+    else
+      echo "  GPU:        $GPU_NAME (passthrough)"
+    fi
+  else
+    echo "  GPU:        CPU-only (no passthrough)"
+  fi
+  if [[ "$LG_ENABLED" == true ]]; then
+    if [[ "$LG_NEEDS_INSTALL" == true ]]; then
+      echo "  Display:    Looking Glass (will install)"
+    else
+      echo "  Display:    Looking Glass (ready)"
+    fi
+  else
+    echo "  Display:    RDP/VNC"
+  fi
+  if [[ "$TPM_ENABLED" == true ]]; then
+    echo "  Security:   TPM 2.0 + Secure Boot"
+  else
+    echo "  Security:   Disabled"
+  fi
+
+  if [[ "$GPU_PASSTHROUGH_NEEDS_SETUP" == true ]]; then
+    echo ""
+    msg_warning "GPU setup requires reboot - other steps will run after"
+  fi
+
+  if [[ "$LG_ENABLED" == true ]]; then
+    echo ""
+    msg_info "Reminder: Looking Glass needs display connected to GPU"
+  fi
+
+  echo ""
+  echo "Estimated time: 10-30 minutes"
+
+  if ! gum confirm "Proceed with installation?"; then
+    echo ""
+    echo "Installation cancelled by user"
+    echo ""
+    echo "You can restart installation later with: omarchy-windows-vm install"
+    exit 0
+  fi
+  echo ""
+
+  # Execute GPU passthrough setup if needed (may exit with reboot required)
+  if [[ "$GPU_PASSTHROUGH_NEEDS_SETUP" == true ]]; then
+    echo "Configuring GPU passthrough..."
+    echo ""
+
+    if omarchy-gpu-passthrough setup; then
+      msg_success "GPU passthrough configured successfully!"
+      echo ""
+      msg_warning "SYSTEM REBOOT REQUIRED"
+      echo ""
+      echo "Kernel parameters have been configured and require reboot."
+      echo ""
+      echo "After reboot:"
+      echo "   1. Verify GPU passthrough: omarchy-gpu-passthrough info verify"
+      echo "   2. Re-run Windows VM installation: omarchy-windows-vm install"
+      echo ""
+      exit 0
+    else
+      msg_error "GPU passthrough setup failed or was cancelled"
+      echo ""
+
+      if ! gum confirm "Continue installation without GPU passthrough?"; then
+        echo ""
+        echo "Installation cancelled"
+        exit 1
+      fi
+
+      echo ""
+      msg_info "Continuing without GPU passthrough"
+      msg_info "You can configure it later with: omarchy-gpu-passthrough setup"
+      echo ""
+
+      GPU_PASSTHROUGH_ENABLED=false
+      GPU_PASSTHROUGH_NEEDS_SETUP=false
+      LG_ENABLED=false
+      LG_NEEDS_INSTALL=false
+    fi
+  fi
+
+  # Execute Looking Glass installation if needed
+  NEEDS_REBOOT_FOR_LG=false
+  if [[ "$LG_NEEDS_INSTALL" == true ]]; then
+    install_looking_glass_client
+    LG_INSTALL_STATUS=$?
+
+    if [[ "$LG_INSTALL_STATUS" -eq 0 ]]; then
+      msg_success "Looking Glass ready"
+    elif [[ "$LG_INSTALL_STATUS" -eq 1 ]]; then
+      msg_warning "Looking Glass installed - reboot required"
+      NEEDS_REBOOT_FOR_LG=true
+    else
+      msg_error "Looking Glass installation failed"
+      [[ -d "$HOME/.config/windows/oem" ]] && rm -rf "$HOME/.config/windows/oem"
+      if ! gum confirm "Continue without Looking Glass?"; then
+        exit 1
+      fi
+      LG_ENABLED=false
+    fi
+  fi
+
+  # Refresh sudo credentials (interactive wizard may have taken time)
+  # This covers: GPU process detection, system configuration (dmidecode), Docker operations
+  if ! sudo -v 2>/dev/null; then
+    msg_error "sudo access required for system configuration"
+    exit 1
+  fi
+
+  # Start OEM configuration
+  OEM_DIR="$HOME/.config/windows/oem"
+  mkdir -p "$OEM_DIR/wallpaper"
+
+  # Validate and resolve OMARCHY_PATH if set
+  if [[ -n "$OMARCHY_PATH" ]] && [[ -d "$OMARCHY_PATH" ]]; then
+    OMARCHY_PATH=$(realpath "$OMARCHY_PATH" 2>/dev/null)
 
-check_prerequisites() {
-  local DISK_SIZE_GB=${1:-64}
-  local REQUIRED_SPACE=$((DISK_SIZE_GB + 10))  # Add 10GB for Windows ISO and overhead
+    if [[ -d "$OMARCHY_PATH" ]]; then
+      # Copy wallpaper if exists
+      if [[ -f "$OMARCHY_PATH/themes/rose-pine/backgrounds/3-leafy-dawn-omarchy.png" ]]; then
+        cp "$OMARCHY_PATH/themes/rose-pine/backgrounds/3-leafy-dawn-omarchy.png" "$OEM_DIR/wallpaper/omarchy.png"
+      fi
 
-  # Check for KVM support
-  if [ ! -e /dev/kvm ]; then
-    gum style \
-      --border normal \
-      --padding "1 2" \
-      --margin "1" \
-      "❌ KVM virtualization not available!" \
-      "" \
-      "Please enable virtualization in BIOS or run:" \
-      "  sudo modprobe kvm-intel  # for Intel CPUs" \
-      "  sudo modprobe kvm-amd    # for AMD CPUs"
-    exit 1
+      # Get git version
+      if [[ -d "$OMARCHY_PATH/.git" ]]; then
+        SCRIPT_VERSION="$(git -C "$OMARCHY_PATH" rev-parse --short HEAD 2>/dev/null || echo 'unknown')"
+      else
+        SCRIPT_VERSION="unknown"
+      fi
+    else
+      SCRIPT_VERSION="unknown"
+    fi
+  else
+    SCRIPT_VERSION="unknown"
+  fi
+  create_oem_powershell_script "$OEM_DIR" "$SCRIPT_VERSION"
+  create_oem_batch_script "$OEM_DIR"
+
+  # Download Looking Glass + SPICE installers silently (future-proof for quick reinstalls)
+  LG_ZIP="$OEM_DIR/looking-glass-host.zip"
+  LG_INSTALLER="$OEM_DIR/looking-glass-host-setup.exe"
+
+  if [[ ! -f "$LG_INSTALLER" ]]; then
+    if curl -L --max-time 300 --connect-timeout 30 -o "$LG_ZIP" "https://looking-glass.io/artifact/stable/host" 2>/dev/null; then
+      if unzip -q -o "$LG_ZIP" -d "$OEM_DIR" 2>/dev/null; then
+        rm "$LG_ZIP"
+      else
+        msg_warning "Looking Glass extraction failed"
+        echo "   Try manually: unzip $LG_ZIP -d $OEM_DIR"
+        echo "   Or download from: https://looking-glass.io/downloads"
+        rm -f "$LG_ZIP"
+      fi
+    else
+      msg_warning "Looking Glass download failed (check internet connection)"
+      echo "   Download manually: https://looking-glass.io/downloads"
+      echo "   Save to: $OEM_DIR/looking-glass-host-setup.exe"
+    fi
   fi
 
-  # Check disk space
-  AVAILABLE_SPACE=$(df "$HOME" | awk 'NR==2 {print int($4/1024/1024)}')
-  if [ "$AVAILABLE_SPACE" -lt "$REQUIRED_SPACE" ]; then
-    echo "❌ Insufficient disk space!"
-    echo "   Available: ${AVAILABLE_SPACE}GB"
-    echo "   Required: ${REQUIRED_SPACE}GB (${DISK_SIZE_GB}GB disk + 10GB for Windows image)"
-    exit 1
+  SPICE_INSTALLER="$OEM_DIR/spice-guest-tools-setup.exe"
+
+  if [[ ! -f "$SPICE_INSTALLER" ]]; then
+    if ! curl -L --tlsv1.2 --max-time 300 --connect-timeout 30 -o "$SPICE_INSTALLER" "https://www.spice-space.org/download/windows/spice-guest-tools/spice-guest-tools-latest.exe" 2>/dev/null; then
+      msg_warning "SPICE Guest Tools download failed (check internet connection)"
+      echo "   Download manually: https://www.spice-space.org/download/windows/spice-guest-tools/spice-guest-tools-latest.exe"
+      echo "   Save to: $OEM_DIR/spice-guest-tools-setup.exe"
+    fi
   fi
-}
 
-install_windows() {
-  # Set up trap to handle Ctrl+C
-  trap "echo ''; echo 'Installation cancelled by user'; exit 1" INT
+  # Use previous IVSHMEM size for quick reinstall, otherwise default 64
+  IVSHMEM_SIZE=${IVSHMEM_SIZE:-${PREVIOUS_IVSHMEM_SIZE:-64}}
+
+  # Detect GPU passthrough configuration
+  GPU_PASSTHROUGH_ENABLED=false
+  GPU_PCI_ADDR=""
+  GPU_IOMMU_GROUP=""
+  GPU_IOMMU_DEVICES=""
+
+  if [[ "$LG_ENABLED" == true ]] && command -v omarchy-gpu-passthrough-info &>/dev/null; then
+    if omarchy-gpu-passthrough-info is-configured &>/dev/null; then
+      GPU_PASSTHROUGH_ENABLED=true
+      GPU_CONFIG=$(omarchy-gpu-passthrough-info get-docker-config 2>/dev/null)
+      if [[ -n "$GPU_CONFIG" ]]; then
+        # Format: GPU_PCI_ADDR IOMMU_GROUP DEVICE1 DEVICE2 ...
+        read -r GPU_PCI_ADDR GPU_IOMMU_GROUP GPU_IOMMU_DEVICES <<<"$GPU_CONFIG"
+      fi
+    fi
+  fi
 
-  check_prerequisites
+  # Clean up old state files (for Quick reinstall only, after user confirmation)
+  # Note: docker-compose.yml will be overwritten by create_docker_compose_config, no need to delete
+  if [[ "${QUICK_REINSTALL_CLEANUP:-false}" == "true" ]]; then
+    rm -f "$HOME/Windows/installation-complete.txt" 2>/dev/null
+    rm -f "$HOME/.local/share/applications/windows-vm.desktop" "$HOME/.local/share/applications/windows-looking-glass.desktop" 2>/dev/null
 
-  omarchy-pkg-add freerdp openbsd-netcat gum
+    # Update desktop database after removing old icons (new icons will be created shortly)
+    if command -v update-desktop-database &>/dev/null; then
+      update-desktop-database "$HOME/.local/share/applications" 2>/dev/null || true
+    fi
+  fi
 
-  mkdir -p "$HOME/.windows"
-  mkdir -p "$HOME/.config/windows"
+  create_docker_compose_config "$COMPOSE_FILE" "$SELECTED_RAM" "$SELECTED_CORES" "$SELECTED_DISK" \
+    "$USERNAME" "$PASSWORD" "$LG_ENABLED" "$IVSHMEM_SIZE" \
+    "$GPU_PASSTHROUGH_ENABLED" "$GPU_PCI_ADDR" "$GPU_IOMMU_GROUP" "$GPU_IOMMU_DEVICES" \
+    "$TPM_ENABLED"
+
+  msg_success "Configuration saved"
+  echo ""
+  msg_warning "Password stored in plain text in $COMPOSE_FILE"
+
+  # Create desktop entries (must be done AFTER LG_ENABLED is determined)
   mkdir -p "$HOME/.local/share/applications/icons"
 
-  # Install Windows VM icon and desktop file
-  if [ -f "$OMARCHY_PATH/applications/icons/windows.png" ]; then
-    cp "$OMARCHY_PATH/applications/icons/windows.png" "$HOME/.local/share/applications/icons/windows.png"
+  # Install Windows VM icon
+  ICON_SOURCE="$SCRIPT_DIR/../applications/icons/windows.png"
+  if [[ -f "$ICON_SOURCE" ]]; then
+    cp "$ICON_SOURCE" "$HOME/.local/share/applications/icons/windows.png"
+  else
+    msg_warning "Windows icon not found at: $ICON_SOURCE"
+    msg_info "Desktop entries will use default icon"
   fi
 
-  cat << EOF | tee "$HOME/.local/share/applications/windows-vm.desktop" > /dev/null
+  # Create Windows (RDP) desktop entry
+  cat <<EOF >"$HOME/.local/share/applications/windows-vm.desktop"
 [Desktop Entry]
 Name=Windows
 Comment=Start Windows VM via Docker and connect with RDP
-Exec=uwsm app -- omarchy-windows-vm launch
+Exec=uwsm-app -- omarchy-windows-vm launch --keep-alive
 Icon=$HOME/.local/share/applications/icons/windows.png
 Terminal=false
 Type=Application
 Categories=System;Virtualization;
 EOF
 
-  # Get system resources
-  TOTAL_RAM=$(free -h | awk 'NR==2 {print $2}')
-  TOTAL_RAM_GB=$(awk 'NR==1 {printf "%d", $2/1024/1024}' /proc/meminfo)
-  TOTAL_CORES=$(nproc)
+  # Create Windows [Looking Glass] desktop entry if enabled
+  if [[ "$LG_ENABLED" == true ]]; then
+    cat <<EOF >"$HOME/.local/share/applications/windows-looking-glass.desktop"
+[Desktop Entry]
+Name=Windows [Looking Glass]
+Comment=Connect to Windows VM via Looking Glass
+Exec=uwsm-app -- omarchy-windows-vm launch --lg --keep-alive --windowed
+Icon=$HOME/.local/share/applications/icons/windows.png
+Terminal=false
+Type=Application
+Categories=System;Virtualization;
+EOF
+  fi
 
-  echo ""
-  echo "System Resources Detected:"
-  echo "  Total RAM: $TOTAL_RAM"
-  echo "  Total CPU Cores: $TOTAL_CORES"
-  echo ""
+  # Set proper permissions for desktop files
+  chmod 644 "$HOME/.local/share/applications/windows-vm.desktop" 2>/dev/null
+  [[ -f "$HOME/.local/share/applications/windows-looking-glass.desktop" ]] &&
+    chmod 644 "$HOME/.local/share/applications/windows-looking-glass.desktop" 2>/dev/null
 
-  RAM_OPTIONS=""
-  for size in 2 4 8 16 32 64; do
-    if [ $size -le $TOTAL_RAM_GB ]; then
-      RAM_OPTIONS="$RAM_OPTIONS ${size}G"
+  # Update desktop database to make icons appear in application menu
+  if command -v update-desktop-database &>/dev/null; then
+    update-desktop-database "$HOME/.local/share/applications" 2>/dev/null || true
+  fi
+
+  # Bind GPU to VFIO before starting Docker (if GPU passthrough enabled)
+  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]]; then
+    if ! command -v omarchy-gpu-passthrough &>/dev/null; then
+      msg_error "omarchy-gpu-passthrough not found"
+      exit 1
     fi
-  done
 
-  SELECTED_RAM=$(echo $RAM_OPTIONS | tr ' ' '\n' | gum choose --selected="4G" --header="How much RAM would you like to allocate to Windows VM?")
+    # Check current GPU driver and bind if needed
+    CURRENT_DRIVER=$(lspci -k -s "$GPU_PCI_ADDR" 2>/dev/null | grep "Kernel driver in use" | awk '{print $5}')
+    if [[ "$CURRENT_DRIVER" != "vfio-pci" ]]; then
+      # omarchy-gpu-passthrough mode vm prints its own status messages
+      if ! omarchy-gpu-passthrough mode vm 2>&1; then
+        msg_error "Failed to bind GPU to VFIO"
+        exit 1
+      fi
+    fi
+  fi
 
-  # Check if user cancelled
-  if [ -z "$SELECTED_RAM" ]; then
-    echo "Installation cancelled by user"
-    exit 1
+  # Ensure Docker image has SPICE support (required for Looking Glass)
+  if [[ "$LG_ENABLED" == true ]]; then
+    if ! ensure_dockurr_windows_with_spice; then
+      msg_error "Failed to prepare Docker image with SPICE support"
+      echo "   Looking Glass requires SPICE for keyboard/mouse input"
+      exit 1
+    fi
   fi
 
-  SELECTED_CORES=$(gum input --placeholder="Number of CPU cores (1-$TOTAL_CORES)" --value="2" --header="How many CPU cores would you like to allocate to Windows VM?" --char-limit=2)
+  # Start or restart docker-compose with user's config
+  msg_info "Starting Windows VM..."
 
-  # Check if user cancelled (Ctrl+C in gum input returns empty string)
-  if [ -z "$SELECTED_CORES" ]; then
-    echo "Installation cancelled by user"
+  # Verify Looking Glass device exists before starting VM
+  if [[ "$LG_ENABLED" == true ]] && [[ ! -e /dev/kvmfr0 ]]; then
+    msg_error "/dev/kvmfr0 not found"
+    echo "   Looking Glass kernel module is not loaded."
+    echo "   Run: omarchy-looking-glass-launch (shows diagnostics)"
+    echo "   Or reinstall: omarchy-looking-glass-install"
     exit 1
   fi
 
-  if ! [[ "$SELECTED_CORES" =~ ^[0-9]+$ ]] || [ "$SELECTED_CORES" -lt 1 ] || [ "$SELECTED_CORES" -gt "$TOTAL_CORES" ]; then
-    echo "Invalid input. Using default: 2 cores"
-    SELECTED_CORES=2
+  # Start container (suppress verbose Docker output)
+  if ! docker-compose -f "$COMPOSE_FILE" up -d >/dev/null 2>&1; then
+    msg_error "Failed to start VM"
+    echo "  Check logs: docker logs omarchy-windows"
+    exit 1
   fi
 
-  AVAILABLE_SPACE=$(df "$HOME" | awk 'NR==2 {print int($4/1024/1024)}')
-  MAX_DISK_GB=$((AVAILABLE_SPACE - 10))  # Leave 10GB for Windows image
+  # Verify container is running (docker-compose up returns 0 even if QEMU crashes)
+  CONTAINER_RUNNING=false
+  for ((i = 0; i < 10; i++)); do
+    CONTAINER_STATUS=$(docker ps -a --filter "name=omarchy-windows" --format "{{.Status}}" 2>/dev/null)
+
+    if [[ "$CONTAINER_STATUS" =~ ^Up ]]; then
+      CONTAINER_RUNNING=true
+      break
+    elif [[ "$CONTAINER_STATUS" =~ ^Exited ]]; then
+      msg_error "VM crashed on startup"
+      echo "  Check logs: docker logs omarchy-windows"
+      exit 1
+    fi
 
-  # Check if we have enough space for minimum
-  if [ $MAX_DISK_GB -lt 32 ]; then
-    echo "❌ Insufficient disk space for Windows VM!"
-    echo "   Available: ${AVAILABLE_SPACE}GB"
-    echo "   Minimum required: 42GB (32GB disk + 10GB for Windows image)"
+    sleep 3
+  done
+
+  if [[ "$CONTAINER_RUNNING" != true ]]; then
+    msg_error "VM failed to start within 30s"
+    echo "  Check logs: docker logs omarchy-windows"
     exit 1
   fi
 
-  DISK_OPTIONS=""
-  for size in 32 64 128 256 512; do
-    if [ $size -le $MAX_DISK_GB ]; then
-      DISK_OPTIONS="$DISK_OPTIONS ${size}G"
+  msg_success "Docker container started"
+
+  # Verify QEMU is running (noVNC on 8006 indicates QEMU is alive)
+  echo "  Verifying VM startup..."
+  QEMU_CHECK=0
+  while [[ "$QEMU_CHECK" -lt 15 ]]; do
+    if nc -z 127.0.0.1 8006 2>/dev/null; then
+      break
     fi
+    sleep 2
+    QEMU_CHECK=$((QEMU_CHECK + 2))
   done
 
-  # Default to 64G if available, otherwise 32G
-  DEFAULT_DISK="64G"
-  if ! echo "$DISK_OPTIONS" | grep -q "64G"; then
-    DEFAULT_DISK="32G"
+  if ! nc -z 127.0.0.1 8006 2>/dev/null; then
+    msg_error "VM failed to start (QEMU not responding)"
+    echo "  Check logs: docker logs omarchy-windows"
+    exit 1
   fi
 
-  SELECTED_DISK=$(echo $DISK_OPTIONS | tr ' ' '\n' | gum choose --selected="$DEFAULT_DISK" --header="How much disk space would you like to give Windows VM? (64GB+ recommended)")
+  # Check if this is quick reinstall with VM already booted and RDP ready
+  if [[ "${SKIP_OEM_AUTORUN:-false}" == "true" ]] && nc -z 127.0.0.1 3389 2>/dev/null; then
+    msg_success "Windows is ready (RDP service responding)"
+
+    # Auto-launch RDP or Looking Glass
+    if [[ "$LG_ENABLED" == true ]]; then
+      echo "Launching Looking Glass..."
+      echo "   Toggle fullscreen: $(get_escape_key_display)"
+      sleep 1
+      launch_windows --lg
+    else
+      echo "Launching RDP connection..."
+      echo "   Toggle fullscreen: Super + F"
+      sleep 1
+      # Extract credentials
+      WIN_USER=$(grep -E '^\s*USERNAME:' "$COMPOSE_FILE" | head -1 | sed -E 's/^[^:]*:[[:space:]]*"?([^"]*)"?[[:space:]]*$/\1/' | xargs)
+      WIN_PASS=$(grep -E '^\s*PASSWORD:' "$COMPOSE_FILE" | head -1 | sed -E 's/^[^:]*:[[:space:]]*"?([^"]*)"?[[:space:]]*$/\1/' | xargs)
+      connect_rdp "$WIN_USER" "$WIN_PASS" true
+    fi
+    return 0
+  fi
 
-  # Check if user cancelled
-  if [ -z "$SELECTED_DISK" ]; then
-    echo "Installation cancelled by user"
-    exit 1
+  # Auto-fix Looking Glass config if using old SPICE socket path
+  if [[ "$LG_ENABLED" == true ]]; then
+    LG_CONFIG="$HOME/.config/looking-glass/client.ini"
+    if [[ -f "$LG_CONFIG" ]] && grep -q "host=/tmp/spice/spice.sock" "$LG_CONFIG" 2>/dev/null; then
+      sed -i 's|host=/tmp/spice/spice.sock|host=/var/run/omarchy-windows/spice.sock|g' "$LG_CONFIG"
+    fi
   fi
 
-  # Extract just the number for prerequisite check
-  DISK_SIZE_NUM=$(echo "$SELECTED_DISK" | sed 's/G//')
+  # Open VNC in browser for monitoring
+  echo ""
+  echo "Monitor progress: http://127.0.0.1:8006"
+  sleep 1
+  xdg-open "http://127.0.0.1:8006" &>/dev/null &
+  echo ""
 
-  # Re-check prerequisites with selected disk size
-  check_prerequisites "$DISK_SIZE_NUM"
+  [[ "${SKIP_OEM_AUTORUN:-false}" == "false" ]] &&
+    monitor_installation_progress "$USERNAME" "$PASSWORD" "true" "$LG_ENABLED" ||
+    monitor_installation_progress "$USERNAME" "$PASSWORD" "false" "$LG_ENABLED"
 
-  # Prompt for username and password
-  USERNAME=$(gum input --placeholder="Username (Press enter to use default: docker)" --header="Enter Windows username:")
-  if [ -z "$USERNAME" ]; then
-    USERNAME="docker"
-  fi
-
-  PASSWORD=$(gum input --placeholder="Password (Press enter to use default: admin)" --password --header="Enter Windows password:")
-  if [ -z "$PASSWORD" ]; then
-    PASSWORD="admin"
-    PASSWORD_DISPLAY="(default)"
-  else
-    PASSWORD_DISPLAY="(user-defined)"
-  fi
-
-  # Display configuration summary
-  gum style \
-    --border normal \
-    --padding "1 2" \
-    --margin "1" \
-    --align left \
-    --bold \
-    "Windows VM Configuration" \
-    "" \
-    "RAM:       $SELECTED_RAM" \
-    "CPU:       $SELECTED_CORES cores" \
-    "Disk:      $SELECTED_DISK" \
-    "Username:  $USERNAME" \
-    "Password:  $PASSWORD_DISPLAY"
-
-  # Ask for confirmation
+  if [[ "$NEEDS_REBOOT_FOR_LG" == true ]]; then
+    if [[ "$LG_REBOOT_REASON" == "kvm group membership" ]]; then
+      msg_warning "Re-login required for Looking Glass (kvm group)"
+    else
+      msg_warning "Reboot required for Looking Glass ($LG_REBOOT_REASON)"
+    fi
+  fi
+}
+
+remove_windows() {
+  echo "Removing Windows VM configuration..."
   echo ""
-  if ! gum confirm "Proceed with this configuration?"; then
-    echo "Installation cancelled by user"
-    exit 1
+  echo "This will remove Docker container and config files."
+  echo "VM disk and your data will be preserved."
+  echo ""
+
+  if ! gum confirm "Remove VM configuration only (keep VM disk)?"; then
+    echo "Cancelled"
+    return 0
   fi
 
-  mkdir -p $HOME/Windows
+  # Stop and remove container
+  echo "• Stopping container..."
+  docker-compose -f "$COMPOSE_FILE" down 2>/dev/null || true
 
-  # Create docker-compose.yml in user config directory
-  cat << EOF | tee "$COMPOSE_FILE" > /dev/null
-services:
-  windows:
-    image: dockurr/windows
-    container_name: omarchy-windows
-    environment:
-      VERSION: "11"
-      RAM_SIZE: "$SELECTED_RAM"
-      CPU_CORES: "$SELECTED_CORES"
-      DISK_SIZE: "$SELECTED_DISK"
-      USERNAME: "$USERNAME"
-      PASSWORD: "$PASSWORD"
-    devices:
-      - /dev/kvm
-      - /dev/net/tun
-    cap_add:
-      - NET_ADMIN
-    ports:
-      - 8006:8006
-      - 3389:3389/tcp
-      - 3389:3389/udp
-    volumes:
-      - $HOME/.windows:/storage
-      - $HOME/Windows:/shared
-    restart: always
-    stop_grace_period: 2m
-EOF
+  # Remove Docker image
+  echo "• Removing Docker image..."
+  if docker rmi dockurr/windows >/dev/null 2>&1; then
+    msg_success "Docker image removed"
+  else
+    msg_info "Image already removed"
+  fi
 
-  echo ""
-  echo "Starting Windows VM installation..."
-  echo "This will download a Windows 11 image (may take 10-15 minutes)."
-  echo ""
-  echo "Monitor installation progress at: http://127.0.0.1:8006"
-  echo ""
+  # Remove desktop files and shortcuts
+  echo "• Removing desktop shortcuts..."
+  rm -f "$HOME/.local/share/applications/windows-vm.desktop"
+  rm -f "$HOME/.local/share/applications/windows-looking-glass.desktop"
 
-  # Start docker-compose with user's config
-  echo "Starting Windows VM with docker-compose..."
-  if ! docker-compose -f "$COMPOSE_FILE" up -d 2>&1; then
-    echo "❌ Failed to start Windows VM!"
-    echo "   Common issues:"
-    echo "   - Docker daemon not running: sudo systemctl start docker"
-    echo "   - Port already in use: check if another VM is running"
-    echo "   - Permission issues: make sure you're in the docker group"
-    exit 1
+  # Update desktop database to remove icons from application menu
+  if command -v update-desktop-database &>/dev/null; then
+    update-desktop-database "$HOME/.local/share/applications" 2>/dev/null || true
   fi
 
-  echo ""
-  echo "Windows VM is starting up!"
-  echo ""
-  echo "Opening browser to monitor installation..."
+  # Remove installation log files (not user data)
+  echo "• Removing installation logs..."
+  rm -f "$HOME/Windows/install-log.txt"
+  rm -f "$HOME/Windows/installation-complete.txt"
 
-  # Open browser to monitor installation
-  sleep 3
-  xdg-open "http://127.0.0.1:8006"
+  # Remove configuration (but keep data)
+  echo "• Removing configuration..."
+  rm -rf "$HOME/.config/windows"
 
   echo ""
-  echo "Installation is running in the background."
-  echo "You can monitor progress at: http://127.0.0.1:8006"
+  msg_success "Windows VM configuration removed!"
   echo ""
-  echo "Once finished, launch 'Windows' via Super + Space"
-  echo ""
-  echo "To stop the VM: omarchy-windows-vm stop"
-  echo "To change resources: ~/.config/windows/docker-compose.yml"
+  echo "Preserved:"
+  echo "  ✓  VM disk: $HOME/.windows/ (reusable for quick reinstall)"
+  echo "  ✓  Shared files: $HOME/Windows/ (your data)"
   echo ""
+  echo "To completely remove all data:"
+  echo "   sudo rm -rf $HOME/.windows/      # Delete VM disk and Windows OS"
 }
 
-remove_windows() {
-  echo "Removing Windows VM..."
+check_passwordless_configuration() {
+  # Check if system is configured for passwordless VM operations
+  # Returns: 0 if OK, 1 if missing configuration
 
-  docker-compose -f "$COMPOSE_FILE" down 2>/dev/null || true
+  local issues_found=false
+  local issue_list=""
+
+  if [[ ! -f /etc/tmpfiles.d/omarchy-windows.conf ]]; then
+    issues_found=true
+    issue_list="${issue_list}  ❌ Missing: /etc/tmpfiles.d/omarchy-windows.conf\n"
+  elif [[ ! -d /var/run/omarchy-windows ]]; then
+    issues_found=true
+    issue_list="${issue_list}  ❌ SPICE directory not created by tmpfiles.d\n"
+  fi
 
-  docker rmi dockurr/windows 2>/dev/null || echo "Image already removed or not found"
+  if ! sudo -n /usr/bin/mkdir -p /var/run/omarchy-windows 2>/dev/null; then
+    issues_found=true
+    if [[ ! -f /etc/sudoers.d/omarchy-looking-glass ]]; then
+      issue_list="${issue_list}  ❌ Missing: /etc/sudoers.d/omarchy-looking-glass\n"
+    else
+      issue_list="${issue_list}  ❌ Sudoers rules not working (run: omarchy-looking-glass-install)\n"
+    fi
+  fi
 
-  rm "$HOME/.local/share/applications/windows-vm.desktop"
-  rm -rf "$HOME/.config/windows"
-  rm -rf "$HOME/.windows"
+  if [[ "$issues_found" == false ]]; then
+    return 0
+  fi
 
   echo ""
-  echo "Windows VM removal completed!"
+  msg_warning "System configuration incomplete for desktop launcher:"
+  echo ""
+  echo -e "$issue_list"
+  echo ""
+  echo "Desktop launcher may not work (requires terminal for password prompt)."
+  echo ""
+  echo "Fix: omarchy-looking-glass-install"
+  echo ""
+
+  # If running from desktop (no TTY), fail immediately
+  if [[ ! -t 0 ]]; then
+    msg_error "Cannot continue: No terminal available for password prompts"
+    echo ""
+    echo "Run from terminal: omarchy-windows-vm launch --lg"
+    echo "Or fix configuration: omarchy-looking-glass-install"
+    notify_silent "Windows VM" "Configuration error - check terminal" "critical"
+    exit 1
+  fi
+
+  if command -v gum &>/dev/null; then
+    if ! gum confirm "Continue anyway (you will be prompted for password)?"; then
+      echo "Cancelled"
+      exit 0
+    fi
+  else
+    read -p "Continue anyway? (y/N) " -n 1 -r
+    echo
+    if [[ ! "$REPLY" =~ ^[Yy]$ ]]; then
+      echo "Cancelled"
+      exit 0
+    fi
+  fi
+
+  return 0
 }
 
 launch_windows() {
   KEEP_ALIVE=false
-  if [ "$1" = "--keep-alive" ] || [ "$1" = "-k" ]; then
-    KEEP_ALIVE=true
-  fi
+  USE_LOOKING_GLASS=false
+  USE_WINDOWED=false
+  USER_PROVIDED_PARAMS=false
+
+  # Parse command line arguments
+  while [[ "$#" -gt 0 ]]; do
+    case "$1" in
+    --keep-alive | -k)
+      KEEP_ALIVE=true
+      USER_PROVIDED_PARAMS=true
+      shift
+      ;;
+    --looking-glass | --lg)
+      USE_LOOKING_GLASS=true
+      USER_PROVIDED_PARAMS=true
+      shift
+      ;;
+    --windowed | -w)
+      USE_WINDOWED=true
+      USER_PROVIDED_PARAMS=true
+      shift
+      ;;
+    *)
+      shift
+      ;;
+    esac
+  done
 
-  # Check if config exists
-  if [ ! -f "$COMPOSE_FILE" ]; then
-    echo "Windows VM not configured. Please run: omarchy-windows-vm install"
-    exit 1
+  check_vm_configured
+  check_docker_running
+
+  # Interactive mode if no params provided
+  if [[ "$USER_PROVIDED_PARAMS" == false ]]; then
+    # Check if Looking Glass is available
+    LG_AVAILABLE=false
+    if grep -q "ivshmem-plain" "$COMPOSE_FILE" 2>/dev/null &&
+      command -v looking-glass-client &>/dev/null &&
+      grep -q "vfio-pci" "$COMPOSE_FILE" 2>/dev/null; then
+      LG_AVAILABLE=true
+    fi
+
+    # Combined prompt for connection method and lifecycle
+    if [[ "$LG_AVAILABLE" == true ]]; then
+      echo "Windows VM Launch Options:"
+      echo ""
+      echo "Connection method:"
+      echo "  • Looking Glass: Ultra-low latency (GPU passthrough)"
+      echo "  • RDP: Standard remote desktop"
+      echo ""
+      echo "VM lifecycle:"
+      echo "  • Auto-stop: VM stops when you disconnect"
+      echo "  • Keep-alive: VM keeps running in background"
+      echo ""
+
+      LAUNCH_CONFIG=$(gum choose --selected="Looking Glass + Auto-stop" \
+        "Looking Glass + Auto-stop" \
+        "Looking Glass + Keep-alive" \
+        "RDP + Auto-stop" \
+        "RDP + Keep-alive")
+
+      # Parse combined choice
+      if [[ "$LAUNCH_CONFIG" == "Looking Glass"* ]]; then
+        USE_LOOKING_GLASS=true
+      fi
+
+      if [[ "$LAUNCH_CONFIG" == *"Keep-alive"* ]]; then
+        KEEP_ALIVE=true
+      fi
+    else
+      # LG not available, only offer RDP options
+      echo "Windows VM Launch Options:"
+      echo ""
+      echo "Connection: RDP (standard remote desktop)"
+      echo "  (Looking Glass not configured)"
+      echo ""
+      echo "VM lifecycle:"
+      echo "  • Auto-stop: VM stops when you disconnect"
+      echo "  • Keep-alive: VM keeps running in background"
+
+      LAUNCH_CONFIG=$(gum choose --selected="RDP + Auto-stop" \
+        "RDP + Auto-stop" \
+        "RDP + Keep-alive")
+
+      if [[ "$LAUNCH_CONFIG" == *"Keep-alive"* ]]; then
+        KEEP_ALIVE=true
+      fi
+    fi
   fi
 
-  # Check if container is already running
-  CONTAINER_STATUS=$(docker inspect --format='{{.State.Status}}' omarchy-windows 2>/dev/null)
+  [[ "$USE_LOOKING_GLASS" == true ]] && check_passwordless_configuration
+
+  CONTAINER_STATUS=$(get_container_status)
+
+  WAS_ALREADY_RUNNING=false
+  if [[ "$CONTAINER_STATUS" == "running" ]]; then
+    WAS_ALREADY_RUNNING=true
+  fi
 
-  if [ "$CONTAINER_STATUS" != "running" ]; then
+  if [[ "$CONTAINER_STATUS" != "running" ]]; then
     echo "Starting Windows VM..."
 
+    # Check if GPU passthrough is configured in docker-compose.yml
+    if grep -q "vfio-pci" "$COMPOSE_FILE" 2>/dev/null; then
+      echo "  Detected GPU passthrough configuration"
+
+      # Check GPU health before attempting to start VM (IOTLB errors require cold boot)
+      if command -v omarchy-gpu-passthrough-info &>/dev/null; then
+        if omarchy-gpu-passthrough-info gpu-health &>/dev/null; then
+          echo ""
+          msg_error "GPU Health: IOTLB_INV_TIMEOUT detected"
+          echo ""
+          echo "The GPU cannot be used for passthrough in this state."
+          echo "This happens when AMD GPUs with 'reset bug' are reset too many times."
+          echo ""
+          echo "Solution: Cold boot"
+          echo ""
+          echo "  1. sudo poweroff"
+          echo "  2. Unplug power for 30 seconds"
+          echo "  3. Power on"
+          echo ""
+          echo "Details: omarchy-gpu-passthrough-info health"
+          exit 1
+        fi
+      fi
+
+      # Load GPU configuration and auto-bind if needed
+      if command -v omarchy-gpu-passthrough-info &>/dev/null; then
+        if omarchy-gpu-passthrough-info is-configured &>/dev/null; then
+          # Check if GPU is already bound to VFIO
+          GPU_CONFIG=$(omarchy-gpu-passthrough-info get-docker-config 2>/dev/null)
+          if [[ -n "$GPU_CONFIG" ]]; then
+            # Format: GPU_PCI_ADDR IOMMU_GROUP DEVICE1 DEVICE2 ...
+            read -r GPU_PCI_ADDR _IOMMU_GROUP _REST <<<"$GPU_CONFIG"
+
+            # Validate PCI address format (security check)
+            if [[ ! "$GPU_PCI_ADDR" =~ ^([0-9a-fA-F]{4}:)?[0-9a-fA-F]{2}:[0-9a-fA-F]{2}\.[0-7]$ ]]; then
+              msg_warning "Invalid PCI address format: $GPU_PCI_ADDR"
+            else
+              # Check current driver binding
+              CURRENT_DRIVER=$(lspci -k -s "$GPU_PCI_ADDR" 2>/dev/null | grep "Kernel driver in use" | awk '{print $5}')
+
+              if [[ "$CURRENT_DRIVER" != "vfio-pci" ]]; then
+                echo "  GPU not bound to VFIO, binding now..."
+                if command -v omarchy-gpu-passthrough &>/dev/null; then
+                  if omarchy-gpu-passthrough mode vm 2>&1; then
+                    msg_success "GPU switched to VM mode successfully"
+                  else
+                    msg_warning "GPU mode switch may have failed, check with: omarchy-gpu-passthrough mode"
+                  fi
+                fi
+              else
+                msg_success "GPU already bound to VFIO"
+              fi
+            fi
+          fi
+        fi
+      fi
+    fi
+
     # Send desktop notification
-    notify-send "    Starting Windows VM" "      This can take 15-30 seconds" -t 15000
+    notify_silent "Windows VM" "Starting... (15-30 seconds)" "normal"
+
+    # Verify Looking Glass device exists before starting VM
+    if grep -q "ivshmem-plain" "$COMPOSE_FILE" 2>/dev/null; then
+      if [[ ! -e /dev/kvmfr0 ]]; then
+        echo ""
+        msg_error "Looking Glass device /dev/kvmfr0 not found!"
+        echo "   Run: omarchy-looking-glass-launch (shows diagnostics)"
+        echo "   Or reinstall: omarchy-looking-glass-install"
+        echo ""
+        notify_silent "Windows VM" "Looking Glass device not found" "critical"
+        exit 1
+      fi
+    fi
+
+    if ! docker-compose -f "$COMPOSE_FILE" up -d >/dev/null 2>&1; then
+      msg_error "Failed to start VM"
+      echo "  Check logs: docker logs omarchy-windows"
+      notify_silent "Windows VM" "VM failed to start" "critical"
+      exit 1
+    fi
+
+    # Verify container is running (docker-compose up returns 0 even if QEMU crashes)
+    CONTAINER_RUNNING=false
+    for ((i = 0; i < 10; i++)); do
+      CONTAINER_STATUS=$(docker ps -a --filter "name=omarchy-windows" --format "{{.Status}}" 2>/dev/null)
+
+      if [[ "$CONTAINER_STATUS" =~ ^Up ]]; then
+        CONTAINER_RUNNING=true
+        break
+      elif [[ "$CONTAINER_STATUS" =~ ^Exited ]]; then
+        msg_error "VM crashed on startup"
+        echo "  Check logs: docker logs omarchy-windows"
+        notify_silent "Windows VM" "VM crashed" "critical"
+        exit 1
+      fi
+
+      sleep 3
+    done
 
-    if ! docker-compose -f "$COMPOSE_FILE" up -d 2>&1; then
-      echo "❌ Failed to start Windows VM!"
-      echo "   Try checking: omarchy-windows-vm status"
-      echo "   View logs: docker logs omarchy-windows"
-      notify-send -u critical "Windows VM" "Failed to start Windows VM"
+    if [[ "$CONTAINER_RUNNING" != true ]]; then
+      msg_error "VM failed to start within 30s"
+      echo "  Check logs: docker logs omarchy-windows"
+      notify_silent "Windows VM" "VM startup timeout" "critical"
       exit 1
     fi
 
-    # Wait for RDP to be ready
+    # Wait for SPICE socket if GPU passthrough is enabled
+    if grep -q "vfio-pci" "$COMPOSE_FILE" 2>/dev/null; then
+      echo "  Waiting for SPICE socket..."
+      SPICE_WAIT=0
+      while [[ "$SPICE_WAIT" -lt 30 ]]; do
+        # Check socket and fix permissions if needed
+        if sudo -n test -S "$SPICE_SOCKET_PATH" 2>/dev/null; then
+          msg_success "SPICE socket created"
+          sudo -n chmod 660 "$SPICE_SOCKET_PATH" 2>/dev/null || true
+          sudo -n chgrp kvm "$SPICE_SOCKET_PATH" 2>/dev/null || true
+          break
+        fi
+        sleep 1
+        SPICE_WAIT=$((SPICE_WAIT + 1))
+      done
+
+      if [[ "$SPICE_WAIT" -ge 30 ]]; then
+        msg_warning "SPICE socket not created within 30s"
+        echo "  Looking Glass input may not work properly"
+      fi
+    fi
+  fi
+
+  # Fix SPICE socket permissions if GPU passthrough is enabled (even if container already running)
+  if grep -q "vfio-pci" "$COMPOSE_FILE" 2>/dev/null; then
+    # Check socket and fix permissions if needed
+    if sudo -n test -S "$SPICE_SOCKET_PATH" 2>/dev/null && [[ ! -r "$SPICE_SOCKET_PATH" ]]; then
+      sudo -n chmod 660 "$SPICE_SOCKET_PATH" 2>/dev/null || true
+      sudo -n chgrp kvm "$SPICE_SOCKET_PATH" 2>/dev/null || true
+    fi
+  fi
+
+  # Verify QEMU is running before waiting for RDP (noVNC on 8006 indicates QEMU is alive)
+  echo "  Verifying VM startup..."
+  QEMU_CHECK=0
+  while [[ "$QEMU_CHECK" -lt 15 ]]; do
+    if nc -z 127.0.0.1 8006 2>/dev/null; then
+      break
+    fi
+    sleep 2
+    QEMU_CHECK=$((QEMU_CHECK + 2))
+  done
+
+  if ! nc -z 127.0.0.1 8006 2>/dev/null; then
+    msg_error "VM failed to start (QEMU not responding)"
+    echo "  Check logs: docker logs omarchy-windows"
+    notify_silent "Windows VM" "QEMU failed" "critical"
+    exit 1
+  fi
+
+  # Wait for RDP port to open (Windows may still be booting or installing)
+  if ! nc -z 127.0.0.1 3389 2>/dev/null; then
     echo "Waiting for Windows VM to be ready..."
+    WAIT_START=$(date +%s)
     WAIT_COUNT=0
     while ! nc -z 127.0.0.1 3389 2>/dev/null; do
-      sleep 2
+      sleep 5
       WAIT_COUNT=$((WAIT_COUNT + 1))
-      if [ $WAIT_COUNT -gt 60 ]; then  # 2 minutes timeout
-        echo "❌ Timeout waiting for RDP!"
-        echo "   The VM might still be installing Windows."
-        echo "   Check progress at: http://127.0.0.1:8006"
+
+      # Check if container is still running
+      if [[ "$(get_container_status)" != "running" ]]; then
+        echo ""
+        msg_error "VM crashed while waiting for Windows to boot"
+        echo ""
+        echo "   Check logs: docker logs omarchy-windows"
+        echo ""
+        warn_if_gpu_iotlb_error
         exit 1
       fi
+
+      if [[ "$((WAIT_COUNT % 60))" -eq 0 ]]; then
+        CURRENT_TIME=$(date +%s)
+        TOTAL_ELAPSED=$((CURRENT_TIME - WAIT_START))
+        echo ""
+        msg_warning "Windows is taking longer than expected (${TOTAL_ELAPSED}s elapsed)"
+        echo ""
+        echo "Options:"
+        echo "   1. Keep waiting - VM might still be installing"
+        echo "   2. Check progress at: http://127.0.0.1:8006"
+        echo "   3. View logs: docker logs -f omarchy-windows"
+        echo ""
+        read -p "Continue waiting? (Y/n) " -n 1 -r
+        echo
+        if [[ "$REPLY" =~ ^[Nn]$ ]]; then
+          echo "VM will keep running in background"
+          echo "Connect later: omarchy-windows-vm launch"
+          exit 0
+        fi
+      elif [[ "$((WAIT_COUNT % 6))" -eq 0 ]]; then
+        CURRENT_TIME=$(date +%s)
+        ELAPSED=$((CURRENT_TIME - WAIT_START))
+        echo "Still waiting... (${ELAPSED}s elapsed)"
+        echo "Check progress at: http://127.0.0.1:8006"
+      fi
     done
 
-    # Give it a moment more to fully initialize
-    sleep 5
+    WAIT_END=$(date +%s)
+    WAIT_TIME=$((WAIT_END - WAIT_START))
+    msg_success "RDP port open (took ${WAIT_TIME}s)"
   fi
 
-  # Extract credentials from compose file
-  WIN_USER=$(grep "USERNAME:" "$COMPOSE_FILE" | sed 's/.*USERNAME: "\(.*\)"/\1/')
-  WIN_PASS=$(grep "PASSWORD:" "$COMPOSE_FILE" | sed 's/.*PASSWORD: "\(.*\)"/\1/')
+  if [[ "$USE_LOOKING_GLASS" == true ]]; then
+    connect_looking_glass "$KEEP_ALIVE" "$USE_WINDOWED"
+
+  else
+    # Extract credentials for RDP connection
+    WIN_USER=$(grep -E '^\s*USERNAME:' "$COMPOSE_FILE" | head -1 | sed -E 's/^[^:]*:[[:space:]]*"?([^"]*)"?[[:space:]]*$/\1/' | xargs)
+    WIN_PASS=$(grep -E '^\s*PASSWORD:' "$COMPOSE_FILE" | head -1 | sed -E 's/^[^:]*:[[:space:]]*"?([^"]*)"?[[:space:]]*$/\1/' | xargs)
+
+    if [[ -z "$WIN_USER" ]] || [[ -z "$WIN_PASS" ]]; then
+      msg_error "Failed to extract credentials from $COMPOSE_FILE"
+      echo "   Configuration file may be corrupted or in unexpected format."
+      echo ""
+      echo "   Try reinstalling: omarchy-windows-vm remove && omarchy-windows-vm install"
+      exit 1
+    fi
+
+    # Always verify RDP service readiness before connecting
+    # Port being open (nc -z) doesn't mean Windows RDP service is ready -
+    # QEMU may forward the port before Windows finishes booting.
+    MAX_WAIT=90
+    if [[ "$WAS_ALREADY_RUNNING" == false ]]; then
+      echo "Waiting for RDP service to become ready..."
+    else
+      echo "Verifying RDP service..."
+    fi
+
+    # Test RDP readiness with X.224 handshake
+    RETRY_INTERVAL=5
+    ELAPSED=0
+    RDP_READY=false
+    CONTAINER_DIED=false
+
+    # Quick first check (don't wait if already ready)
+    if test_rdp_ready; then
+      RDP_READY=true
+    else
+      while [[ "$ELAPSED" -lt "$MAX_WAIT" ]]; do
+        sleep "$RETRY_INTERVAL"
+        ELAPSED=$((ELAPSED + RETRY_INTERVAL))
+
+        # Check if container is still running
+        if [[ "$(get_container_status)" != "running" ]]; then
+          CONTAINER_DIED=true
+          break
+        fi
+
+        if test_rdp_ready; then
+          RDP_READY=true
+          break
+        fi
+        if [[ "$ELAPSED" -lt "$MAX_WAIT" ]]; then
+          echo "  Testing RDP protocol... (${ELAPSED}s elapsed, next check in ${RETRY_INTERVAL}s)"
+        fi
+      done
+    fi
 
-  # Use defaults if not found
-  [ -z "$WIN_USER" ] && WIN_USER="docker"
-  [ -z "$WIN_PASS" ] && WIN_PASS="admin"
+    echo ""
+    if [[ "$CONTAINER_DIED" == true ]]; then
+      msg_error "VM crashed during startup"
+      echo ""
+      echo "   Check logs: docker logs omarchy-windows"
+      echo ""
+      warn_if_gpu_iotlb_error
+      exit 1
+    elif [[ "$RDP_READY" == true ]]; then
+      msg_success "RDP service is ready"
+    else
+      if [[ "$WAS_ALREADY_RUNNING" == false ]]; then
+        msg_warning "RDP service did not respond within ${MAX_WAIT}s"
+        echo "   Proceeding anyway, but connection may fail"
+      else
+        msg_warning "RDP not responding - Windows may be restarting"
+        echo "   Will retry connection..."
+      fi
+    fi
 
-  # Build the connection info
-  if [ "$KEEP_ALIVE" = true ]; then
-    LIFECYCLE="VM will keep running after RDP closes
+    # Build the connection info
+    if [[ "$KEEP_ALIVE" == true ]]; then
+      LIFECYCLE="VM will keep running after RDP closes
 To stop: omarchy-windows-vm stop"
-  else
-    LIFECYCLE="VM will auto-stop when RDP closes"
+    else
+      LIFECYCLE="VM will auto-stop when RDP closes"
+    fi
+
+    gum style \
+      --border normal \
+      --padding "1 2" \
+      --margin "1" \
+      --align center \
+      "Connecting to Windows VM" \
+      "" \
+      "$LIFECYCLE"
+
+    echo "   Toggle fullscreen: Super + F"
+    echo "   Close RDP window: Super + W (or shutdown Windows)"
+    if [[ "$KEEP_ALIVE" == false ]]; then
+      echo "   Ctrl+C            - Close terminal (RDP/VM keep running)"
+    fi
+    echo ""
+    echo "   Manual connect: xfreerdp3 /u:$WIN_USER /p:yourPassword /v:127.0.0.1:3389 -grab-keyboard /sound /microphone /cert:ignore /dynamic-resolution /gfx:AVC444 (requires running VM)"
+
+    # Connect with RDP (foreground mode)
+    connect_rdp "$WIN_USER" "$WIN_PASS" false
+
+    # After RDP closes, stop the container unless --keep-alive was specified
+    if [[ "$KEEP_ALIVE" == false ]]; then
+      echo ""
+      echo "RDP session closed. Stopping Windows VM..."
+      docker-compose -f "$COMPOSE_FILE" stop
+      echo "Windows VM stopped."
+      echo ""
+      msg_info "Container is stopped but preserved for fast restart"
+      echo "   Quick start: omarchy-windows-vm launch"
+      echo "   Full cleanup: omarchy-windows-vm stop (removes container)"
+    else
+      echo ""
+      echo "RDP session closed. Windows VM is still running."
+      echo "To stop it: omarchy-windows-vm stop"
+    fi
   fi
+}
 
-  gum style \
-    --border normal \
-    --padding "1 2" \
-    --margin "1" \
-    --align center \
-    "Connecting to Windows VM" \
-    "" \
-    "$LIFECYCLE"
+stop_windows() {
+  check_vm_configured
 
-  # Detect display scale from Hyprland
-  HYPR_SCALE=$(hyprctl monitors -j | jq -r '.[] | select (.focused == true) | .scale')
-  SCALE_PERCENT=$(echo "$HYPR_SCALE" | awk '{print int($1 * 100)}')
+  # Check if GPU restore will be needed (read once, use multiple times)
+  local gpu_mode=""
+  [[ -r /var/run/omarchy-vm-gpu-mode ]] && gpu_mode=$(<"/var/run/omarchy-vm-gpu-mode") 2>/dev/null
 
-  RDP_SCALE=""
-  if [ "$SCALE_PERCENT" -ge 170 ]; then
-    RDP_SCALE="/scale:180"
-  elif [ "$SCALE_PERCENT" -ge 130 ]; then
-    RDP_SCALE="/scale:140"
+  # Pre-authenticate sudo immediately before docker operations
+  # (GPU restore needs sudo, better to ask upfront than mid-operation)
+  if [[ "$gpu_mode" == "vm" ]]; then
+    sudo -v
   fi
-  # If scale is less than 130%, don't set any scale (use default 100)
 
-  # Connect with RDP in fullscreen (auto-detects resolution)
-  xfreerdp3 /u:"$WIN_USER" /p:"$WIN_PASS" /v:127.0.0.1:3389 -grab-keyboard /sound /microphone /cert:ignore /title:"Windows VM - Omarchy" /dynamic-resolution /gfx:AVC444 /floatbar:sticky:off,default:visible,show:fullscreen $RDP_SCALE
-
-  # After RDP closes, stop the container unless --keep-alive was specified
-  if [ "$KEEP_ALIVE" = false ]; then
+  echo "Stopping Windows VM and removing container..."
+  docker-compose -f "$COMPOSE_FILE" down
+  echo "Windows VM stopped and container removed."
+  echo "(Container will be recreated fresh on next launch)"
+
+  # Phase 2: Auto-unbind GPU if it was bound for this VM
+  # NOTE: For AMD GPUs with "reset bug" (Vega, Fiji, Navi, etc.), we skip auto-unbind
+  # because these GPUs cannot be reliably rebound after unbind without a system reboot.
+  # The GPU stays in vm mode (vfio-pci) for the next VM session.
+  if [[ "$gpu_mode" == "vm" ]]; then
     echo ""
-    echo "RDP session closed. Stopping Windows VM..."
-    docker-compose -f "$COMPOSE_FILE" down
-    echo "Windows VM stopped."
-  else
+
+    if command -v omarchy-gpu-passthrough &>/dev/null; then
+      # Check if GPU has AMD reset bug (requires reboot to rebind to native driver)
+      # Affected: Vega 10/20, Fiji, Tonga, Hawaii, some Polaris, some Navi 10/14
+      local has_reset_bug=false
+      if command -v omarchy-gpu-passthrough-info &>/dev/null; then
+        if omarchy-gpu-passthrough-info needs-reset 2>/dev/null; then
+          has_reset_bug=true
+        fi
+      fi
+
+      if [[ "$has_reset_bug" == true ]]; then
+        # GPUs with reset bug: keep in vm mode (vfio-pci) for next session
+        msg_info "AMD GPU with reset bug: keeping in VM mode (vfio-pci)"
+        echo "   GPU stays ready for next VM session"
+        echo "   To use on host: reboot system, then: omarchy-gpu-passthrough mode host"
+        notify_silent "Windows VM" "GPU stays in VM mode (reset bug)" "normal"
+      else
+        # GPUs without reset bug: restore to none mode
+        echo "GPU passthrough detected - restoring GPU to host..."
+
+        # Verify GPU mode (marker may be stale after reboot)
+        local actual_mode=""
+        if command -v omarchy-gpu-passthrough-info &>/dev/null; then
+          actual_mode=$(omarchy-gpu-passthrough-info mode 2>/dev/null)
+        fi
+
+        if [[ "$actual_mode" == "vm" ]]; then
+          if omarchy-gpu-passthrough mode none 2>/dev/null; then
+            msg_success "GPU restored to mode=none"
+            notify_silent "Windows VM" "GPU restored to mode=none" "normal"
+          else
+            msg_warning "Failed to restore GPU"
+            echo "   You can manually restore: omarchy-gpu-passthrough mode none"
+            notify_silent "Windows VM" "Failed to restore GPU" "critical"
+          fi
+        else
+          msg_info "GPU already restored (marker was stale, actual mode: ${actual_mode:-none})"
+          # Clean up stale marker
+          sudo -n /usr/bin/rm -f /var/run/omarchy-vm-gpu-mode 2>/dev/null || true
+        fi
+      fi
+    else
+      msg_warning "GPU passthrough tools not found"
+      echo "   GPU may still be bound to vfio-pci"
+      echo "   Manual restore: omarchy-gpu-passthrough mode none"
+    fi
     echo ""
-    echo "RDP session closed. Windows VM is still running."
-    echo "To stop it: omarchy-windows-vm stop"
   fi
 }
 
-stop_windows() {
-  if [ ! -f "$COMPOSE_FILE" ]; then
-    echo "Windows VM not configured."
+show_compose() {
+  # Check if docker-compose.yml exists
+  if [[ ! -f "$COMPOSE_FILE" ]]; then
+    msg_error "Windows VM not configured"
+    echo "   Run: omarchy-windows-vm install"
     exit 1
   fi
 
-  echo "Stopping Windows VM..."
-  docker-compose -f "$COMPOSE_FILE" down
-  echo "Windows VM stopped."
+  # Extract configuration from existing docker-compose.yml
+  local SELECTED_RAM=$(grep 'RAM_SIZE:' "$COMPOSE_FILE" | awk '{print $2}' | tr -d '"')
+  local SELECTED_CORES=$(grep 'CPU_CORES:' "$COMPOSE_FILE" | awk '{print $2}' | tr -d '"')
+  local SELECTED_DISK=$(grep 'DISK_SIZE:' "$COMPOSE_FILE" | awk '{print $2}' | tr -d '"')
+  local USERNAME=$(grep 'USERNAME:' "$COMPOSE_FILE" | awk '{print $2}' | tr -d '"')
+  local PASSWORD=$(grep 'PASSWORD:' "$COMPOSE_FILE" | awk '{print $2}' | tr -d '"')
+
+  # Detect Looking Glass (check for kvmfr device)
+  local LG_ENABLED=false
+  if grep -q '/dev/kvmfr0' "$COMPOSE_FILE"; then
+    LG_ENABLED=true
+  fi
+
+  # Detect GPU passthrough (check for vfio devices)
+  local GPU_PASSTHROUGH_ENABLED=false
+  local GPU_PCI_ADDR=""
+  local GPU_IOMMU_GROUP=""
+  local GPU_IOMMU_DEVICES=""
+
+  if grep -q 'vfio-pci,host=' "$COMPOSE_FILE"; then
+    GPU_PASSTHROUGH_ENABLED=true
+
+    GPU_IOMMU_DEVICES=$(grep -oP 'vfio-pci,host=0000:\K[0-9a-f:.]+' "$COMPOSE_FILE" | tr '\n' ' ' | sed 's/ $//')
+    GPU_PCI_ADDR=$(echo "$GPU_IOMMU_DEVICES" | awk '{print $1}')
+
+    # Extract all IOMMU groups from devices section
+    # Returns comma-separated list of unique group numbers
+    GPU_IOMMU_GROUP=$(grep -oP '/dev/vfio/\K[0-9]+' "$COMPOSE_FILE" | sort -u | tr '\n' ',' | sed 's/,$//')
+  fi
+
+  # Detect IVSHMEM size (default 64)
+  local IVSHMEM_SIZE=64
+  if grep -q 'size=' "$COMPOSE_FILE"; then
+    IVSHMEM_SIZE=$(grep -oP 'size=\K[0-9]+' "$COMPOSE_FILE" | head -1)
+  fi
+
+  # Detect TPM (check for TPM: "Y")
+  local TPM_ENABLED=false
+  if grep -q 'TPM:.*Y' "$COMPOSE_FILE"; then
+    TPM_ENABLED=true
+  fi
+
+  # Generate docker-compose.yml to stdout
+  create_docker_compose_config "-" "$SELECTED_RAM" "$SELECTED_CORES" "$SELECTED_DISK" \
+    "$USERNAME" "$PASSWORD" "$LG_ENABLED" "$IVSHMEM_SIZE" \
+    "$GPU_PASSTHROUGH_ENABLED" "$GPU_PCI_ADDR" "$GPU_IOMMU_GROUP" "$GPU_IOMMU_DEVICES" \
+    "$TPM_ENABLED"
 }
 
 status_windows() {
-  if [ ! -f "$COMPOSE_FILE" ]; then
-    echo "Windows VM not configured."
-    echo "To set up: omarchy-windows-vm install"
-    exit 1
-  fi
+  check_vm_configured
 
-  CONTAINER_STATUS=$(docker inspect --format='{{.State.Status}}' omarchy-windows 2>/dev/null)
+  CONTAINER_STATUS=$(get_container_status)
 
-  if [ -z "$CONTAINER_STATUS" ]; then
+  if [[ -z "$CONTAINER_STATUS" ]]; then
     echo "Windows VM container not found."
     echo "To start: omarchy-windows-vm launch"
-  elif [ "$CONTAINER_STATUS" = "running" ]; then
+  elif [[ "$CONTAINER_STATUS" == "running" ]]; then
+    # Check if Looking Glass is available
+    LG_STATUS=""
+    if is_looking_glass_ready; then
+      LG_STATUS="Looking Glass: Available"
+    else
+      LG_STATUS="Looking Glass: Not installed"
+    fi
+
     gum style \
       --border normal \
       --padding "1 2" \
@@ -387,9 +3824,11 @@ status_windows() {
       "" \
       "Web interface: http://127.0.0.1:8006" \
       "RDP available: port 3389" \
+      "$LG_STATUS" \
       "" \
-      "To connect: omarchy-windows-vm launch" \
-      "To stop:    omarchy-windows-vm stop"
+      "To connect (RDP):          omarchy-windows-vm launch" \
+      "To connect (Looking Glass): omarchy-windows-vm launch --lg" \
+      "To stop:                   omarchy-windows-vm stop"
   else
     echo "Windows VM is stopped (status: $CONTAINER_STATUS)"
     echo "To start: omarchy-windows-vm launch"
@@ -402,44 +3841,52 @@ show_usage() {
   echo "Commands:"
   echo "  install              Install and configure Windows VM"
   echo "  remove               Remove Windows VM and optionally its data"
-  echo "  launch [options]     Start Windows VM (if needed) and connect via RDP"
+  echo "  launch [options]     Start Windows VM (if needed) and connect (RDP default, --lg for Looking Glass)"
   echo "                       Options:"
-  echo "                         --keep-alive, -k   Keep VM running after RDP closes"
+  echo "                         --keep-alive, -k        Keep VM running after RDP closes"
+  echo "                         --looking-glass, --lg   Connect via Looking Glass"
+  echo "                         --windowed, -w          Start Looking Glass in windowed mode"
   echo "  stop                 Stop the running Windows VM"
   echo "  status               Show current VM status"
+  echo "  show-compose         Display generated docker-compose.yml configuration (for testing/debugging)"
   echo "  help                 Show this help message"
   echo ""
   echo "Examples:"
   echo "  omarchy-windows-vm install           # Set up Windows VM for first time"
   echo "  omarchy-windows-vm launch            # Connect to VM (auto-stop on exit)"
   echo "  omarchy-windows-vm launch -k         # Connect to VM (keep running)"
+  echo "  omarchy-windows-vm show-compose      # View generated config without creating file"
   echo "  omarchy-windows-vm stop              # Shut down the VM"
 }
 
 # Main command dispatcher
 case "$1" in
-  install)
-    install_windows
-    ;;
-  remove)
-    remove_windows
-    ;;
-  launch|start)
-    launch_windows "$2"
-    ;;
-  stop|down)
-    stop_windows
-    ;;
-  status)
-    status_windows
-    ;;
-  help|--help|-h|"")
-    show_usage
-    ;;
-  *)
-    echo "Unknown command: $1" >&2
-    echo "" >&2
-    show_usage >&2
-    exit 1
-    ;;
+install)
+  install_windows
+  ;;
+remove)
+  remove_windows
+  ;;
+launch | start)
+  shift # Remove the command name from arguments
+  launch_windows "$@"
+  ;;
+stop | down)
+  stop_windows
+  ;;
+status)
+  status_windows
+  ;;
+show-compose)
+  show_compose
+  ;;
+help | --help | -h | "")
+  show_usage
+  ;;
+*)
+  echo "Unknown command: $1" >&2
+  echo "" >&2
+  show_usage >&2
+  exit 1
+  ;;
 esac
